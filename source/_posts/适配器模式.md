---
title: 适配器模式
excerpt: 适配器模式主要用于解决开发中接口之间的不兼容问题，比如说axios，它可以同时在浏览器环境和node环境中使用，且用户在调用它的api时，入参是相同的，这里使用的就是适配器模式来兼容
toc: true
tag: [前端, 设计模式]
categories:
- 前端
- 设计模式
---

适配器模式主要用于解决开发中接口之间的不兼容问题，比如说axios，它可以同时在浏览器环境和node环境中使用，且用户在调用它的api时，入参是相同的，这里使用的就是适配器模式来兼容
简单来说，适配器模式就是对外统一入参，出参和规则。

## 例子
现代浏览器提供了Fetch API来简化Ajax请求，比如说我们封装了一个请求类
```javascript
export default class HttpUtils {
  // get方法
  static get(url) {
    return new Promise((resolve, reject) => {
      // 调用fetch
      fetch(url)
        .then(response => response.json())
        .then(result => {
          resolve(result)
        })
        .catch(error => {
          reject(error)
        })
    })
  }

  // post方法，data以object形式传入
  static post(url, data) {
    return new Promise((resolve, reject) => {
      // 调用fetch
      fetch(url, {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        // 将object类型的数据格式化为合法的body参数
        body: this.changeData(data)
      })
        .then(response => response.json())
        .then(result => {
          resolve(result)
        })
        .catch(error => {
          reject(error)
        })
    })
  }

  // body请求体的格式化方法
  static changeData(obj) {
    var prop,
      str = ''
    var i = 0
    for (prop in obj) {
      if (!prop) {
        return
      }
      if (i == 0) {
        str += prop + '=' + obj[prop]
      } else {
        str += '&' + prop + '=' + obj[prop]
      }
      i++
    }
    return str
  }
}
```
如果此时项目中存在使用`XMLHttpRequest`来请求ajax的接口，我们可以封装一个适配器，用来将所有XHR请求转化为新的Fetch请求
```javascript
// Ajax适配器函数，入参与旧接口保持一致
async function AjaxAdapter(type, url, data, success, failed) {
    const type = type.toUpperCase()
    let result
    try {
         // 实际的请求全部由新接口发起
         if(type === 'GET') {
            result = await HttpUtils.get(url) || {}
        } else if(type === 'POST') {
            result = await HttpUtils.post(url, data) || {}
        }
        // 假设请求成功对应的状态码是1
        result.statusCode === 1 && success ? success(result) : failed(result.statusCode)
    } catch(error) {
        // 捕捉网络错误
        if(failed){
            failed(error.statusCode);
        }
    }
}

// 用适配器适配旧的Ajax方法
async function Ajax(type, url, data, success, failed) {
    await AjaxAdapter(type, url, data, success, failed)
}
```
