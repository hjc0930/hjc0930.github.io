---
title: 拖拽
excerpt: 可拖拽元素是HTML5的新特性，它让我们可以对页面上任意一个元素进行拖拽
toc: true
tag: HTML
categories:
- 前端
- HTML
---

## 1.draggable属性
现代浏览器中，图片标签是可以被长按拖拽的，如果需要让自定义DOM节点可以被拖拽，需要配置`draggable`全局标签属性
当元素设置的draggable属性，就可以被自由拖拽了
## 2.Drag & Drop事件
HTML 的 drag & drop 使用了“**DOM Event**”和从“**Mouse Event**”继承而来的“**drag event**”
**一个典型的拖拽操作：** 用户选中一个可拖拽的（draggable）元素，并将其拖拽（鼠标按住不放）至一个可放置的（droppable）元素上，然后松开鼠标。
在拖动元素期间，一些与拖放相关的事件会被触发，像 drag 和 dragover 类型的事件会被频繁触发。
除了定义拖拽事件类型，每个事件类型还赋予了对应的事件处理器

| 事件类型 | 事件处理器 | 触发时机 | 绑定元素 |
| --- | --- | --- | --- |
| dragstart | ondragstart | 当开始拖动一个元素时 | 拖拽 |
| drag | ondrag | 当元素被拖动期间按一定频率触发 | 拖拽 |
| dragend | ondragend | 当拖动的元素被释放（🖱️松开、按键盘 ESC）时 | 拖拽 |
| dragenter | ondragenter | 当拖动元素到一个可释放目标元素时 | 放置 |
| dragover | ondragover | 当元素被拖到一个可释放目标元素上时（100 ms/次） | 放置 |
| dragexit | ondragexit | 当元素变得不再是拖动操作的选中目标时 | 放置 |
| dragleave | ondragleave | 当拖动元素离开一个可释放目标元素 | 放置 |
| drop | ondrop | 当拖动元素在可释放目标元素上释放时 | 放置 |

各个事件的时机可以用下面这个图简单表示：
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26434275/1662172588600-903f7bb8-9ccd-4d02-9879-5c55d032479b.png#averageHue=%23fafafa&clientId=ue1ca1322-96a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=674&id=u562b56cd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=674&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116394&status=done&style=none&taskId=uf999364e-978e-4062-8b1c-9d082401da5&title=&width=936)
**⚠️注意：** [dragOver](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FDocument%2Fdragover_event) 事件的默认行为是：“Reset the current drag operation to "none"”。也就是说，如果不阻止放置元素的 dragOver 事件，则放置元素不会响应“拖动元素”的“放置行为”
## 3.DataTransfer
在上述的事件类型中，不难发现，放置元素和拖动元素分别绑定了自己的事件，可如何将拖拽元素和放置元素**建立联系**以及**传递数据**？
这就涉及到 DataTransfer 对象：
DataTransfer 对象用于保存拖动并放下（drag and drop）过程中的数据。它可以保存一项或多项数据，这些数据项可以是一种或者多种数据类型。 —— [DataTransfer - MDN](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FDataTransfer)
### (1) 属性
| 属性 | 说明 |
| --- | --- |
| dropEffect | 获取当前选定的拖放操作类型或者设置的为一个新的类型。值为：none、copy、link、move |
| effectAllowed | 提供所有可用的操作类型。值是：none、copy、copyLink、copyMove、link、linkMove、move、all、uninitialized |
| files | 包含数据传输中可用的所有本地文件的列表。如果拖动操作不涉及拖动文件，则此属性为空列表 |
| items (只读) | 提供一个包含所有拖动数据列表的 DataTransferItemList 对象 |
| types (只读) | 提供一个 dragstart 事件中设置的格式的 strings 数组。 |

### (2) 方法
| 属性 | 说明 |
| --- | --- |
| setData(format, value) | 设置给定类型的数据。如果该类型的数据不存在，则将其添加到末尾，以便类型列表中的最后一项将是新的格式。如果该类型的数据已经存在，则在相同位置替换现有数据。 |
| getData(format) | 检索给定类型的数据，如果该类型的数据不存在或 data transfer 不包含数据，则返回空字符串 |
| clearData([format]) | 删除与给定类型关联的数据。类型参数是可选的。如果类型为空或未指定，则删除与所有类型关联的数据。如果指定类型的数据不存在，或者 data transfer 中不包含任何数据，则该方法不会产生任何效果。 |
| setDragImage(img,element, xOffset, yOffset) | 设置自定义的拖动图像，注意图像需要提前加载，否则会无效 |

## 4.手写一个拖拽列表
### vue
```vue
<script setup lang="ts">
import { ref } from 'vue'

const MOCK_LIST_DATA = new Array(10).fill(0).map((_, index) => ({
  id: Math.random().toString(36).slice(-6),
  val: `初始顺序: ${index}`
}))

const mockListData = ref(MOCK_LIST_DATA);
const dragId = ref("");

// 替换数据
const move = (dragId: string, dropId: string) => {
  if (!dragId || !dropId) return;
  const dragIndex = mockListData.value.findIndex(item => item.id === dragId);
  const dropIndex = mockListData.value.findIndex(item => item.id === dropId);

  const originData = mockListData.value.splice(dragIndex, 1)[0];

  mockListData.value.splice(dropIndex, 0, originData);

}
// 拖拽开始时
const onDragStart = (e) => {
  dragId.value = e.currentTarget.dataset.id;
}
// 拖拽进行中
const onDrag = (e) => {
  e.currentTarget.style.opacity = "0";
}
// 拖拽结束
const onDragEnd = (e) => {
  e.currentTarget.style.opacity = "1"
}
// 当移动到可以被放置的元素时
const onDragOver = (e) => {
  const dropId = e.currentTarget.dataset.id;
  if (dragId === dropId) return;

  const dragIndex = mockListData.value.findIndex(item => item.id === dragId.value);
  const dropIndex = mockListData.value.findIndex(item => item.id === dropId);
  e.currentTarget.classList.remove("drop-up", "drop-down");
  if (dragIndex < dropIndex) {
    e.currentTarget.classList.add("drop-down");
  } else if (dragIndex > dropIndex) {
    e.currentTarget.classList.add("drop-up");
  }
  move(dragId.value, dropId);
}
</script>

<template>
  <div class="sortable-page">
    <h1>基于 HTML5 原生拖拽事件的拖拽列表</h1>
    <div className="list-container">
      <div @dragstart="onDragStart" @drag="onDrag" @dragend="onDragEnd" @dragover.prevent="onDragOver" class="item"
        v-for="item in mockListData" :key="item.id" :data-id="item.id" draggable="true">
        <div>ID: {{ item.id }}</div>
        <div> {{ item.val }}</div>
      </div>
    </div>
  </div>
</template>

<style scoped lang="scss">
.sortable-page {
  position: relative;
  width: 100%;
  min-height: 100vh;
  background-color: #ececec;
  display: flex;
  align-items: center;
  flex-direction: column;
  justify-content: center;

  &>.list-container {
    margin: 40px auto;
    width: 400px;
    min-height: 600px;
    padding: 10px 20px;
    background-color: #fff;
    border-radius: 4px;
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;

    .item {
      position: relative;
      box-sizing: border-box;
      height: 50px;
      padding: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #fff;
      cursor: grab;
      user-select: none;

      &.drop-up {
        animation: dropUp 0.3s ease-in-out forwards;
      }

      &.drop-down {
        animation: dropDown 0.3s ease-in-out forwards;
      }

      &.border-top {
        border-top: 2px solid red;
      }
    }
  }
}

@keyframes dropUp {
  100% {
    transform: translateY(5px);
  }
}

@keyframes dropDown {
  100% {
    transform: translateY(-5px);
  }
}
</style>

```
### react
```tsx
import React, { useState } from "react";
import { cloneDeep, findIndex, isEqual } from "lodash-es";
import update from "immutability-helper";
import "./App.less";

const MOCK_LIST_DATA = new Array(10).fill(0).map((_, idx) => ({
  id: Math.random().toString(36).slice(-6),
  val: `初始顺序：${idx}`,
}));

interface ItemProps {
  index: string;
  val: string;
  handleDragStart: React.DragEventHandler<HTMLDivElement>;
  handleDragOver: React.DragEventHandler<HTMLDivElement>;
  handleDrag: React.DragEventHandler<HTMLDivElement>;
  handleDragEnd: React.DragEventHandler<HTMLDivElement>;
}

const Item: React.FC<ItemProps> = React.memo((props) => {
  const {
    index,
    val,
    handleDrag,
    handleDragEnd,
    handleDragOver,
    handleDragStart,
  } = props;

  return (
    <div
      className="item"
      draggable
      onDragStart={handleDragStart}
      onDragOver={handleDragOver}
      onDrag={handleDrag}
      onDragEnd={handleDragEnd}
      onDragLeave={(e) => {
        e.currentTarget.classList.remove("border-top");
      }}
      data-index={index}
    >
      <div>ID: {index}</div>
      <div>{val}</div>
    </div>
  );
});

const SortableListPage = () => {
  const [listData, setListData] = useState(MOCK_LIST_DATA);
  const [dragId, setDragId] = useState<string | undefined>("");

  const move = (dragId?: string, dropId?: string) => {
    if (!dragId || !dropId) return;
    const dragIndex = findIndex(listData, (i) => i.id === dragId);
    const dropIndex = findIndex(listData, (i) => i.id === dropId);

    const originItem = listData.splice(dragIndex, 1)[0];
    listData.splice(dropIndex, 0, originItem);

    setListData([...listData]);
  };

  // 源对象开始拖拽
  const handleDragStart = (e: React.DragEvent<HTMLDivElement>) => {
    e.dataTransfer.effectAllowed = "move";
    setDragId(e.currentTarget.dataset.index);
  };

  // 源对象在目标对象上方时
  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault(); // 允许放置，阻止默认事件
    // 设置动画
    const dropId = e.currentTarget.dataset.index;

    if(dragId === dropId) return;

    const dragIndex = findIndex(listData, (i) => i.id === dragId);
    const dropIndex = findIndex(listData, (i) => i.id === dropId);
    e.currentTarget.classList.remove("drop-up", "drop-down");
    if (dragIndex < dropIndex) {
      e.currentTarget.classList.add("drop-down");
    } else if (dragIndex > dropIndex) {
      e.currentTarget.classList.add("drop-up");
    }

    move(dragId, dropId);
  };

  // 源对象被拖拽过程中
  const handleDrag = (e: React.DragEvent<HTMLDivElement>) => {
    e.currentTarget.style.opacity = "0";
  };

  // 源对象被放置完成时
  const handleDragEnd = (e: React.DragEvent<HTMLDivElement>) => {
    e.currentTarget.style.opacity = "1";
  };

  return (
    <div className="sortable-page">
      <h1>基于 HTML5 原生拖拽事件的拖拽列表</h1>
      <div className="list-container">
        {listData.map((i) => (
          <Item
            key={i.id}
            index={i.id}
            val={i.val}
            handleDragStart={handleDragStart}
            handleDragOver={handleDragOver}
            handleDrag={handleDrag}
            handleDragEnd={handleDragEnd}
          />
        ))}
      </div>
    </div>
  );
};

export default SortableListPage;
```
```less
.sortable-page {
  position: relative;
  width: 100%;
  min-height: 100vh;
  background-color: #ececec;
  display: flex;
  align-items: center;
  flex-direction: column;
  justify-content: center;

  & > .list-container {
    margin: 40px auto;
    width: 400px;
    min-height: 600px;
    padding: 10px 20px;
    background-color: #fff;
    border-radius: 4px;
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;

    .item {
      position: relative;
      box-sizing: border-box;
      height: 50px;
      padding: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #fff;
      cursor: grab;
      user-select: none;

      &.drop-up {
        animation: dropUp 0.3s ease-in-out forwards;
      }
      &.drop-down {
        animation: dropDown 0.3s ease-in-out forwards;
      }

      &.border-top {
        border-top: 2px solid red;
      }
    }
  }
}

@keyframes dropUp {
  100% {
    transform: translateY(5px);
  }
}

@keyframes dropDown {
  100% {
    transform: translateY(-5px);
  }
}

```
### React-dnd
```bash
yarn add react-dnd react-dnd-html5-backend
```
```tsx
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';

// App.tsx
function App() {
  return (
    <DndProvider backend={ HTML5Backend }>
        <Demo />
    </DndProvider>
  )
}

// Demo.tsx
import React, { useState, useRef } from "react";
import { useDrag, useDrop } from "react-dnd";

const mockData = new Array(10).fill(0).map((_, index) => ({
  id: Math.random().toString(36).slice(-6),
  val: `初始位置: ${index}`,
}));

const Item = ({ val, id, move }: any) => {
  const ref = useRef<HTMLDivElement>(null);
  const [, drag, dragPreview] = useDrag({
    type: "Item",
    item: () => ({
      id,
    }),
  });

  const [, drop] = useDrop({
    accept: "Item",
    hover: (item: any, monitor) => {
      const dragId = item.id;
      const dropId = id;

      if (dragId === dropId) return;
      move(dragId, dropId)
    },

  });

  dragPreview(drag(drop(ref)));

  return (
    <div
      ref={ref}
      style={{
        width: "200px",
        lineHeight: "40px",
        cursor: "grab",
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
      }}
    >
      <div>ID: {id}</div>
      <div>{val}</div>
    </div>
  );
};

function Demo() {
  const [dataList, setDataList] = useState(mockData);

  const move = (dragId: string, dropId: string) => {
    const dragIndex = dataList.findIndex((item) => item.id === dragId);
    const dropIndex = dataList.findIndex((item) => item.id === dropId);
    const originData = dataList.splice(dragIndex, 1)[0];
    dataList.splice(dropIndex, 0, originData);

    setDataList([...dataList]);
  };

  return (
    <>
      {dataList.map((item) => (
        <Item key={item.id} id={item.id} val={item.val} move={move} />
      ))}
    </>
  );
}

export default Demo;

```

