{"posts":[{"title":"express连接mongoDB实例","text":"1.创建连接12345678910111213141516171819202122232425262728// utils/mongoConfig.jsconst mongoose = require('mongoose');// 创建连接实例const mongoUrl = 'mongodb://admin:123456@127.0.0.1:27017/express-test?authSource=admin';mongoose.connect(mongoUrl, { useNewUrlParser: true, useUnifiedTopology: true });// 创建User集合连接const UserSchema = mongoose.Schema({ name: String, age: Number});const User = mongoose.model('User', UserSchema, 'user');// 创建student集合连接const StudentSchema = mongoose.Schema({ name: String, grade: Number, class: String});const Student = mongoose.model('Student', StudentSchema, 'student');module.exports = { User, Student}; 2.使用12345678910111213141516171819// routers/index.jsrouter.get('/mongo', async (req, res) =&gt; { const result = await User.aggregate([ { $lookup: { from: 'student', localField: 'name', foreignField: 'name', as: 'item' } }, { $project: {'name':1,'age':1,'item.grade':1,'item.class':1} }, { $group: { _id:&quot;$item.class&quot;, count:{$sum: 1} } } ]) res.send(result);})","link":"/NodeJs/%E6%A1%86%E6%9E%B6/Express/5.express%E8%BF%9E%E6%8E%A5mongoDB%E5%AE%9E%E4%BE%8B/"},{"title":"express连接mysql实例","text":"1.express安装1npm i express express-generator -g 2.nodemon安装1npm i nodemon --save 修改package.json 12345{ &quot;script&quot;: { &quot;start&quot;: &quot;nodemon ./bin/www&quot; }} 3.操作mysql 安装mysql1npm i mysql --save 配置123456789101112131415161718192021222324252627282930// utils/dbConfig.jsconst mysql = require('mysql');// 数据库连接配置const config = { host: '127.0.0.1', port: '3306', user: 'root', password: '123456', database: 'test'}// 使用连接池连接mysqlmodule.exports = { sqlConnection: ({sql,sqlArr,callBack}) =&gt; { // 创建连接池 const pool = mysql.createPool(config); pool.getConnection((err,conn) =&gt; { if(err) { console.log(err); return; } // 事件驱动回调 conn.query(sql,sqlArr,callBack); // 释放连接 conn.release(); }) }} 操作数据库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// routes/index.jsconst express = require('express');const router = express.Router();const mysql = require('../utils/dbConfig');/** * 获取所有信息 */router.get('/', (req,res) =&gt; { mysql.sqlConnection({ sql: 'select * from user', sqlArr: [], callBack: (err,data) =&gt; { if(err) { console.log(err); return; } res.send(data); } })});/** * 通过用户名和密码获取信息 * @body name * @body password */router.post('/user',(req,res) =&gt; { const { name, password } = req.body; if(name &amp;&amp; password) { mysql.sqlConnection({ sql: 'select * from user where name=? and password=?', sqlArr: [name,password], callBack: (err,data) =&gt; { if(err) { console.log(err); return; } res.send(data); } }); }});module.exports = router; 4.接口测试 VS Code安装REST Client插件 新建 .http文件 测试12345678910111213@url=http://127.0.0.1:3000@json=Content-Type: application/json###Get {{url}}/###POST {{url}}/user{{json}}{ &quot;name&quot;: &quot;小明&quot;, &quot;password&quot;: &quot;123456&quot;} 5.优化配置 数据库配置优化123456789101112131415161718192021222324252627282930313233343536// utlis/dbConfig.jsconst mysql = require('mysql');// 数据库连接配置const config = { host: '127.0.0.1', port: '3306', user: 'root', password: '123456', database: 'test'}// 使用连接池连接mysqlmodule.exports = { sqlConnection: (sql, sqlArr = []) =&gt; { // 创建Promise对象 return new Promise((resolve, reject) =&gt; { // 创建连接池 const pool = mysql.createPool(config); // 运行结果操作 pool.getConnection((err,conn) =&gt; { // 返回错误信息 err &amp;&amp; reject(err); // 事件驱动回调 conn.query(sql, sqlArr, (err, result) =&gt; { // 返回错误信息 err &amp;&amp; reject(err); // 返回查询结果 resolve(result); }) // 释放连接 conn.release(); }) }) }} 使用优化123456789101112131415// router/index.jsconst express = require('express');const router = express.Router();// const userController = require('../controller/user');const mysql = require('../utils/dbConfig');router.get('/', async (req, res) =&gt; { const sql = 'select * from user'; const result = await mysql.sqlConnection(sql); res.send(result);});module.exports = router; 6.分层操作 service1234567891011121314// service/userServiceconst mysql = require('../utils/dbConfig');class userService { getUser = async () =&gt; { const sql = 'select * from user'; const result = await mysql.sqlConnection(sql); return result; }}module.exports = new userService(); controller123456789101112// controller/userControllerconst userService = require('../service/user');class UserController { getUser = async (req, res) =&gt; { const result = await userService.getUser(); res.send(result); }}module.exports = new UserController(); router123456789// routerconst express = require('express');const router = express.Router();const userController = require('../controller/user');router.get('/', userController.getUser);module.exports = router;","link":"/NodeJs/%E6%A1%86%E6%9E%B6/Express/4.express%E8%BF%9E%E6%8E%A5mysql%E5%AE%9E%E4%BE%8B/"},{"title":"express编写接口","text":"routes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require('express');const router = express.Router();const mysql = require('../utils/dbconfig');/* GET home page. */router.get('/', (req,res) =&gt; { mysql.sqlConnection({ sql: 'select * from user', sqlArr: [], callBack: (err,data) =&gt; { if(err) { console.log(err); return; } res.send(data); } });});router.get('/user',(req,res) =&gt; { const { id } = req.query; mysql.sqlConnection({ sql: 'select * from user where id=?', sqlArr: [id], callBack: (err,data) =&gt; { if(err) { console.log(err); return; } res.send(data); } });});router.post('/userpost', (req,res) =&gt; { const {name,password} = req.body; console.log(name+'---'+password);});router.post('/userpost/:id',(req,res) =&gt; { const {id} = req.params; console.log(id);});module.exports = router; app.js1234567891011121314151617181920212223const express = require('express');const path = require('path');const cookieParser = require('cookie-parser');const logger = require('morgan');const cors = require('cors');// 导入路由const indexRouter = require('./routes/index');const app = express();app.use(logger('dev'));app.use(express.json());app.use(express.urlencoded({ extended: false }));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));app.use(cors());// 使用路由app.use('/', indexRouter);module.exports = app;","link":"/NodeJs/%E6%A1%86%E6%9E%B6/Express/3.%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3/"},{"title":"mysql的使用","text":"mysql 安装 1npm i mysql --save 配置 123456789101112131415161718192021222324252627const mysql = require('mysql');// 连接数据库配置const config = { host: 'localhost', port: '3306', user: 'root', password: '123456', database: 'test'}// 创建数据库连接池module.exports = { sqlConnection: (sql,sqlArr,callBack) =&gt; { const pool = mysql.createPool(config); pool.getConnection((err,conn) =&gt; { if(err) { console.log(err); return; } // 事件驱动回调 conn.query(sql,sqlArr,callBack); // 关闭连接池 conn.release(); }) }}","link":"/NodeJs/%E6%A1%86%E6%9E%B6/Express/2.%E4%BD%BF%E7%94%A8mysql/"},{"title":"Egg、Midway系列相关笔记","text":"1.mysql 安装 1npm install egg-mysql -S 配置 123456789101112131415161718192021222324252627// /config/plugin.tsmysql: { enable: true, package: 'egg-mysql',},//config/config.default.ts// mysqlconfig.mysql = { // 单数据库信息配置 client: { // host host: '127.0.0.1', // 端口号 port: '3306', // 用户名 user: 'root', // 密码 password: '123456', // 数据库名 database: 'test', }, // 是否加载到 app 上，默认开启 app: true, // 是否加载到 agent 上，默认关闭 agent: false,}; 2.cors 安装 1npm i egg-cors -S 配置 123456789101112131415161718192021// /config/plugin.tscors: { enable: true, package: 'egg-cors',},//config/config.default.ts // 跨域 config.security = { csrf: { //关闭csrf enable: false, ignoreJSON: true, }, domainWhiteList: [ 'http://127.0.0.1:8000','http://127.0.0.1:5500' ], // 配置白名单 }; config.cors = { // origin: '*', //允许所有跨域访问，注释掉则允许上面 白名单 访问 credentials: true, // 允许 Cookie 跨域 allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS', }; 3.csrf12345//config/config.default.ts//单独关闭csrfconfig.security = { csrf: false,};","link":"/NodeJs/%E6%A1%86%E6%9E%B6/Egg_Midway/1.%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"title":"静态服务器的路由实现","text":"1.封装web静态服务器1.在routes.js中重新暴露一个方法，名为static12345678910111213141516171819202122232425262728293031323334353637const fs = require('fs');const path = require('path');const url = require('url');// 私有方法let getMime = (extName) =&gt; { let data = fs.readFileSync('./data/mime.json'); let mimeObj = JSON.parse(data.toString()); return mimeObj[extName];}//封装的web静态服务exports.static = (req, res, staticPath) =&gt; { /* / /favicon.ico */ //获取url中的路径(pathname) let pathname = url.parse(req.url).pathname; // 获取路径中的后缀名 let extName = path.extname(pathname); pathname = pathname == '/' ? '/index.html' : pathname; // 获得正确的路径 if (pathname != '/favicon.ico') { try { // 读取对应文件夹下的文件并传给浏览器 let data = fs.readFileSync('./' + staticPath + pathname); if (data) { // 获取对应后缀名的响应头 let mimeName = getMime(extName); res.writeHead(200, {'Content-Type':''+mimeName+';charset=utf-8'}); res.end(data); } } catch (error) { } }} 2.在app.js中调用该方法并且实现简单的路由访问123456789101112131415161718192021222324252627282930const http = require('http');const routes = require('./module/routes');const url = require('url');http.createServer((req,res)=&gt;{ // 创建静态web服务 routes.static(req,res,'state'); // 路由 let pathname = url.parse(req.url).pathname; if(pathname == '/login'){ res.writeHead(200,{'Content-Type':'text/html;charset=utf-8'}); res.end(&quot;执行登录&quot;); }else if(pathname == '/register'){ res.writeHead(200,{'Content-Type':'text/html;charset=utf-8'}); res.end(&quot;执行注册&quot;); }else if(pathname == '/admin'){ res.writeHead(200,{'Content-Type':'text/html;charset=utf-8'}); res.end(&quot;执行后端操作&quot;); }else{ res.writeHead(404,{'Content-Type':'text/html;charset=utf-8'}); res.end(&quot;页面不存在&quot;); }}).listen(8080);console.log(&quot;http://127.0.0.1:8080&quot;);","link":"/NodeJs/9.node%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1/"},{"title":"使用node搭建简单的静态web服务器","text":"1.说明1.获取url中的pathname属性路径有两种，要获得正确的路径 12345/* / /favicon.ico*///获取url中的路径(pathname)let pathname = url.parse(req.url).pathname; 2.通过fs中readFile()方法来获得对应的文件并传回浏览器12345678910111213// 读取对应文件夹下的文件并传给浏览器fs.readFile('./state'+pathname,async (err,data)=&gt;{ if(err){ console.log(err); res.writeHead(404,{'Content-Type':'text/html;charset:utf-8'}); res.end('404'); return; } // 获取对应后缀名的响应头 let mimeName = await common.getMime(extName); res.writeHead(200,{'Content-Type':''+mimeName+';charset:utf-8'}); res.end(data);}) 3.在获得文件的过程中同时要确定相应的响应头12// 获取对应后缀名的响应头let mimeName = await common.getMime(extName); 4.获取响应头的模块12345678910111213141516// 引入一个后缀名和响应头映射的文件来返回响应头的格式exports.getFileMime = (extname) =&gt;{ //使用Promise对象来获得异步方法中的数据 return new Promise((resolve,reject)=&gt;{ //调用readFile()方法，查询mime.json中是否有传入的后缀名对应的响应头 fs.readFile('./data/mime.json',(err,data)=&gt;{ if(err){ console.log(err); reject(err); return; } let mimeObj = JSON.parse(data.toString()); resolve(mimeObj[extname]); }) })} 4.1.也可以使用fs.readFileSync()方法来获取，该方法为同步方法 2.服务器代码123456789101112131415161718192021222324252627282930313233343536const http = require('http');const fs = require('fs');const path = require('path');const url = require('url');const common = require('./module/common');http.createServer((req,res)=&gt;{ /* / /favicon.ico */ //获取url中的路径(pathname) let pathname = url.parse(req.url).pathname; // 获取路径中的后缀名 let extName = path.extname(pathname); pathname = pathname=='/' ? '/index.html':pathname; // 获得正确的路径 if(pathname != '/favicon.ico'){ // 读取对应文件夹下的文件并传给服务器 fs.readFile('./state'+pathname,async (err,data)=&gt;{ if(err){ console.log(err); res.writeHead(404,{'Content-Type':'text/html;charset:utf-8'}); res.end('404'); return; } // 获取对应后缀名的响应头 let mimeName = await common.getMime(extName); res.writeHead(200,{'Content-Type':''+mimeName+';charset:utf-8'}); res.end(data); }) }}).listen(8080);console.log(&quot;http://127.0.0.1:8080&quot;); 3.查询响应头代码12345678910111213141516// 引入一个后缀名和响应头映射的文件来返回响应头的格式exports.getFileMime = (extname) =&gt;{ //使用Promise对象来获得异步方法中的数据 return new Promise((resolve,reject)=&gt;{ //调用readFile()方法，查询mime.json中是否有传入的后缀名对应的响应头 fs.readFile('./data/mime.json',(err,data)=&gt;{ if(err){ console.log(err); reject(err); return; } let mimeObj = JSON.parse(data.toString()); resolve(mimeObj[extname]); }) })}","link":"/NodeJs/8.%E4%BD%BF%E7%94%A8node%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9D%99%E6%80%81web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"管道流的使用","text":"1.读取流 2.写入流 3.管道流管道流值将一个文件读取并写入到另一个文件中的流程","link":"/NodeJs/7.fs%E4%B8%AD%E7%9A%84%E6%B5%81%E4%BB%A5%E5%8F%8A%E7%AE%A1%E9%81%93%E6%B5%81/"},{"title":"ES6常用语法","text":"1.let和const用let声明的变量具备块级作用域，用const声明的变量为常量 12345678910111213var a = 1;{ var a = 2;}console.log(a); //2let a = 1;{ let a = 2;}console.log(a); //1const PI = 3.14; //是常量，不能改变其值 2.ES6中语法的简写对象属性的简写 12345//如果对象属性名和某个要赋值的变量名相同，则可以直接写对象属性名name = &quot;小明&quot;let obj = { name;} 对象方法的简写 123456789//写对象方法时，可以省略functionlet obj = { a: 1, b: 2, add(){ return this.a + this.b; }}console.log(obj.add()); 3.获取异步方法中的值es6之前，可以通过回调函数来获取异步方法中的值 12345678910function getData(callbck){ setTimeout(function(){ let name = &quot;小明&quot;; callbck(name); },1000);}getData(function(a){ console.log(a);}) es6之后，可以通过Promise来获取 1234567891011121314151617181920212223242526//写法一let p = new Promise((resolve,reject)=&gt;{ setTimeout(function(){ let name = &quot;小明&quot;; resolve(name); },1000);})//通过then方法获取resolve中的值p.then(function(data){ console.log(data);})//写法二//定义一个函数，传入参数resolve和rejectfunction getData(resolve,reject){ setTimeout(function(){ let name = &quot;小明&quot;; resolve(name); },1000);}//将该函数传给Promise对象let p = new Promise(getData);//通过then来获取值p.then(function(data){ console.log(data);}) 通过async和await来获取异步数据 123456789101112//1.通过async声明的方法为异步方法，返回值为Promise对象async function test(){ return &quot;Hello World&quot;;}console.log(test()); // Promise{&quot;Hello world&quot;}//2.可以通过await来直接获取异步方法中的内容async function getData(){ let d = await test(); console.log(d);}getData(); 案例async和await配合Promise使用 12345678910111213function test(){ return new Promise((res,rej)=&gt;{ setTimeout(function(){ let name = &quot;小明&quot;; res(name); },1000); })}async function getData(){ let data = await test(); console.log(data);} 通过async_await判断wwwroot下有几个目录 12345678910111213141516171819202122232425262728293031323334353637// 判断wwwroot文件夹下所有的文件，若是文件夹，则存到一个数组中const fs = require('fs');function getDir(path){ return new Promise((res,rej)=&gt;{ fs.stat(path,(err,data)=&gt;{ if(err){ console.log(err); rej(err); return; } if(data.isDirectory()){ res(true); }else{ res(false); } }) })}function main(){ let path = './wwwroot'; let dirArr = []; fs.readdir(path,async (err,data)=&gt;{ if(err){ console.log(err); return; } for(let i = 0; i &lt; data.length; i++){ if(await getDir(path + '/' + data[i])){ dirArr.push(data[i]); } } console.log(dirArr); })}main();","link":"/NodeJs/6.async.await%E5%92%8Ces6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95/"},{"title":"fs模块的使用","text":"1.fs模块功能介绍 1.fs.stat()检查是文件还是目录 12345678910111213141516171819202122const fs = require('fs');/* fs.stat() 第一个参数：要检测的路径 第二个参数：回调函数：err:返回错误信息，data：返回检测结果*/fs.stat('./html',(err,data)=&gt;{ // 返回错误信息 if(err){ console.log(err); return; } // 如果data.isFile()为true则为文件，如果 data.isDirectory()为true则为目录 if(data.isFile()){ console.log(&quot;是文件&quot;); }else if(data.isDirectory()){ console.log(&quot;是目录&quot;); }}) 2.fs.mkdir()创建目录 1234567891011121314/* fs.mkdir() path:要创建目录的路径 mode:目录读写权限，可不写，默认为777 callback:回调函数，传递异常参数err*/fs.mkdir('./css',(err)=&gt;{ if(err){ console.log(err); return; } console.log(&quot;创建成功&quot;);}) 3.fs.writeFile()创建写入文件 1234567fs.writeFile('./html/index.html','hello',(err)=&gt;{ if(err){ console.log(err); return; } console.log(&quot;创建成功&quot;);}) 4.fs.appendFile()追加文件 123456789// fs.appendFile()fs.appendFile('./css/commit.css','body{color:red}\\nh2{font-size:16px}\\n*{margin:0}',(err)=&gt;{ if(err){ console.log(err); return; } console.log(&quot;appendFile成功&quot;);}) 5.fs.readFile()读取文件 12345678910// fs.readFile()fs.readFile('./html/index.html',(err,data)=&gt;{ if(err){ console.log(err); return; } console.log(data);//Buffer console.log(data.toString());}) 6.fs.readdir()读取目录 12345678// fs.readdirfs.readdir('./html',(err,files)=&gt;{ if(err){ console.log(err); return; } console.log(files);}) 7.fs.rename()重命名/移动文件 1234567891011121314151617// fs.rename 功能1：重命名文件，功能2：移动文件//1.重命名fs.rename('./css/aaa.css','./css/bbb.css',(err)=&gt;{ if(err){ console.log(err); return; } console.log(&quot;rename成功&quot;);})//2.移动fs.rename('./css/bbb.css','./html/bbb.css',(err)=&gt;{ if(err){ console.log(err); return; } console.log(&quot;rename成功&quot;);}) 8.fs.unlink(),fs.rmdir()删除文件，删除目录 1234567891011121314151617// fs.unlink() fs.rmdir()//删除文件fs.unlink('./html/bbb.css',(err)=&gt;{ if(err){ console.log(err); return; } console.log(&quot;删除文件成功&quot;);})//删除目录fs.rmdir('./bbb',(err)=&gt;{ if(err){ console.log(err); return; } console.log(&quot;删除目录成功&quot;);}) 【注】如果目录下有文件，则必须删除文件后才能删除目录，直接删除会失败 2.案例1.创建upload目录判断服务器中是否有upload目录，若没有，则创建它，若有，则不做任何操作 12345678910111213141516171819202122232425262728293031323334const fs = require('fs');let path = './upload';fs.stat(path,(err,data)=&gt;{ //判断目录/文件是否已存在，若不存在则直接创建 if(err){ mkdir(path); return; } //判断已存在的文件/目录属性，若是文件则先删除文件在创建，若是目录则不用创建 if(data.isFile()){ fs.unlink(path,(err)=&gt;{ if(!err){ mkdir(path); return; } }); }else if(data.isDirectory()){ console.log(&quot;该目录已存在&quot;); }})//创建文件方法function mkdir(path){ fs.mkdir(path,(err)=&gt;{ if(err){ console.log(err); return; }else{ console.log(&quot;创建成功&quot;); } })} 通过第三方模块mkdirp创建 1234/* cnpm i mkdirp --save */const mkdirp = require('mkdirp');mkdirp('./upload').then(made =&gt;console.log(`made directories, starting with ${made}`)) 2.判断wwwroot目录下有几个为目录12345678910111213141516171819202122// 判断wwwroot文件夹下所有的文件，若是文件夹，则存到一个数组中const fs = require('fs');let dirArr = [];let path = './wwwroot';fs.readdir(path,(err,data)=&gt;{ if(err){ console.log(err); return; } (function getDir(i){ if(i == data.length){ console.log(dirArr); return; } fs.stat(path+'/'+data[i],(error,state)=&gt;{ if(state.isDirectory()){ dirArr.push(data[i]); } getDir(++i); }) })(0)})","link":"/NodeJs/5.fs%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"package.json文件的说明","text":"1.文件结构 name：文件名 version：版本号 description：描述 2.关于第三方模块版本的说明 “^2.3.0”：代表更新时，第一位版本号不变，后面两位更新到最新版本 “~2.3.0”：代表更新时，前两位版本号不变，最后一位更新到最新版本 “*2.3.0”：代表更新时，全部更新到最新版本 “2.3.0”：代表更新时，全部不更新，指定该版本号进行安装 【注】使用npm命令进行模块安装时，最后不加’-g’，则默认为本地安装","link":"/NodeJs/4.package.json%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"title":"commonJS","text":"一.自定义模块的两种暴露方式1.exports(1)自定义一个方法，然后通过exports暴露12345function formateApi(api){ return &quot;http://127.0.0.1:8080/&quot;+api;}exports.formateApi = formateApi; 123//在另一个js文件中引入该模块即可const tools = require('./module/tools');tools.formateApi(); (2)直接通过exports暴露函数1234567exports.get = function(){ console.log(&quot;get&quot;);}exports.post = function(){ console.log(&quot;post&quot;);} 123456//使用const request = require('./module/request');request.get();request.post(); 2.module.exportsmodule.exports适合暴露封装好的对象 123456789let obj = { get: function(){ console.log(&quot;get&quot;); }, post: function(){ console.log(&quot;post&quot;); }}module.exports = obj; 123456//使用const request = require('./module/request');request.get();request.post(); 二.node_modules的使用 1.如果不指定相对路径，Node.js会默认引入node_modules中指定文件夹下文件名为index.js的文件 12345// NodeJs会默认引入node_modules文件夹中index.js模块const axios = require('axios');axios.post();axios.get(); 2.如果node_modules中指定的文件夹中的文件名不是index.js，则要在该文件夹中生成一个package.json文件后才能正常引入 123// 如果db文件夹中的js文件不是index.js，则会报错，解决方法是在该文件夹下生成一个package.json(npm init -y)的配置文件const db = require('db');db.add(); 【注】一般第三方模块都是放在node_modules文件夹中的","link":"/NodeJs/3.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"url模块","text":"url模块的使用nodejs中的url模块是用来解析url地址的，可以获取对应的查询字符串 1234567891011121314const url = require('url');let api = &quot;https://www.baidu.com?username='张三'&amp;password='123456'&quot;;/* 1.url.parse()中传入对应的url地址; 2.第二个参数传入true后会将查询字符串转为js对象; 3.query就是对应的查询字符串对象*/let getValue = url.parse(api,true).query;let {username,password} = getValue;console.log(username+&quot;,&quot;+password); url模块的使用例子 1234567891011121314151617181920212223const http = require('http');const url = require('url');http.createServer((request,response)=&gt;{ // 响应头 response.writeHead(200, {'Content-Type': 'text/html; charset=&quot;utf-8&quot;'}); // 防止页面乱码 response.write('&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;'); // 判断url是否为正常的url if(request.url != &quot;/favicon.ico&quot;){ let {username,pwd} = url.parse(request.url,true).query; // console.log(request.url); console.log(`姓名:${username},密码:${pwd}`); } response.write(&quot;你好 Node.js&quot;); // 结束响应 response.end();}).listen(8080); //端口console.log(&quot;http://127.0.0.1:8080&quot;);","link":"/NodeJs/2.url%E6%A8%A1%E5%9D%97/"},{"title":"Corepack","text":"1.CorepackCorepack是Nodejs在16.9.0中加入的实验性阶段工具，用于协助管理你本机package manager的版本 简单来说，Corepack 会成为 Node.js 官方的内置 CLI，用来管理『包管理工具（npm、yarn、pnpm、cnpm）』，用户无需手动安装，即『包管理器的管理器』 2.体验 升级你的Nodejs版本到16.9.0。如果使用nvm管理node版本，则需要先升级nvm版本1.1.8以上才行 在你项目的package.json文件中添加packageManager属性 1234{ &quot;name&quot;: &quot;test&quot;, &quot;packageManager&quot;: &quot;pnpm@6.26.0&quot;,} 运行corepack enable命令即可激活 1234567# 激活$ corepack enable# 使用$ pnpm i# 用非声明的包管理器，则会报错$ yarnUsage Error: This project is configured to use pnpm","link":"/NodeJs/14.Corepack/"},{"title":"封装一个类似express的路由，静态web服务","text":"1.route模块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const url = require('url');const path = require('path');const fs = require('fs');// 扩展reslet changeRes = (res)=&gt;{ res.send = (data)=&gt;{ res.writeHead(200,{'Content-Type':'text/html;charset=&quot;utf-8&quot;'}); res.end(data); }}// 根据后缀名获取文件类型let getMime = (extName) =&gt; { let data = fs.readFileSync('./data/mime.json'); let mimeObj = JSON.parse(data.toString()); return mimeObj[extName];}//静态web服务方法let static = (req, res, staticPath) =&gt; { /* / /favicon.ico */ //获取url中的路径(pathname) let pathname = url.parse(req.url).pathname; // 获取路径中的后缀名 let extName = path.extname(pathname); // pathname = pathname == '/' ? '/index.html' : pathname; // 获得正确的路径 try { // 读取对应文件夹下的文件并传给浏览器 let data = fs.readFileSync('./' + staticPath + pathname); if (data) { // 获取对应后缀名的响应头 let mimeName = getMime(extName); res.writeHead(200, {'Content-Type':''+mimeName+';charset=utf-8'}); res.end(data); } } catch (error) { }}let server = ()=&gt;{ // 全局对象G let G = { _get: {}, _post: {}, staticPath: 'static' }; let app = (req,res)=&gt;{ // 扩展res changeRes(res); // 配置静态web服务 static(req,res,G.staticPath); let pahtname = url.parse(req.url).pathname; //获得请求方式 let method = req.method.toLowerCase(); if(G['_'+method][pahtname]){ if(method == &quot;get&quot;){ G['_'+method][pahtname](req,res); //执行方法 }else{ let postData = ''; req.on('data',(chunk)=&gt;{ postData += chunk; }) req.on('end',()=&gt;{ req.body = postData; G['_'+method][pahtname](req,res); //执行方法 }) } }else{ res.writeHead(404,{'Content-Type':'text/html;charset=&quot;utf-8&quot;'}); res.end(&quot;页面不存在&quot;); } } // get方法 app.get = function(str,cb){ // 注册方法 G._get[str] = cb; } // post方法 app.post = function(str,cb){ // 注册方法 G._post[str] = cb; } // 配置静态web服务目录 app.static = function(staticPath){ G.staticPath = staticPath; } return app;}module.exports = server(); 2.server模块1234567891011121314151617181920212223242526272829const http = require('http');const app = require('./module/route');const ejs = require('ejs');http.createServer(app).listen(3000);console.log(&quot;http://127.0.0.1:3000&quot;);// 配置静态web目录app.static('static');// 配置路由app.get('/',(req,res)=&gt;{ res.send(&quot;首页&quot;);})app.get('/login',(req,res)=&gt;{ ejs.renderFile('./view/login.ejs',{},(err,data)=&gt;{ res.send(data); })})app.post('/doLogin',(req,res)=&gt;{ console.log(req.body); res.send(req.body);})app.get('/news',(req,res)=&gt;{ res.send(&quot;新闻页面&quot;);}) 3.ejs页面123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/commit.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;登录页面&lt;/h2&gt; &lt;form action=&quot;/doLogin&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;uername&quot; value=&quot;admin&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;123456&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.目录结构","link":"/NodeJs/13.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCexpress%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%8C%E9%9D%99%E6%80%81web%E6%9C%8D%E5%8A%A1/"},{"title":"封装一个类似express的路由","text":"1.实现步骤1.定义一个app方法 123let app = (req,res)=&gt;{} 2.定义一个app的私有方法app.get() 1234//str:传入的路径，cb:即callback，回调函数app.get = (str,cb)=&gt;{} 3.注册方法 12345678910111213141516//1.定义一个G空对象let G = {};//2.在app.get()方法中注册app.get = (str,cb)=&gt;{ G[str] = cb;}//3.调用该方法let app = (req,res)=&gt;{ if(G['/login']){ G['/login'](req,res); }}//4.执行方法app.get('/login',(req,res)=&gt;{ console.log(&quot;执行登录&quot;);}) 4.封装成通用方法，并暴露该方法 1234567891011121314151617181920const url = require('url');let G = {};let app = function(req,res){ let pahtname = url.parse(req.url).pathname; if(G[pahtname]){ G[pahtname](req,res); }else{ res.writeHead(404,{'Content-Type':'text/html;charset=&quot;utf-8&quot;'}); res.end(&quot;页面不存在&quot;); }}app.get = function(str,cb){ // 注册方法 G[str] = cb;}//暴露module.exports = app; 5.使用http模块实现调用路由 12345678910111213141516171819const http = require('http');const app = require('./module/route');http.createServer(app).listen(3000);console.log(&quot;http://127.0.0.1:3000&quot;);// 配置路由app.get('/',(req,res)=&gt;{ res.writeHead(200,{'Content-Type':'text/html;charset=&quot;utf-8&quot;'}); res.end(&quot;首页&quot;);})app.get('/login',(req,res)=&gt;{ res.writeHead(200,{'Content-Type':'text/html;charset=&quot;utf-8&quot;'}); res.end(&quot;登录页&quot;);})app.get('/news',(req,res)=&gt;{ res.writeHead(200,{'Content-Type':'text/html;charset=&quot;utf-8&quot;'}); res.end(&quot;新闻页面&quot;);}) 2.加入POST路由，并通过req.body获取数据，并封装一个res.send方法1.封装一个res.send()方法12345678function changeRes(res){ res.send = (data)=&gt;{ res.writeHead(200,{'Content-Type':'text/html;charset=&quot;utf-8&quot;'}); res.end(data); }}//在app中调用该方法changeRes(res); 2.改造server方法，封装一个post方法123456789101112131415161718192021222324252627282930313233343536373839404142434445let server = ()=&gt;{ let G = {}; G._get = {}; G._post = {}; let app = function(req,res){ // 扩展res changeRes(res); let pahtname = url.parse(req.url).pathname; //获得请求类型 let method = req.method.toLowerCase(); if(G['_'+method][pahtname]){ if(method == &quot;get&quot;){ //get执行如下方法 G['_'+method][pahtname](req,res); //执行方法 }else{ //post执行如下方法 let postData = ''; req.on('data',(chunk)=&gt;{ postData += chunk; }) req.on('end',()=&gt;{ //将获得的post数据放入req.body中 req.body = postData; G['_'+method][pahtname](req,res); //执行方法 }) } }else{ res.writeHead(404,{'Content-Type':'text/html;charset=&quot;utf-8&quot;'}); res.end(&quot;页面不存在&quot;); } } // get方法 app.get = function(str,cb){ // 注册方法 G._get[str] = cb; } app.post = function(str,cb){ // 注册方法 G._post[str] = cb; } return app;} 3.调用方法123456789101112131415161718192021222324const http = require('http');const app = require('./module/route');const ejs = require('ejs');http.createServer(app).listen(3000);console.log(&quot;http://127.0.0.1:3000&quot;);/*配置路由*/app.get('/',(req,res)=&gt;{ res.send(&quot;首页&quot;);})app.get('/login',(req,res)=&gt;{ ejs.renderFile('./view/login.ejs',{},(err,data)=&gt;{ res.send(data); })})app.post('/doLogin',(req,res)=&gt;{ console.log(req.body); res.send(req.body);})app.get('/news',(req,res)=&gt;{ res.send(&quot;新闻页面&quot;);})","link":"/NodeJs/12.%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCexpress%E7%9A%84%E8%B7%AF%E7%94%B1/"},{"title":"封装路由","text":"1.路由的封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const fs = require('fs');const path = require('path');const url = require('url');const ejs = require('ejs');// 私有方法let getMime = (extName) =&gt; { let data = fs.readFileSync('./data/mime.json'); let mimeObj = JSON.parse(data.toString()); return mimeObj[extName];}// 封装路由let app = { static(req, res, staticPath) { //获取url中的路径(pathname) let pathname = url.parse(req.url).pathname; // 获取路径中的后缀名 let extName = path.extname(pathname); pathname = pathname == '/' ? '/index.html' : pathname; // 获得正确的路径 if (pathname != '/favicon.ico') { try { // 读取对应文件夹下的文件并传给浏览器 let data = fs.readFileSync('./' + staticPath + pathname); if (data) { // 获取对应后缀名的响应头 let mimeName = getMime(extName); res.writeHead(200, { 'Content-Type': '' + mimeName + ';charset=utf-8' }); res.end(data); } } catch (error) { } } }, login(req,res){ res.end(&quot;login&quot;); }, news(req,res){ res.end(&quot;news&quot;); }, form(req,res){ ejs.renderFile('./views/form.ejs',{},(err,data)=&gt;{ res.writeHead(200,{'Content-Type':'text/html,charset=&quot;utf-8&quot;'}); res.end(data); }) }, doLogin(req,res){ let postData = ''; req.on('data',(chunk)=&gt;{ postData += chunk; }) req.on('end',()=&gt;{ console.log(postData); res.end(postData); }) }, error(req,res){ res.end(&quot;error&quot;); }}module.exports = app; 2.使用123456789101112131415161718192021const http = require('http');const routes = require('./module/routes');const url = require('url');http.createServer((req,res)=&gt;{ // 创建静态web服务 routes.static(req,res,'state'); // 获取请求类型 // console.log(req.method); // 路由 let pathname = url.parse(req.url).pathname.replace(&quot;/&quot;,&quot;&quot;); try { routes[pathname](req,res); } catch (error) { routes['error'](req,res); }}).listen(8080);console.log(&quot;http://127.0.0.1:8080&quot;);","link":"/NodeJs/11.%E5%B0%81%E8%A3%85%E8%B7%AF%E7%94%B1/"},{"title":"EJS","text":"1.下载ejs12//本地安装ejscnpm i ejs --save 2.引入ejs，并创建ejs页面1const ejs = require('ejs'); 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;这是一个登录页面&lt;/h2&gt; &lt;h3&gt;&lt;%=msg%&gt;&lt;/h3&gt; &lt;ul&gt; &lt;%for(let i = 0; i &lt; list.length; i++){%&gt; &lt;li&gt;&lt;%=list[i].msg%&gt;&lt;/li&gt; &lt;%}%&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 3.模拟将数据库中的数据传回ejs页面并进行渲染12345678910111213141516171819//将数据传去ejs页面if(pathname == '/login'){ let msg = &quot;数据库中获取的数据&quot;; let list = [ {msg:&quot;新闻111&quot;}, {msg:&quot;新闻222&quot;}, {msg:&quot;新闻333&quot;}, {msg:&quot;新闻444&quot;}, {msg:&quot;新闻555&quot;} ]; //ejs渲染页面 ejs.renderFile('./views/login.ejs',{msg:msg,list:list},(err,data)=&gt;{ res.writeHead(200,{'Content-Type':'text/html;charset=utf-8'}); res.end(data); })} 1234567//ejs上渲染&lt;h3&gt;&lt;%=msg%&gt;&lt;/h3&gt;&lt;ul&gt; &lt;%for(let i = 0; i &lt; list.length; i++){%&gt; &lt;li&gt;&lt;%=list[i].msg%&gt;&lt;/li&gt; &lt;%}%&gt;&lt;/ul&gt; 2.get和post1.获取get传值get传值是拼接在url后面的查询字符串，可以直接通过url模块提供的parse解析获取 123456else if(pathname == '/news'){ // 获取get传值 let {page,title} = url.parse(req.url,true).query; console.log(page+&quot;,&quot;+title); res.end(page+&quot;,&quot;+title);} 2.获取post传值1.新建一个form页面，里面有简单的form表单 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/doLogin&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot; autofocus=&quot;off&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.在路由中配置访问form页面的路由 123456else if(pathname == '/form'){ // 获取post传值 ejs.renderFile('./views/form.ejs',{},(err,data)=&gt;{ res.end(data); })} 3.post请求提交到的路由地址为’/doLogin’，在这里面解析post请求 1234567891011else if(pathname == '/doLogin'){ // 获取POST传值 let postData = ''; req.on('data',(chunk)=&gt;{ postData += chunk; }) req.on('end',()=&gt;{ console.log(postData); res.end(postData); })} 【注】一般加载页面用的都是get请求，post请求大多数在提交数据时使用 可以通过req.method查看 12// 获取请求类型console.log(req.method);","link":"/NodeJs/10.EJS,Get,Post/"},{"title":"http模块","text":"Node.js自动的http模块的使用123456789101112131415161718192021// 引入http模块const http = require('http');/* request 获取url传过来的信息 response 给浏览器响应信息 */http.createServer(function (request, response) { console.log(request.url); // 设置响应头 response.writeHead(200, {'Content-Type': 'text/html;charset=&quot;utf-8&quot;'}); // 防止页面乱码 response.write(&quot;&lt;head&gt;&lt;meta charset='UTF-8'&gt;&lt;/head&gt;&quot;); response.write(&quot;你好 Node&quot;); // 结束响应 response.end();}).listen(8080); //端口console.log('Server running at http://127.0.0.1:8080/');","link":"/NodeJs/1.http%E6%A8%A1%E5%9D%97/"},{"title":"打包样式资源","text":"1.打包样式资源 常用的样式资源有 css less (sa|sc)ss，这些分别需要引入不同的loader 固定依赖： style-loader css-loader前者将打包好的资源引入到根文件的&lt;head&gt;&lt;/head&gt;标签内，后者将css样式文件编译成commjs可识别的字符串 引入less： less less-loader 引入(sa|sc)ss：sass sass-loader 1234567891011121314151617181920212223242526272829303132const { resolve } = require('path');module.exports = { ... // loader配置 module: { rules: [ { // 匹配哪些文件 test: /\\.css$/, // 使用哪些loader 执行顺序是数组降序(从下往上) use: [ // 创建style标签，将js中的样式资源插入到资源中进行，并将标签添加到页面head标签中 'style-loader', // 将 css文件变成commonjs模块加载到js中，里面的内容是字符串 'css-loader' ] }, /** 支持引入less 需要 less和less-loader依赖 */ { test: /\\.less$/, use: ['style-loader','css-loader','less-loader'] }, /** 支持引入(sa|sc)ss 需要sass和sass-loader依赖 */ { test: /\\.(sa|sc)ss$/, use: ['style-loader','css-loader','sass-loader'] } ] }, ...} 2.支持css module写法 只需在对应的css-loader中加入modules配置即可 12345678910111213141516171819202122232425262728293031const { resolve } = require('path');module.exports = { ... // loader配置 module: { rules: [ ... /** 支持引入(sa|sc)ss 需要sass和sass-loader依赖 */ { test: /\\.(sa|sc)ss$/, use: [ 'style-loader', { loader: 'css-loader', options: { importLoaders: true, // 支持 css module写法 modules: { localIdentName: '[local]__[name]-[hash:base64:4]' } } }, 'sass-loader' ] } ... ] }, ...}","link":"/webpack/3.%E6%89%93%E5%8C%85%E6%A0%B7%E5%BC%8F%E8%B5%84%E6%BA%90/"},{"title":"打包图片资源","text":"1.打包图片资源 webpack打包图片资源需要下载两个loader: url-loader file-loader url-loader 依赖于file-loader，在配置时只需要引入一个loader即可 1234567891011121314151617181920212223const dirs = require('./dirs');module.exports = { module: { rules: [ /** 处理图片资源，需要 url-loader file-loader */ { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [ { loader: 'url-loader', options: { limit: 5 * 1000, include: dirs.src, // 打包后的图片路径以及命名 name: 'images/[path][name].[ext]' } } ] } ] }}","link":"/webpack/5.%E6%89%93%E5%8C%85%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/"},{"title":"devServer","text":"1.devServer基本配置 开发环境下自动编译，自动打开浏览器 123456789101112131415{ module.exports = { // 开发服务器， 在开发过程中热加载项目 devServer: { // 构建后的项目运行的目录 contentBase: path.resolve(dirs.build), // 启动gzip压缩 compress: true, // 端口号 port: 8100, // 自动打开浏览器 open: false, } }}","link":"/webpack/6.devServer/"},{"title":"打包HTML资源","text":"1.打包html文件 下载plugin: html-webpack-plugin 使用 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { plugins: [ new HtmlWebpackPlugin({ // 复制指定的html文件，并自动引入打包后的所有资源 template: path.resolve(__dirname, '../src/index.html') }), ]}","link":"/webpack/4.%E6%89%93%E5%8C%85html%E8%B5%84%E6%BA%90/"},{"title":"Webpack简介","text":"1.简介 Webpack是一种前端资源构建工具，一个静态模块打包器(module bundler) 在Webpack看来，前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理 它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle) 2.原理当前端需要引入模块(js文件，样式资源，图片，字体等其他资源)时，webpack会将这些资源交给构建工具去处理，构建工具会从webpack指定的入口文件作为起点开始打包，会将每一个模块记录好，形成依赖关系结构图，然后根据依赖关系图的先后顺序将这些模块引入，形成一个chunk代码块，最后将这个代码块中的模块(ts,less,scss…)进行编译打包，形成浏览器所能识别的文件，最后将处理好的资源进行输出，输出的文件称为bundle 3.五个核心概念 Entry 入口(Entry)指示，Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图 Output 输出(Output)指示Webpack打包后的资源bundles输出到哪里去，以及如何命名 Loader(loader放在module模块的rules数组中) Loader让Webpack能够去处理那些非JavaScript文件(Webpack自身只能理解JavaScript) Plugins 插件(Plugins)可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。 Mode 打包的模式(development production)","link":"/webpack/1.webpack%E7%AE%80%E4%BB%8B/"},{"title":"Webpack初始化","text":"1.初始化webpack12$ yarn init -y$ yarn webpack webpack-cli webpack-dev-server -D package.json 1234&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack server --config ./scripts/webpack.config.js --mode=development&quot;, // 开发时的启动服务命令 &quot;build&quot;: &quot;webpack --config ./scripts/webpack.config.js --mode=production&quot; // 编译命令}, webpack.config.js**(注意webpack配置文件的路径，需要和package.json中启动命令的路径对应)** 123456789101112131415161718// /script/webpack.config.jsconst path = require('path');module.exports = { // 入口 entry: path.resolve(__dirname, '../src/index.js'), // 出口 output: { filename: 'index.js', path: path.resolve(__dirname, '../dist'), }, // loader module: [], // plugins plugins: [],} 2.配置目录文件 在scripts文件夹中新建dirs.js，此文件中专门用于存储各种需要用到的路径 123456789101112131415161718192021const path = require('path');const root = path.resolve(__dirname, '../../');const dirs = { // 根目录 root, // 源码目录 src: path.resolve(root, './src'), // 输出目录 dist: path.resolve(root, './dist'), // 第三方库 lib: path.resolve(root, './lib'), // 构建脚本目录 build: path.resolve(root, './webpack'), // modules modules: path.resolve(root, './node_modules'), // package package: path.resolve(root, './package.json')};module.exports = dirs;","link":"/webpack/2.%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"JavaScript类机制","text":"1.ES5 继承ES5中没有类的概念，通常通过声明一个构造函数来模拟类 1234567891011121314151617181920function Person(name) { this.name = name; this.sayName1 = function () { console.log(this.name + '在工作'); }}// 原型链上的方法和属性会被多个实例共享，构造函数中的则不会Person.prototype.sayName2 = function () { console.log(this.name + '在学习');}// 静态方法Person.sayName3 = () =&gt; { console.log(this.name + '在运动')}var person = new Person('Tom');person.sayName1(); // Tom在工作person.sayName2(); // Tom在学习 原型方法和实例方法的区别： 写在原型中的方法可以被所有的实例共享， 实例化的时候不会在实例内存中再复制一份，占有的内存消耗少。 js中每个函数都有一个prototype属性，这个属性指向一个对象（所有属性的集合：默认constructor属性，值指向这个函数本身。） 每个原型对象都属于对象，所以它也有自己的原型，而它自己的原型对象又有自己的原型，所以就形成了原型链。 一个对象的隐式原型指向构造这个对象的构造函数的显式原型，所以这个对象可以访问构造函数的属性和方法。（new一个实例） js的继承也就是通过原型链来实现的，当访问一个对象的属性，如果这个对象本身不存在，则沿着__proto__依次往上查找，如果有则返回值，没有则一直到查到Object.prototype的__proto__的值为null. 继承ES5实现继承的方式有原型链继承，构造继承，实例继承，拷贝继承，组合继承，寄生组合继承这六种 原型链继承 优点 实例是子类的实例，也是父类的实例 可以调用父类的实例属性和方法，也可以调用父类原型链上的属性和方法 缺点 子类无法在构造器中新增属性或者方法，必须要在new Person()之后 在子类实例化时，无法向父类传参 父类原型对象的所有属性被所有实例共享 1234567// 原型链继承function Cat() { }Cat.prototype = new Person('Pt'); // 只能在这里向父类传参，或者下面代码那样var cat = new Cat();cat.sayName1(); 构造继承 优点 解决了原型链继承中，子类实例共享父类引用属性的问题 在创建子类实例时，可以向父类传参 缺点 实例并不是父类的实例，只是子类的实例 只能继承父类构造函数中的属性和方法，不能继承父类原型链中的属性和方法 无法实现函数的复用，每个子类都有父类实例函数的副本，影响性能 1234567function Cat(name) { Person.call(this, name);}var cat = new Cat('Tom');cat.sayName1(); 实例继承 缺点 无法实现多继承 子类实例化出来的对象是父类类型，不是子类类型 123456789// 实例继承function Cat(name) { var instance = new Person(name); return instance;}var cat = new Cat('Tom');cat.sayName1() 组合继承 优点 弥补了构造继承的缺陷，可以继承实例的属性/方法，也可以继承原型上的属性/方法 既是子类的实例，也是父类的实例 可以向父类传参 函数可以复用 缺点 调用了两次父类的构造函数，生成了两份实例 1234567891011121314151617function Cat(name, age) { Person.call(this, name); this.age = age;}Cat.prototype = new Person();var cat = new Cat('Tom', 18);console.log(cat.name);cat.sayName1();cat.sayName2();console.log(cat.age); 寄生组合继承1234567891011function Cat(name) { Person.call(this, name);}var Temp = Object.create(Person.prototype); // 创建对象，创建父类原型的一个副本Temp.constructor = Cat; // 增强对象，弥补因重写原型而失去的默认的constructor 属性Cat.prototype = Temp; // 指定对象，将新创建的对象赋值给子类的原型var cat = new Cat('Tom');cat.sayName1() 2.new的时候都做了什么？ 创建一个新对象 把这个新对象的__proto__属性指向你要new 的那个对象的prototype 让构造函数里面的this指向新的对象，然后执行构造函数 返回这个新对象 123456function _new(constructor, ...args) { const obj = Object.create(constructor.prototype); const result = constructor.call(obj, ...args); return result instanceof Object ? result : obj;} 3.ES6 ClassES6提供了更接近传统的写法，基本上可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到 12345678910class Person { constructor(name) { this.name = name; } sayName() { console.log(this.name + '在学习') }}const p = new Person('jiacheng') 构造函数上的prototype属性，在ES6类上面继续存在，事实上，类的所有方法都是定义在类的prototype属性上面的 1234567891011121314151617181920class Point { constructor() { // ... } toString() { // ... } toValue() { // ... }}// 等同于Point.prototype = { constructor() {}, toString() {}, toValue() {},}; 因此，在类的实例上面调用方法，其实就是调用原型上的方法 12345class B{}const b = new B();b.constructor === B.prototype.constructor // true 所以，使用Object.assin()方法可以很方便地一次向类添加多个方法 12345678910class Point { constructor(){ // ... }}Object.assign(Point.prototype, { toString(){}, toValue(){}}); prototype对象的constructor属性，直接指向类本身，这与ES5的行为是一致的 1Point.prototype.constructor === Point // true 另外，类内部所有定义的方法，都是不可枚举的 1234567891011121314class Point { constructor(x, y) { // ... } toString() { // ... }}Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [&quot;constructor&quot;,&quot;toString&quot;] constructorconstructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法，一个类即使没有显示定义constructor，也会被默认添加一个空的constructor 123456class Person{}// 相当于class Person { constructor(){}} constructor默认返回实例对象，完全可以指定返回另一个对象 1234567class Person { constructor() { return Object.create(null) }}new Person instanceof Person // false 类必须使用new调用，否则会直接报错 12345class Person {}Person()// TypeError: Class constructor Foo cannot be invoked without 'new' 类的实例直接通过new命令生成一个类的实例，与ES5不同的是，直接调用类会报错 123456789class Point { // ...}// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上） 12345678910111213141516171819202122//定义类class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; }}var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 类的所有实例共享一个原型对象 12345var p1 = new Point(2,3);var p2 = new Point(3,2);//truep1.__proto__ === p2.__proto__ 这也意味着，可以通过实例的__proto__属性为“类”添加方法。 __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () { return 'Oops' };p1.printName() // &quot;Oops&quot;p2.printName() // &quot;Oops&quot;var p3 = new Point(4,2);p3.printName() // &quot;Oops&quot; 上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 getter和setter与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass { constructor() { // ... } get prop() { return 'getter'; } set prop(value) { console.log('setter: '+value); }}let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 存值函数和取值函数是设置在属性的 Descriptor 对象上的。 1234567891011121314151617181920class CustomHTMLElement { constructor(element) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; }}var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, &quot;html&quot;);&quot;get&quot; in descriptor // true&quot;set&quot; in descriptor // true 注意点 严格模式 类和模块的内部，默认就是严格模式，不需要使用’use strict’指定运行模式 不存在提升 类不存在变量提升 Generator方法 如果某个方法前加上*，就表示该方法是一个Generator函数 12345678910111213141516class Foo { constructor(...args) { this.args = args; } * [Symbol.iterator]() { for (let arg of this.args) { yield arg; } }}for (let x of new Foo('hello', 'world')) { console.log(x);}// hello// world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。 this的指向 类方法内部如果含有this，它默认指向类的实例，但该方法无法单独使用 12345678910111213class Logger { printName(name = 'there') { this.print(`Hello ${name}`); } print(text) { console.log(text); }}const logger = new Logger();const { printName } = logger;printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，因为printName方法中的this，默认指向Logger类的实例，但如果将这个方法单独提取出来使用，this会指向该方法运行时所在的环境，而由于class内部是严格模式，所以这时候this直接指向undefined，导致报错 解决方法： 在构造方法中绑定this，这样就不会找不到print方法了。 12345678910111213class Logger { constructor() { this.printName = this.printName.bind(this); } printName(name = 'there') { this.print(`Hello ${name}`); } print(text) { console.log(text); }} 使用箭头函数 箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象 123456789101112131415class Person { printName = () =&gt; { this.print() } print() { console.log('111'); }}var p = new Person();var { printName } = p;printName() 静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承，如果在一个方法前面加上static关键字，就表示该方法不会被实例继承，而是通过类来调用，这被称为静态方法 1234567891011class Foo { static classMethod() { return 'hello'; }}Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 如果静态方法中包含this关键字，这个this指向的是类，而不是实例 12345678910111213class Foo { static bar() { this.baz(); } static baz() { console.log('hello'); } baz() { console.log('world'); }}Foo.bar() // hello 父类的静态方法，可以被子类继承 静态方法也可以从super对象上调用 12345678910111213class Foo { static classMethod() { return 'hello'; }}class Bar extends Foo { static classMethod() { return super.classMethod() + ', too'; }}Bar.classMethod() // &quot;hello, too&quot; 静态属性静态属性是指class本身的属性，而不是定义在实例对象上的属性 123456789101112class Foo {}Foo.prop = 1;// 或者class Foo{ static name = 'jiacheng'}Foo.name; // jiacheng 4.继承class通过extends关键字来实现继承 123class Person{}class ColorPoint extends Person {} super super关键字表示父类的构造函数，用来新建父类的this对象 子类必须在constructor中调用super方法，否则会报错 12345678910class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString() }} 5.和ES5继承的区别 ES5里的构造函数是一个普通函数，可以使用new调用，也可以直接调用，且存在变量提升。ES6的class必须使用new操作符调用，且不存在变量提升 ES5子类的原型是指向Function.prototype，而ES6子类的原型是指向父类的 ES5的原型方法和静态方法是可枚举的，而class的默认不可枚举，但可以使用Object.getOwnPropertyNames方法获取 ES5的继承，实质是先创造一个子类实例对象的this，然后再执行父类构造函数给它添加实例方法和属性(不执行也无所谓)；ES6的继承机制则相反，先将父类的属性和方法，加到一个空对象上，然后再将该对象作为子类的实例，即”继承在前，实例在后”","link":"/JavaScript/6.%E7%B1%BB/"},{"title":"let和const关键字","text":"1.letES6新增的声明变量关键字，所声明的变量，只在let命令所在的代码块内有效 块级作用域1234567{ let a = 10; var b = 10;}console.log(a);// ReferenceError: a is not defined.console.log(b);// 10 for循环计数器，就很合适使用let命令 123456789101112for (let i = 0; i &lt; 10; i++) { // ...}console.log(i);// ReferenceError: i is not defined// 如果使用var，最后会输出10for (var i = 0; i &lt; 10; i++) { // ...}console.log(i);// 10 不存在变量提升var关键字声明的变量，可以在声明之前使用，let关键字声明的变量，一定要在声明后使用，否则报错 12345console.log(foo); // undefinedvar foo = 2;console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let关键字声明的变量，它所声明的变量就被绑定在这个区域，不再受到外部的影响 123456var a = 10;{ console.log(a); // 报错ReferenceError let a;} 有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) { return [x, y];}bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) { return [x, y];}bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。不允许重复声明 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() { let a = 10; var a = 1;}// 报错function func() { let a = 10; let a = 1;} 因此，不能在函数内部重新声明参数。 1234567891011function func(arg) { let arg;}func() // 报错function func(arg) { { let arg; }}func() // 不报错 constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) { const MAX = 5;}MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) { console.log(MAX); // ReferenceError const MAX = 5;} 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; 本质const实际上是为了保证，变量指向的那个内存地址所保存的数据不能改动。对于基本数据类型来说，值就是保存在变量指向的那个内存地址中。但对于引用数据类型来说，变量指向的内存地址所保存的数据只是指针，const只能保证这个指针是固定的，至于它的数据结果是不是固定的就不可控制了。 如果真想要冻结对象，应该使用Object.freeze方法 12345const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;","link":"/JavaScript/7.let%E5%92%8Cconst/"},{"title":"解构赋值","text":"解构赋值ES6允许按照一定的模式，从数组和对象中提取值，并赋值给对应的对象，这被称为解构赋值 解构赋值本质上属于模式匹配，也就是说，只要等式两边的模式相同，左边的变量就会被赋予对应的值 如果解构不成功，变量的值就会被赋予undefined 解构赋值分为数组形式的解构赋值和对象形式的解构赋值，两者实现的原理不同 1.数组形式的解构赋值数组形式的解构赋值本质上是调用可迭代数据结构原型链上的iterator接口，遍历出对应的数据并进行赋值 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // &quot;a&quot;y // undefinedz // [] 如果右边不是数组(或者严格来说，不是可遍历的结构)，那么将会报错 对于Set结构，也可以使用数组进行解构赋值 1let [x,y,z] = new Set([1,2,3]) 事实上，只要某种数据结构具有Iterator接口，都可以采用数组的形式解构赋值 1234567891011function* fibs() { let a = 0; let b = 1; while (true) { yield a; [a, b] = [b, a + b]; }}let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 默认值 解构赋值允许指定默认值 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意：ES6内部默认使用严格相等运算符判断一个位置是否有值，所以，只有当要解构的数组成员默认等于undefined时，默认值才会生效 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null]x // null 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() { console.log('aaa');}let [x = f()] = [1]; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 字符串的解构赋值字符串也可以解构赋值。这是因为字符串的包装类也是一个带有iterator的可迭代对象 123456const [a, b, c, d, e] = 'hello';a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 函数参数的解构赋值函数参数也可以使用解构赋值 12345function add([x, y]){ return x + y;}add([1, 2]); // 3 2.对象的解构赋值对象的解构赋值和数组有所不同，数组的解构赋值变量名是按照数组的元素顺序一一赋值的，而对象解构赋值内部的运行机制其实就是直接查找同名的属性进行赋值，只要属性名正确，就能取到值，否则为undefined 123456let { bar, foo } = { foo: 'aaa', bar: 'bbb' };foo // &quot;aaa&quot;bar // &quot;bbb&quot;let { baz } = { foo: 'aaa', bar: 'bbb' };baz // undefined 对象的解构赋值极大地方便了我们将现有对象的某个方法，单独取出来使用，并且支持重命名 1234567let { foo: baz } = { foo: 'aaa', bar: 'bbb' };baz // &quot;aaa&quot;let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello'l // 'world' 默认值 对象的解构赋值也可以指定默认值 123456789101112131415var {x = 3} = {};x // 3var {x, y = 5} = {x: 1};x // 1y // 5var {x: y = 3} = {};y // 3var {x: y = 3} = {x: 5};y // 5var { message: msg = 'Something went wrong' } = {};msg // &quot;Something went wrong&quot; 默认值生成的条件与数组相同，对象的属性必须严格等于undefined 12345var {x = 3} = {x: undefined};x // 3var {x = 3} = {x: null};x // null 3.解构中的装箱一些基本数据类型也可以进行解构取值。准确地来说，是因为在解构中发生了装箱操作，可以取到其对应包装类型上的方法 例如： 取字符串所对应String类中的length12let { length } = 'hello';length // 5 数值和布尔值的解构赋值同样可以取到对应包装类型上的方法 12345let {toString: s} = 123;s === Number.prototype.toString // truelet {toString: s} = true;s === Boolean.prototype.toString // true null和undefined没有对应的包装类型，无法转为对象，因此解构会直接报错 12let { prop: x } = undefined; // TypeErrorlet { prop: y } = null; // TypeError 4.用途变量的解构赋值用途很多。 （1）交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() { return [1, 2, 3];}let [a, b, c] = example();// 返回一个对象function example() { return { foo: 1, bar: 2 };}let { foo, bar } = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1}); （4）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = { id: 42, status: &quot;OK&quot;, data: [867, 5309]};let { id, status, data: number } = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取 JSON 数据的值。 （5）函数参数的默认值 1234567891011jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config} = {}) { // ... do stuff}; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。 （6）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) { console.log(key + &quot; is &quot; + value);}// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) { // ...}// 获取键值for (let [,value] of map) { // ...} （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);","link":"/JavaScript/8.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"迭代器","text":"1.Iterator(遍历器)的概念JavaScript原有的表示集合的数据，主要是数组和对象，ES6又添加了Map和Set结构，这样就有了四种数据集合 这样就需要一种统一的接口机制，来处理所有不同的数据结构 遍历器(Iterator)就是这样的一种机制，它是一个接口，为不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作(即依次处理该数据结构的所有成员) Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。 遍历过程 创建一个指针对象，指向当前数据结构的起始位置，也就是说，遍历器的本质是一个指针对象 不断调用这个指针对象的next方法，返回数据结构的当前成员信息，具体来说，就是返回一个包含value和done两个属性的对象，其中，value就是当前成员的值，done属性是一个布尔值，表示遍历是否结束 12345678910111213141516var it = makeIterator(['a', 'b']);it.next() // { value: &quot;a&quot;, done: false }it.next() // { value: &quot;b&quot;, done: false }it.next() // { value: undefined, done: true }function makeIterator(array) { var nextIndex = 0; return { next: function() { return nextIndex &lt; array.length ? {value: array[nextIndex++], done: false} : {value: undefined, done: true}; } };} 2.默认Iterator接口Iterator接口的目的，就是为所有的数据结构，提供一种统一的访问机制，即for...of循环 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable） ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。 ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 1234567let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // { value: 'a', done: false }iter.next() // { value: 'b', done: false }iter.next() // { value: 'c', done: false }iter.next() // { value: undefined, done: true } 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了 3.调用 Iterator 接口的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。 （1）解构赋值 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add('a').add('b').add('c');let [x,y] = set;// x='a'; y='b'let [first, ...rest] = set;// first='a'; rest=['b','c']; （2）扩展运算符 扩展运算符（…）也会调用默认的 Iterator 接口。 12345678// 例一var str = 'hello';[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] 上面代码的扩展运算符内部就调用 Iterator 接口。 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 1let arr = [...iterable]; （3）yield* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function* () { yield 1; yield* [2,3,4]; yield 5;};var iterator = generator();iterator.next() // { value: 1, done: false }iterator.next() // { value: 2, done: false }iterator.next() // { value: 3, done: false }iterator.next() // { value: 4, done: false }iterator.next() // { value: 5, done: false }iterator.next() // { value: undefined, done: true } （4）其他场合 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])） Promise.all() Promise.race()","link":"/JavaScript/9.Iterator%E5%92%8Cfor...of%E5%BE%AA%E7%8E%AF/"},{"title":"事件循环机制","text":"1.JavaScript执行机制 同步：在执行到同步代码时，会按照顺序执行直接输出 异步：在执行到异步代码时，会将异步代码的回调函数存入事件队列中，等所有同步代码执行完成后再执行异步代码 1234567891011console.log(1) // 同步setTimeout(() =&gt; { console.log(2) // 异步}, 2000); // 注意延迟的时间console.log(3) // 同步setTimeout(() =&gt; { console.log(4) // 异步}, 0);console.log(5) // 同步// 输出 ： 1 3 5 4 2 2.宏任务&amp;&amp;微任务异步任务分为宏任务和微任务，微任务执行时机先于宏任务 宏任务 # 浏览器 Node I/O ✅ ✅ setTimeout ✅ ✅ setInterval ✅ ✅ setImmediate ❌ ✅ requestAnimationFrame ✅ ❌ 微任务 # 浏览器 Node Promise.prototype.then catch finally ✅ ✅ process.nextTick ❌ ✅ MutationObserver ✅ ❌ 执行流程 3.例子12345678910console.log(1) // 同步setTimeout(() =&gt; { console.log(2) // 异步：宏任务});console.log(3) // 同步Promise.resolve().then(()=&gt;{ // 异步：微任务 console.log(4)})console.log(5) // 同步// 1 3 5 4 2 例11234567891011121314151617181920console.log(1)setTimeout(() =&gt; { console.log(2) Promise.resolve().then(() =&gt; { console.log(3) })});console.log(4)new Promise((resolve,reject) =&gt; { console.log(5) resolve()}).then(() =&gt; { console.log(6) setTimeout(() =&gt; { console.log(7) })})console.log(8)// 1 4 5 8 6 2 3 7 例2123456789101112131415setTimeout(() =&gt; { console.log(1)}, 0)console.log(2)const p = new Promise((resolve) =&gt; { console.log(3) resolve()}).then(() =&gt; { console.log(4)}).then(() =&gt; { console.log(5)})console.log(6)// 2 3 6 4 5 1 遇到Promise.then.then这种时，如果有点懵逼的同学，可以转换一下 12345678910111213141516setTimeout(() =&gt; { // 异步：宏任务 setTimeout console.log(1)}, 0)console.log(2) // 同步const p = new Promise((resolve) =&gt; { // p 是 then1 执行返回的新 Promise console.log(3) // 同步 resolve()}).then(() =&gt; { // 异步：微任务 then1 console.log(4) // 拿着 p 重新 then p.then(() =&gt; { // 异步：微任务 then2 console.log(5) })})console.log(6) // 同步 6// 2 3 6 4 5 1 例312345678910111213141516171819202122232425262728293031323334353637new Promise((resolve,reject)=&gt;{ console.log(1) resolve()}).then(()=&gt;{ console.log(2) new Promise((resolve,reject)=&gt;{ console.log(3) resolve() }).then(()=&gt;{ console.log(4) }).then(()=&gt;{ console.log(5) })}).then(()=&gt;{ console.log(6)})// 转换后的代码const p1 = new Promise((resolve,reject)=&gt;{ console.log(1) resolve()}).then(()=&gt;{ console.log(2) const p2 = new Promise((resolve,reject)=&gt;{ console.log(3) resolve() }).then(()=&gt;{ console.log(4) p2.then(()=&gt;{ console.log(5) }) }) p1.then(()=&gt;{ console.log(6) })})// 1 2 3 4 6 5 例412345678910111213141516171819new Promise((resolve, reject) =&gt; { console.log(1) resolve()}).then(() =&gt; { console.log(2) // 多了个return return new Promise((resolve, reject) =&gt; { console.log(3) resolve() }).then(() =&gt; { console.log(4) }).then(() =&gt; { // 相当于return了这个then的执行返回Promise console.log(5) })}).then(() =&gt; { console.log(6)})// 1 2 3 4 5 6 例512345678910111213141516171819202122232425new Promise((resolve, reject) =&gt; { console.log(1) resolve()}).then(() =&gt; { console.log(2) new Promise((resolve, reject) =&gt; { console.log(3) resolve() }).then(() =&gt; { console.log(4) }).then(() =&gt; { console.log(5) })}).then(() =&gt; { console.log(6)})new Promise((resolve, reject) =&gt; { console.log(7) resolve()}).then(() =&gt; { console.log(8)})// 1 7 2 3 8 4 6 5 例61234567891011121314151617181920async function async1() { console.log(1); await async2(); console.log(2);}async function async2() { console.log(3);}console.log(4);setTimeout(function () { console.log(5);});async1()new Promise(function (resolve, reject) { console.log(6); resolve();}).then(function () { console.log(7);});console.log(8); 转换后的代码 12345678910111213141516171819202122console.log(4);setTimeout(function () { console.log(5);});console.log(1);new Promise((resolve, reject) =&gt; { console.log(3);}).then(() =&gt; { console.log(2);})new Promise(function (resolve, reject) { console.log(6); resolve();}).then(function () { console.log(7);});console.log(8);// 4 1 3 6 8 2 7 5 例7123456789101112131415161718192021222324252627282930313233343536373839async function async1() { console.log(1); await async2(); console.log(2);}async function async2() { console.log(3);}new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve() console.log(4) }, 1000);}).then(() =&gt; { console.log(5) new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { async1() resolve() console.log(6) }, 1000) }).then(() =&gt; { console.log(7) }).then(() =&gt; { console.log(8) })}).then(() =&gt; { console.log(9)})new Promise((resolve, reject) =&gt; { console.log(10) setTimeout(() =&gt; { resolve() console.log(11) }, 3000);}).then(() =&gt; { console.log(12)}) 转换后 123456789101112131415161718192021222324252627282930313233343536373839new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve() console.log(4) }, 1000);}).then(() =&gt; { console.log(5) new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(1); new Promise((resolve, reject) =&gt; { console.log(3); resolve(); }).then(() =&gt; { console.log(2); }) resolve() console.log(6) }, 1000) }).then(() =&gt; { console.log(7) }).then(() =&gt; { console.log(8) })}).then(() =&gt; { console.log(9)})new Promise((resolve, reject) =&gt; { console.log(10) setTimeout(() =&gt; { resolve() console.log(11) }, 3000);}).then(() =&gt; { console.log(12)})// 10 4 5 9 1 3 6 2 7 8 11 12 例8123456789101112131415161718192021222324252627282930async function async1() { console.log('async1 start') await async2() console.log('async1 end')}async function async2() { console.log('async start') return new Promise((resolve, reject) =&gt; { resolve() console.log('async2 promise') })}console.log('script start')setTimeout(() =&gt; { console.log('setTimeout')}, 0);async1()new Promise((resolve) =&gt; { console.log('promise1') resolve()}).then(() =&gt; { console.log('promise2')}).then(() =&gt; { console.log('promise3')})console.log('script end') 转换后 1234567891011121314151617181920212223242526272829303132333435363738console.log('script start')setTimeout(() =&gt; { console.log('setTimeout')}, 0);console.log('async1 start')new Promise((resolve,reject) =&gt; { console.log('async start') return new Promise((resolve, reject) =&gt; { resolve() console.log('async2 promise') })}).then(() =&gt; { console.log('async1 end')})new Promise((resolve) =&gt; { console.log('promise1') resolve()}).then(() =&gt; { console.log('promise2')}).then(() =&gt; { console.log('promise3')})console.log('script end')// script start// async1 start// async start// async2 promise// promise1// script end// promise2// promise3// async1 end// setTimeout 123456789101112131415161718Promise.resolve().then(() =&gt; { console.log(0); return Promise.resolve(4);}).then((res) =&gt; { console.log(res)})Promise.resolve().then(() =&gt; { console.log(1);}).then(() =&gt; { console.log(2);}).then(() =&gt; { console.log(3);}).then(() =&gt; { console.log(5);}).then(() =&gt;{ console.log(6);})","link":"/JavaScript/3.%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"title":"ESM","text":"ESM是ES6引入的JS标准模块化规范，它的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系和输入和输出的变量。 功能：模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 特性 编译时确定模块的依赖关系和输入输出变量 自动采用严格模式 一个模块就是一个文件，该模块内部的所有变量，外部无法获取 好处 使得静态分析成了可能，比如类型检验 不再需要UMD模块格式 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 export如果你希望外部能够读取模块内部的某个变量，必须通过export关键字输出该变量 输出变量 1234567891011// profile.jsexport const a = 1;export const b = 'aaa';export const c = 2021;// 另一种写法const a = 1;const b = 'aaa';const c = 2021;export {a, b, c} 上面的这两种写法的等价的，但推荐使用第二种写法，因为这样可以在模块的末尾一眼看出该模块输出了哪些变量 输出函数 1234567891011export function fn() { console.log()}// 另一种写法function fn1(){}function fn2() {}export {fn1, fn2}// 给函数重命名export {fn1 as st1, fn2 as st2, fn2 as st3} 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 注意：export命令规定的是模块对外的接口，必须与模块内部的变量建立一一对应关系 例如以下的写法会报错 123export 1; // 报错const a = 1;export a; // 报错 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。 正确的写法 12345678910// 写法1export const a = 1;// 写法2const a = 1;export { a }// 写法3const a = 1;export {a as m} 上面三种写法都是正确的，规定了对外的接口a。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。 函数和类同样必须遵守上面的规则 1234567function fn() {}export fn; // 报错export function fn() {} // 正确function fn() {}export {fn} // 正确 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，获取模块内部实时的值 12export let foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面的代码输出时是bar，500ms后会变为baz export只能出现在模块的顶层，不能在块级作用域中 export default：用于模块的默认导出，一个模块中只能存在一个export default 123456// index.jsexport default function() { ...}// 加载，可以为该匿名函数指定任意名字import aaa from './index.js' importimport命令用于输入其他模块提供的功能 123456import { a, b, c } from './index.js';// 直接使用console.log(a);console.log(b);console.log(c); import命令也可以给加载的模块重命名 1import { a as st1, b as st2, c as st3 } from './index.js'; import命令输入的变量都是只读的，因为它本质是输入接口，也就是说，不允许在加载模块的脚本里面，改写接口 123import {a} from './xxx.js'a = {}; // Syntax Error : 'a' is read-only; 上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。 123import { a } from './xxx.js'a.foo = 'hello'; // 合法操作 import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 import命令具有提升效果，会提升到整个模块的头部，首先执行。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12345678910111213// 报错import { 'f' + 'oo' } from 'my_module';// 报错let module = 'my_module';import { foo } from module;// 报错if (x === 1) { import { foo } from 'module1';} else { import { foo } from 'module2';} import语句在没有from的情况下会执行所加载的模块，如果多次执行同一个模块的import，那么只会执行一次 12import 'lodash';import 'lodash'; 如果执行的import语句对应的是同一个模块，等同于只加载一次 12345import { foo } from 'my_module';import { bar } from 'my_module'; // 不建议这么写// 等同于import { foo, bar } from 'my_module'; 复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 12345export { foo, bar } from 'my_module';// 可以简单理解为import { foo, bar } from 'my_module';export { foo, bar }; import()ES2020提案 引入import()函数，支持动态加载模块，并且返回一个Promise对象。 1import(module) 和CommonJs的差异 CommonJS 模块输出的是一个值的拷贝，ESM 模块输出的是值的引用。 CommonJS 模块是运行时加载，ESM 模块是编译时输出接口。 CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。 CommonJS模块，都是只能在运行时确定这些东西。 12345678// CommonJS模块let { stat, exists, readfile } = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面的代码实质是整体加载fs模块，生成一个对象，然后从这三个对象上面读取三个方法，这种加载称为运行时加载，因为只有在运行时才能得到这个对象，导致完全无法在编译时做”静态优化” NodeJs从13.2版本开始支持ESM模块 CommonJS 模块加载 ESM 模块CommonJs不能通过require()命令加载ESM模块，只能通过import()命令加载 12345( async () =&gt; { await import(modlue) })() require()不支持 ESM模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层await命令，导致无法被同步加载。 ESM模块加载CommonjsESM模块的import命令可以加载CommonJs模块，但只能整体加载，不能单独加载单一的输出项","link":"/JavaScript/4.ESM/"},{"title":"防抖和节流","text":"防抖所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 12345678910const debounce = (fn, wait) =&gt; { let timer = 0; return (args) =&gt; { if(timer) window.clearTimeout(timer); timer = window.setTimeout(() =&gt; { fn(args); }, wait) }} 节流所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。 123456789101112const throttle = (fn, wait) =&gt; { let timer = 0; return (args) =&gt; { if(timer) return; timer = window.setTimeout(() =&gt; { fn(args); timer = 0; }, wait) }}","link":"/JavaScript/5.%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"},{"title":"Promise","text":"1.Promise Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息； 从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。 Promise对象有以下两个特点： 对象的状态不受外界影响，Promise对象代表一个异步操作，有三种状态：pending(进行中)，fulfilled(已成功)和rejected(已失败)，只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是Promise这个名字的由来。 一旦状态改变，就不会再变，任何时候都可以得到这个结果，Promise对象状态改变，只有两种情况，从pending变为fufilled和从pending变为rejected，只要这两种情况发生，状态就凝固了，不会再变了，这时就称为resolved。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 2.实例方法 Promise.prototype.then() 为Promise实例添加状态改变时的回调函数，第一个参数是resolve状态的回调函数，第二个参数是reject状态的回调函数 then方法会返回一个新的Promise实例，因此可以采用链式写法，即then后面再调用一个then 1fetch('/api/xxx').then(res =&gt; res.json()).then(data =&gt; console.log(data)) Promise.prototype.catch() catch方法是.then(_,rejection)方法的别名，用于指定发生错误时的回调函数 catch方法不仅可以捕获reject函数的回调，也能捕获异步运行时抛出的异常 1234567const promise = new Promise(function(resolve, reject) { throw new Error('test');});promise.catch(function(error) { console.log(error);});// Error: test 上面代码中，promise抛出一个错误，就被catch()方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 12345678910111213141516171819// 写法一const promise = new Promise(function(resolve, reject) { try { throw new Error('test'); } catch(e) { reject(e); }});promise.catch(function(error) { console.log(error);});// 写法二const promise = new Promise(function(resolve, reject) { reject(new Error('test'));});promise.catch(function(error) { console.log(error);}); Promise.prototyp.finally() finally方法用于指定不管Promise对象最后状态如何，都会执行操作。 1234promise.then(result =&gt; {···}).catch(error =&gt; {···}).finally(() =&gt; {···}); 3.静态方法 Promise.all() Promise.all()方法用于将多个Promise实例，包装成一个新的Promise实例，并且只有当所有Promise实例状态都变成fulfilled，该实例的状态才会变成fulfilled，并返回实例返回值组成的一个数组。 该方法常用于多个接口的并发请求 1Promise.all(api1, api2, api3).then(res =&gt; console.log(res)) // 会返回三个接口数据组成的数组 如果有一个实例的状态变为rejected，那么该实例的状态就会变为rejected Promise.race() 该方法同样是将多个Promise实例，包装成一个新的Promise实例 只要被包裹的Promise实例中，有一个状态变为fulfilled，那么该实例的状态就直接变为fulfilled 如果有一个被包裹的Promise状态变为rejected，那么Promise状态就会变为reject Promise.allSettled() Promise.allSettled()方法，用来确定一组异步组件操作是否都结束了，只有当被包裹的对象都发生了状态变更，返回的Promise对象才会发生状态变更 Promise.any() ES2021引入的新方法，只要被包裹的实例有一个变成fulfilled状态，包装实例就会变成fulfilled，如果所有参数实例都变成rejected，包装实例就会变成rejected状态 Promise.resolve() Promise.resolve方法将一个对象转为Promise对象,其参数分为四种情况 参数是一个Promise实例 如果参数是一个Promise实例，将不做修改，原封不动地返回这个实例 参数是一个thenable实例 thenable对象是指具有then方法的对象，Promise.resolve方法会将这个对象转为Promise对象，然后执行thenable对象的then方法 12345678910let thenable = { then: function(resolve, reject) { resolve(42); }};let p1 = Promise.resolve(thenable);p1.then(function (value) { console.log(value); // 42}); 参数不具有then()方法的对象，或者根本就不是对象 参数不是具有then()方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve('Hello');p.then(function (s) { console.log(s)});// Hello 不带任何参数 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。 12345const p = Promise.resolve();p.then(function () { // ...}); 需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () { console.log('three');}, 0);Promise.resolve().then(function () { console.log('two');});console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。 Promise.reject() Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) { console.log(s)});// 出错了 4.应用 对事件监听处理异步的二次封装 Pormise在实际业务开发中常用于事件监听解决异步的二次封装 例如将图片转为Base64编码格式时，需要实例化一个FileReader对象，并且添加load事件监听 如果不用Promise处理，则需要传入一个回调函数获取 123456789101112function getBase64(img, callback) { const reader new FileReader(); reader.addEventListener('load', () =&gt; callback(reader.result)); reader.readAsDataURL(img);}// 使用getBase64(img, baseUrl =&gt; this.setState({ baseUrl }),); 如果使用Promise进行处理，则可以这么写 1234567891011121314function getBase65(img) { return new Promise(resolve =&gt; { const reader new FileReader(); reader.addEventListener('load', () =&gt; resolve(reader.result)); reader.readAsDataURL(img); })}// 使用getBase64(img).then(baseUrl =&gt; { this.setState({ baseUrl }),})","link":"/JavaScript/24.Promise/"},{"title":"import.meta属性","text":"import.metaimport.meta是一个给JavaScript模块暴露特定上下文的元数据属性的对象。有ECMAScript实现，原型是null，并且默认带有一个url对象，这个对象可扩展，它的属性都是可写，可配置，可枚举的 1&lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt; // 必须是module 1console.log(import.meta); // {url: 'http://127.0.0.1:5500/index.js'}","link":"/JavaScript/26.import.meta/"},{"title":"Generator","text":"1.特性·function关键字与函数名之间有一个星号 内部通过yield表达式，定义不同的内部状态 返回的遍历器对象，使用next()方法依次遍历函数内部的状态 2.yield表达式Generator函数内部通过yield表达式来暂停执行后面的操作，只有通过next()方法才能继续往下执行 next方法的运行逻辑： 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值 再次调用next方法，就继续往下执行，直到遇到下一个yield表达式，就暂停执行并将后面的值赋给value返回 如果没有遇到新的yield表达式，就一直运行到函数结束，将return语句后面的表达式作为对象的value值返回，如果没有return语句，则返回undefined 3.与Iterator的关系Generator函数就是遍历器的生成函数，可以把Generator赋值给对象的Symbol.Iterator属性，从而使得该对象可以被Iterator接口相关的语句遍历 123456789101112const obj = {}obj[Symbol.iterator] = function * () { yield 1; yield 2; yield 3;}[...obj]for(const i of obj) { console.log(i)} 4. next方法参数yield表达式本身没有返回值，或者说返回值是undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值 123456789101112131415function* foo(x) { var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);}var a = foo(5);a.next() // Object{value:6, done:false}a.next() // Object{value:NaN, done:false}a.next() // Object{value:NaN, done:true}var b = foo(5);b.next() // { value:6, done:false }b.next(12) // { value:8, done:false }b.next(13) // { value:42, done:true } 上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。 如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。 5.next() throw() return() 都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式 next()是将上一个yield表达式替换成一个值 1234567891011const g = function* (x, y) { let result = yield x + y; return result;};const gen = g(1, 2);gen.next(); // Object {value: 3, done: false}gen.next(1); // Object {value: 1, done: true}// 相当于将 let result = yield x + y// 替换成 let result = 1; throw()是将yield表达式替换成一个throw语句 123gen.throw(new Error('出错了')); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error('出错了')); return()相当于将yield表达式替换成一个return语句 123gen.return(2); // Object {value: 2, done: true}// 相当于将 let result = yield x + y// 替换成 let result = return 2; 6.yield*yield*表达式用来在一个Generator函数里面执行另一个Generator函数 1234567891011121314function * foo() { yield 'a'; yield 'b'}function * bar() { yield 'x'; yield foo(); yield 'y'}for(let item of bar()) { console.log(item) // x a b y} 任何数据结构只要有iterator接口，就能被yield*遍历 12345function * gen() { yield * [1,2,3]}gen().next() 7.处理异步传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程的执行流程 协程A开始执行 协程A执行到一半，进入暂停，执行权转移到协程B 一段时间后，协程B交还执行权并恢复协程A的执行 协程的Generator函数实现Generator函数是协程在ES6的实现，最大的特点就是可以交出函数的执行权(暂停执行)。 整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器，异步操作需要暂停的地方，都使用yield语句注明 1234function * gen(x) { var y = yield x + 2; return y} Generator函数数据的交换和错误处理Generator函数所具有的特性，使它成为异步编程的解决方案 可以暂停执行和恢复执行，这是它能封装异步任务的根本原因 函数体内外的数据交换和错误处理机制，使它可以作为异步编程的完整解决方案 调用next()方法返回值的value属性，是Generator函数向外输出数据，而在调用next()方法还可以接受参数，向Generator函数体内输入数据 12345678function* gen(x){ var y = yield x + 2; return y;}var g = gen(1);g.next() // { value: 3, done: false }g.next(2) // { value: 2, done: true } Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误 12345678910111213function* gen(x){ try { var y = yield x + 2; } catch (e){ console.log(e); } return y;}var g = gen(1);g.next();g.throw('出错了');// 出错了 上面代码的最后一行，Generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 1234567var fetch = require('node-fetch');function* gen(){ var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result);} 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 12345678var g = gen();var result = g.next();result.value.then(function(data){ return data.json();}).then(function(data){ g.next(data);}); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 自动执行Generator 封装一个基于Promise的自动执行机制 1234567891011121314151617var fs = require('fs');var readFile = function (fileName){ return new Promise(function (resolve, reject){ fs.readFile(fileName, function(error, data){ if (error) return reject(error); resolve(data); }); });};var gen = function* (){ var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());}; 手动执行上面的Generator函数 1234567var g = gen();g.next().value.then(function(data){ g.next(data).value.then(function(data){ g.next(data); });}); 手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。 123456789101112131415function run(gen){ var g = gen(); function next(data){ var result = g.next(data); if (result.done) return result.value; result.value.then(function(data){ next(data); }); } next();}run(gen);","link":"/JavaScript/25.Generator/"},{"title":"WebSocket","text":"1.Websocket Websocket是一种基于TCP的全双工通讯协议，现在的业务场景中可能会遇到一些需要实时请求数据去刷新页面的需求，在ws协议出来之前，我们常用的方式有三种，轮询，长轮询和数据流，但这三种方式都十分的占用服务器资源。WebSocket协议基于TCP，只要一次握手后，就可以保持连接不断开，并且服务端可以主动发送数据给客户端，减轻了服务器的压力 2.特点 建立在TCP协议的基础上，双向通信，服务端也可以主动向客户端推送数据 兼容HTTP协议，在握手时使用的就是HTTP协议 数据格式轻量，可以发送文本，也可以发送二进制数据 没有同源限制 3.通信原理WebSocket在请求阶段使用的是HTTP协议，在协议的请求头中，会有两个标识，一是客户端标识key，二是Upgrade字段，表示告诉服务器要进行协议的升级。服务器在拿到请求头后会进行判断，如果支持，则会在响应头中，带上需要升级的Upgrade和客户端标识key","link":"/JavaScript/27.websocket/"},{"title":"Set和Map数据结构","text":"1.SetES6提供了新的数据结构Set。它类似于数组，但成员的值都是唯一的，没有重复的值 注意：Set结构没有键名，或者说键名和键值是同一个值 Set本身是一个构造函数，用来生成Set数据结构 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) { console.log(i);}// 2 3 5 4 上面的代码通过add()方法向Set结构加入成员，结果表明Set结构不会添加重复的值 Set函数可以接受一个数组(或者具有iterator接口的其他数据结构)，作为参数，用来初始化 12345678910111213141516171819// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll('div'));set.size // 56// 类似于const set = new Set();document .querySelectorAll('div') .forEach(div =&gt; set.add(div));set.size // 56 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。 12// 去除数组的重复成员[...new Set(array)] 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。 123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set {NaN} 上面代码向 Set 实例添加了两次NaN，但是只会加入一个。这表明，在 Set 内部，两个NaN是相等的。 另外，两个对象总是不相等的。 1234567let set = new Set();set.add({});set.size // 1set.add({});set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 2.Set实例的属性和方法Set结构的实例有以下属性 Set.prototype.constructor：构造函数，默认就是Set函数 Set.prototype.size：返回Set实例的成员个数 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。 12345678910111213141516171819// 对象的写法const properties = { 'width': 1, 'height': 1};if (properties[someName]) { // do something}// Set的写法const properties = new Set();properties.add('width');properties.add('height');if (properties.has(someName)) { // do something} Array.from方法可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 12345function dedupe(array) { return Array.from(new Set(array));}dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 key() value() forEach()keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) { console.log(item);}// red// green// bluefor (let item of set.values()) { console.log(item);}// red// green// bluefor (let item of set.entries()) { console.log(item);}// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。 12Set.prototype[Symbol.iterator] === Set.prototype.values// true 这意味着，可以省略values方法，直接用for...of循环遍历 Set。 12345678let set = new Set(['red', 'green', 'blue']);for (let x of set) { console.log(x);}// red// green// blue forEach()Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 12345let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9 上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。 另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。 遍历的应用扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。 123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 而且，数组的map和filter方法也可以间接用于 Set 了。 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：{2, 4, 6}let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：{2, 4} 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set {1, 2, 3, 4}// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set {2, 3}// （a 相对于 b 的）差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set {1} 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。 123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。 3.WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别： WeakSet 的成员只能是对象，而不能是其他类型的值。 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 12345const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set WeakSet 结构有以下三个方法。 **WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。 **WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。 **WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 WeakSet 没有size属性，没有办法遍历它的成员。 12345ws.size // undefinedws.forEach // undefinedws.forEach(function(item){ console.log('WeakSet has ' + item)})// TypeError: undefined is not a function 上面代码试图获取size和forEach属性，结果都不能成功。 WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 4.MapJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 12345const data = {};const element = document.getElementById('myDiv');data[element] = 'metadata';data['[object HTMLDivElement]'] // &quot;metadata&quot; 上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 123456789const m = new Map();const o = {p: 'Hello World'};m.set(o, 'content')m.get(o) // &quot;content&quot;m.has(o) // truem.delete(o) // truem.has(o) // false 上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // &quot;张三&quot;map.has('title') // truemap.get('title') // &quot;Author&quot; 上面代码在新建 Map 实例时，就指定了两个键name和title。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。 12345678910const items = [ ['name', '张三'], ['title', 'Author']];const map = new Map();items.forEach( ([key, value]) =&gt; map.set(key, value)); 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 12345678910const set = new Set([ ['foo', 1], ['bar', 2]]);const m1 = new Map(set);m1.get('foo') // 1const m2 = new Map([['baz', 3]]);const m3 = new Map(m2);m3.get('baz') // 3 上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。 如果对同一个键多次赋值，后面的值将覆盖前面的值。 1234567const map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // &quot;bbb&quot; 上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。 如果读取一个未知的键，则返回undefined。 12new Map().get('asfddfsasadf')// undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。 同理，同样的值的两个实例，在 Map 结构中被视为两个键。 1234567891011const map = new Map();const k1 = ['a'];const k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。 由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set('true', 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 实例属性和操作方法Map 结构的实例有以下属性和操作方法。 （1）size 属性 size属性返回 Map 结构的成员总数。 12345const map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 （2）Map.prototype.set(key, value) set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 12345const m = new Map();m.set('edition', 6) // 键是字符串m.set(262, 'standard') // 键是数值m.set(undefined, 'nah') // 键是 undefined set方法返回的是当前的Map对象，因此可以采用链式写法。 1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); （3）Map.prototype.get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 123456const m = new Map();const hello = function() {console.log('hello');};m.set(hello, 'Hello ES6!') // 键是函数m.get(hello) // Hello ES6! （4）Map.prototype.has(key) has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 12345678910const m = new Map();m.set('edition', 6);m.set(262, 'standard');m.set(undefined, 'nah');m.has('edition') // truem.has('years') // falsem.has(262) // truem.has(undefined) // true （5）Map.prototype.delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 123456const m = new Map();m.set(undefined, 'nah');m.has(undefined) // truem.delete(undefined)m.has(undefined) // false （6）Map.prototype.clear() clear方法清除所有成员，没有返回值。 1234567let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0 遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。 Map.prototype.keys()：返回键名的遍历器。 Map.prototype.values()：返回键值的遍历器。 Map.prototype.entries()：返回所有成员的遍历器。 Map.prototype.forEach()：遍历 Map 的所有成员。 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) { console.log(key);}// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) { console.log(value);}// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) { console.log(item[0], item[1]);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) { console.log(key, value);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) { console.log(key, value);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot; Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。 1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 5.WeakMapWeakMap结构与Map结构类似，也是用于生成键值对的集合。 123456789101112// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = {foo: 1};wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);wm2.get(k2) // &quot;bar&quot; WeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key 上面代码中，如果将数值1和Symbol值作为 WeakMap 的键名，都会报错。 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。 123456const e1 = document.getElementById('foo');const e2 = document.getElementById('bar');const arr = [ [e1, 'foo 元素'], [e2, 'bar 元素'],]; 面代码中，e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用。 一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。 1234// 不需要 e1 和 e2 的时候// 必须手动删除引用arr [0] = null;arr [1] = null; 上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。 WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。 123456const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // &quot;some information&quot; 上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，上面的 DOM 节点对象除了 WeakMap 的弱引用外，其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。 总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。 12345678const wm = new WeakMap();let key = {};let obj = {foo: 1};wm.set(key, obj);obj = null;wm.get(key)// Object {foo: 1} 上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。 WeakMap 的语法WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 123456const wm = new WeakMap();// size、forEach、clear 方法都不存在wm.size // undefinedwm.forEach // undefinedwm.clear // undefined 6.WeakRefWeakSet 和 WeakMap 是基于弱引用的数据结构，ES2021 更进一步，提供了 WeakRef 对象，用于直接创建对象的弱引用。 12let target = {};let wr = new WeakRef(target); 上面示例中，target是原始对象，构造函数WeakRef()创建了一个基于target的新对象wr。这里，wr就是一个 WeakRef 的实例，属于对target的弱引用，垃圾回收机制不会计入这个引用，也就是说，wr的引用不会妨碍原始对象target被垃圾回收机制清除。 WeakRef 实例对象有一个deref()方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回undefined。 1234567let target = {};let wr = new WeakRef(target);let obj = wr.deref();if (obj) { // target 未被垃圾回收机制清除 // ...} 上面示例中，deref()方法可以判断原始对象是否已被清除。 弱引用对象的一大用处，就是作为缓存，未被清除时可以从缓存取值，一旦清除缓存就自动失效。 12345678910111213141516function makeWeakCached(f) { const cache = new Map(); return key =&gt; { const ref = cache.get(key); if (ref) { const cached = ref.deref(); if (cached !== undefined) return cached; } const fresh = f(key); cache.set(key, new WeakRef(fresh)); return fresh; };}const getImageCached = makeWeakCached(getImage); 上面示例中，makeWeakCached()用于建立一个缓存，缓存里面保存对原始文件的弱引用。 注意，标准规定，一旦使用WeakRef()创建了原始对象的弱引用，那么在本轮事件循环（event loop），原始对象肯定不会被清除，只会在后面的事件循环才会被清除。","link":"/JavaScript/21.Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"Proxy","text":"1.概述Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种”元编程”，即对编程语言进行编程 Proxy可以理解成，在目标对象之前架设一层”拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由他来代理某些操作 123456789const obj = new Proxy({}, { get: function(target, propKey, receiver) { return Reflect.get(target, propKey, receiver); }, set: function(target, propKey, value, receiver) { console.log(`setting ${propKey}!`); return Reflect.set(target, propKey, value, receiver); }}) 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。 123456obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 12345var target = {};var handler = {};var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // &quot;b&quot; 上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。 下面是 Proxy 支持的拦截操作一览，一共 13 种。 **get(target, propKey, receiver)**：拦截对象属性的读取，比如proxy.foo和proxy['foo']。 **set(target, propKey, value, receiver)**：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。 **has(target, propKey)**：拦截propKey in proxy的操作，返回一个布尔值。 **deleteProperty(target, propKey)**：拦截delete proxy[propKey]的操作，返回一个布尔值。 **ownKeys(target)**：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 **getOwnPropertyDescriptor(target, propKey)**：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 **defineProperty(target, propKey, propDesc)**：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 **preventExtensions(target)**：拦截Object.preventExtensions(proxy)，返回一个布尔值。 **getPrototypeOf(target)**：拦截Object.getPrototypeOf(proxy)，返回一个对象。 **isExtensible(target)**：拦截Object.isExtensible(proxy)，返回一个布尔值。 **setPrototypeOf(target, proto)**：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 2.Proxy实例的方法get()get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。 12345678910111213141516var person = { name: &quot;张三&quot;};var proxy = new Proxy(person, { get: function(target, propKey) { if (propKey in target) { return target[propKey]; } else { throw new ReferenceError(&quot;Prop name \\&quot;&quot; + propKey + &quot;\\&quot; does not exist.&quot;); } }});proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 get方法可以继承。 123456789let proto = new Proxy({}, { get(target, propertyKey, receiver) { console.log('GET ' + propertyKey); return target[propertyKey]; }});let obj = Object.create(proto);obj.foo // &quot;GET foo&quot; 上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。 下面的例子使用get拦截，实现数组读取负数的索引。 123456789101112131415161718function createArray(...elements) { let handler = { get(target, propKey, receiver) { let index = Number(propKey); if (index &lt; 0) { propKey = String(target.length + index); } return Reflect.get(target, propKey, receiver); } }; let target = []; target.push(...elements); return new Proxy(target, handler);}let arr = createArray('a', 'b', 'c');arr[-1] // c 上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。 利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。 12345678910111213141516171819202122var pipe = function (value) { var funcStack = []; var oproxy = new Proxy({} , { get : function (pipeObject, fnName) { if (fnName === 'get') { return funcStack.reduce(function (val, fn) { return fn(val); },value); } funcStack.push(window[fnName]); return oproxy; } }); return oproxy;}var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;pipe(3).double.pow.reverseInt.get; // 63 上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。 下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。 123456789101112131415161718192021222324252627282930const dom = new Proxy({}, { get(target, property) { return function(attrs = {}, ...children) { const el = document.createElement(property); for (let prop of Object.keys(attrs)) { el.setAttribute(prop, attrs[prop]); } for (let child of children) { if (typeof child === 'string') { child = document.createTextNode(child); } el.appendChild(child); } return el; } }});const el = dom.div({}, 'Hello, my name is ', dom.a({href: '//example.com'}, 'Mark'), '. I like:', dom.ul({}, dom.li({}, 'The web'), dom.li({}, 'Food'), dom.li({}, '…actually that\\'s it') ));document.body.appendChild(el); 下面是一个get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。 123456const proxy = new Proxy({}, { get: function(target, key, receiver) { return receiver; }});proxy.getReceiver === proxy // true 上面代码中，proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象。 12345678const proxy = new Proxy({}, { get: function(target, key, receiver) { return receiver; }});const d = Object.create(proxy);d.a === d // true 上面代码中，d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。 如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。 123456789101112131415161718const target = Object.defineProperties({}, { foo: { value: 123, writable: false, configurable: false },});const handler = { get(target, propKey) { return 'abc'; }};const proxy = new Proxy(target, handler);proxy.foo// TypeError: Invariant check failed set()set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。 123456789101112131415161718192021222324let validator = { set: function(obj, prop, value) { if (prop === 'age') { if (!Number.isInteger(value)) { throw new TypeError('The age is not an integer'); } if (value &gt; 200) { throw new RangeError('The age seems invalid'); } } // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; return true; }};let person = new Proxy({}, validator);person.age = 100;person.age // 100person.age = 'young' // 报错person.age = 300 // 报错 上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。 有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。 12345678910111213141516171819202122const handler = { get (target, key) { invariant(key, 'get'); return target[key]; }, set (target, key, value) { invariant(key, 'set'); target[key] = value; return true; }};function invariant (key, action) { if (key[0] === '_') { throw new Error(`Invalid attempt to ${action} private &quot;${key}&quot; property`); }}const target = {};const proxy = new Proxy(target, handler);proxy._prop// Error: Invalid attempt to get private &quot;_prop&quot; propertyproxy._prop = 'c'// Error: Invalid attempt to set private &quot;_prop&quot; property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。 下面是set方法第四个参数的例子。 123456789const handler = { set: function(obj, prop, value, receiver) { obj[prop] = receiver; return true; }};const proxy = new Proxy({}, handler);proxy.foo = 'bar';proxy.foo === proxy // true 上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身，请看下面的例子。 123456789101112const handler = { set: function(obj, prop, value, receiver) { obj[prop] = receiver; return true; }};const proxy = new Proxy({}, handler);const myObj = {};Object.setPrototypeOf(myObj, proxy);myObj.foo = 'bar';myObj.foo === myObj // true 上面代码中，设置myObj.foo属性的值时，myObj并没有foo属性，因此引擎会到myObj的原型链去找foo属性。myObj的原型对象proxy是一个 Proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myObj。 注意，如果目标对象自身的某个属性不可写，那么set方法将不起作用。 12345678910111213141516const obj = {};Object.defineProperty(obj, 'foo', { value: 'bar', writable: false});const handler = { set: function(obj, prop, value, receiver) { obj[prop] = 'baz'; return true; }};const proxy = new Proxy(obj, handler);proxy.foo = 'baz';proxy.foo // &quot;bar&quot; 上面代码中，obj.foo属性不可写，Proxy 对这个属性的set代理将不会生效。 注意，set代理应当返回一个布尔值。严格模式下，set代理如果没有返回true，就会报错。 1234567891011'use strict';const handler = { set: function(obj, prop, value, receiver) { obj[prop] = receiver; // 无论有没有下面这一行，都会报错 return false; }};const proxy = new Proxy({}, handler);proxy.foo = 'bar';// TypeError: 'set' on proxy: trap returned falsish for property 'foo' 上面代码中，严格模式下，set代理返回false或者undefined，都会报错。 apply()apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 12345var handler = { apply (target, ctx, args) { return Reflect.apply(...arguments); }}; 下面是一个例子。 1234567891011var target = function () { return 'I am the target'; };var handler = { apply: function () { return 'I am the proxy'; }};var p = new Proxy(target, handler);p()// &quot;I am the proxy&quot; 上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。 下面是另外一个例子。 123456789101112var twice = { apply (target, ctx, args) { return Reflect.apply(...arguments) * 2; }};function sum (left, right) { return left + right;};var proxy = new Proxy(sum, twice);proxy(1, 2) // 6proxy.call(null, 5, 6) // 22proxy.apply(null, [7, 8]) // 30 上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。 另外，直接调用Reflect.apply方法，也会被拦截。 1Reflect.apply(proxy, null, [9, 10]) // 38 has()has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。 has()方法可以接受两个参数，分别是目标对象、需查询的属性名。 下面的例子使用has()方法隐藏某些属性，不被in运算符发现。 1234567891011var handler = { has (target, key) { if (key[0] === '_') { return false; } return key in target; }};var target = { _prop: 'foo', prop: 'foo' };var proxy = new Proxy(target, handler);'_prop' in proxy // false 上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has()就会返回false，从而不会被in运算符发现。 如果原对象不可配置或者禁止扩展，这时has()拦截会报错。 12345678910var obj = { a: 10 };Object.preventExtensions(obj);var p = new Proxy(obj, { has: function(target, prop) { return false; }});'a' in p // TypeError is thrown 上面代码中，obj对象禁止扩展，结果使用has拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则has()方法就不得“隐藏”（即返回false）目标对象的该属性。 值得注意的是，has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。 另外，虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。 12345678910111213141516171819202122232425262728293031323334let stu1 = {name: '张三', score: 59};let stu2 = {name: '李四', score: 99};let handler = { has(target, prop) { if (prop === 'score' &amp;&amp; target[prop] &lt; 60) { console.log(`${target.name} 不及格`); return false; } return prop in target; }}let oproxy1 = new Proxy(stu1, handler);let oproxy2 = new Proxy(stu2, handler);'score' in oproxy1// 张三 不及格// false'score' in oproxy2// truefor (let a in oproxy1) { console.log(oproxy1[a]);}// 张三// 59for (let b in oproxy2) { console.log(oproxy2[b]);}// 李四// 99 上面代码中，has()拦截只对in运算符生效，对for...in循环不生效，导致不符合要求的属性没有被for...in循环所排除。 3.this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 1234567891011const target = { m: function () { console.log(this === proxy); }};const handler = {};const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true 上面代码中，一旦proxy代理target，target.m()内部的this就是指向proxy，而不是target。 下面是一个例子，由于this指向的变化，导致 Proxy 无法代理目标对象。 12345678910111213141516const _name = new WeakMap();class Person { constructor(name) { _name.set(this, name); } get name() { return _name.get(this); }}const jane = new Person('Jane');jane.name // 'Jane'const proxy = new Proxy(jane, {});proxy.name // undefined 上面代码中，目标对象jane的name属性，实际保存在外部WeakMap对象_name上面，通过this键区分。由于通过proxy.name访问时，this指向proxy，导致无法取到值，所以返回undefined。 此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。 123456const target = new Date();const handler = {};const proxy = new Proxy(target, handler);proxy.getDate();// TypeError: this is not a Date object. 上面代码中，getDate()方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。 123456789101112const target = new Date('2015-01-01');const handler = { get(target, prop) { if (prop === 'getDate') { return target.getDate.bind(target); } return Reflect.get(target, prop); }};const proxy = new Proxy(target, handler);proxy.getDate() // 1 另外，Proxy 拦截函数内部的this，指向的是handler对象。 1234567891011121314151617181920const handler = { get: function (target, key, receiver) { console.log(this === handler); return 'Hello, ' + key; }, set: function (target, key, value) { console.log(this === handler); target[key] = value; return true; }};const proxy = new Proxy({}, handler);proxy.foo// true// Hello, fooproxy.foo = 1// true 上面例子中，get()和set()拦截函数内部的this，指向的都是handler对象。","link":"/JavaScript/22.Proxy/"},{"title":"Reflect","text":"1.ReflectReflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象设计的目的有这样几个 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 1234567891011121314// 老写法try { Object.defineProperty(target, property, attributes); // success} catch (e) { // failure}// 新写法if (Reflect.defineProperty(target, property, attributes)) { // success} else { // failure} 让Object操作都变成函数行为，某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 12345// 老写法'assign' in Object // true// 新写法Reflect.has(Object, 'assign') // true Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为 123456789Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; }}); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能 1234567891011121314var loggedObj = new Proxy(obj, { get(target, name) { console.log('get', target, name); return Reflect.get(target, name); }, deleteProperty(target, name) { console.log('delete' + name); return Reflect.deleteProperty(target, name); }, has(target, name) { console.log('has' + name); return Reflect.has(target, name); }}); 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。 有了Reflect对象以后，很多操作会更易读。 12345// 老写法Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1// 新写法Reflect.apply(Math.floor, undefined, [1.75]) // 1 2.静态方法Reflect对象一共有13个静态方法 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。 Reflect.get(target, name, reciver)Reflect.get方法查找并返回target对象的name属性的值，如果没有该属性，则返回undefined。 1234567891011var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; },}Reflect.get(myObject, 'foo') // 1Reflect.get(myObject, 'bar') // 2Reflect.get(myObject, 'baz') // 3 Reflect.set(target, name, value, receiver)Reflect.set方法设置target对象的name属性等于value 1234567891011121314var myObject = { foo: 1, set bar(value) { return this.foo = value; },}myObject.foo // 1Reflect.set(myObject, 'foo', 2);myObject.foo // 2Reflect.set(myObject, 'bar', 3)myObject.foo // 3 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。 1234567891011121314var myObject = { foo: 4, set bar(value) { return this.foo = value; },};var myReceiverObject = { foo: 0,};Reflect.set(myObject, 'bar', 1, myReceiverObject);myObject.foo // 4myReceiverObject.foo // 1 注意，如果 Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。 12345678910111213141516171819let p = { a: 'a'};let handler = { set(target, key, value, receiver) { console.log('set'); Reflect.set(target, key, value, receiver) }, defineProperty(target, key, attribute) { console.log('defineProperty'); Reflect.defineProperty(target, key, attribute); }};let obj = new Proxy(p, handler);obj.a = 'A';// set// defineProperty 上面代码中，Proxy.set拦截里面使用了Reflect.set，而且传入了receiver，导致触发Proxy.defineProperty拦截。这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。 123456789101112131415161718let p = { a: 'a'};let handler = { set(target, key, value, receiver) { console.log('set'); Reflect.set(target, key, value) }, defineProperty(target, key, attribute) { console.log('defineProperty'); Reflect.defineProperty(target, key, attribute); }};let obj = new Proxy(p, handler);obj.a = 'A';// set 如果第一个参数不是对象，Reflect.set会报错。 12Reflect.set(1, 'foo', {}) // 报错Reflect.set(false, 'foo', {}) // 报错 Reflect.has(obj, name)Reflect.has方法对应name in obj里面的in运算符。 123456789var myObject = { foo: 1,};// 旧写法'foo' in myObject // true// 新写法Reflect.has(myObject, 'foo') // true 如果Reflect.has()方法的第一个参数不是对象，会报错。 Reflect.deleteProperty(obj, name)Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。 1234567const myObj = { foo: 'bar' };// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, 'foo'); 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。 如果Reflect.deleteProperty()方法的第一个参数不是对象，会报错。 Reflect.construct(target, args)Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。 123456789function Greeting(name) { this.name = name;}// new 的写法const instance = new Greeting('张三');// Reflect.construct 的写法const instance = Reflect.construct(Greeting, ['张三']); 如果Reflect.construct()方法的第一个参数不是函数，会报错。 Reflect.getPrototypeOf(obj)Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。 1234567const myObj = new FancyThing();// 旧写法Object.getPrototypeOf(myObj) === FancyThing.prototype;// 新写法Reflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。 12Object.getPrototypeOf(1) // Number {[[PrimitiveValue]]: 0}Reflect.getPrototypeOf(1) // 报错 Reflect.setPrototypeOf(obj, newProto)Reflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。 123456789const myObj = {};// 旧写法Object.setPrototypeOf(myObj, Array.prototype);// 新写法Reflect.setPrototypeOf(myObj, Array.prototype);myObj.length // 0 如果无法设置目标对象的原型（比如，目标对象禁止扩展），Reflect.setPrototypeOf方法返回false。 1234Reflect.setPrototypeOf({}, null)// trueReflect.setPrototypeOf(Object.freeze({}), null)// false 如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。 12345Object.setPrototypeOf(1, {})// 1Reflect.setPrototypeOf(1, {})// TypeError: Reflect.setPrototypeOf called on non-object 如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。 12345Object.setPrototypeOf(null, {})// TypeError: Object.setPrototypeOf called on null or undefinedReflect.setPrototypeOf(null, {})// TypeError: Reflect.setPrototypeOf called on non-object Reflect.apply(func, thisArg, args)Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。 一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。 1234567891011const ages = [11, 33, 12, 54, 18, 96];// 旧写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// 新写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.defineProperty(target, propertyKey, attributes)Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。 12345678910111213function MyDate() { /*…*/}// 旧写法Object.defineProperty(MyDate, 'now', { value: () =&gt; Date.now()});// 新写法Reflect.defineProperty(MyDate, 'now', { value: () =&gt; Date.now()}); 如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误，比如Reflect.defineProperty(1, 'foo')。 这个方法可以与Proxy.defineProperty配合使用。 1234567891011const p = new Proxy({}, { defineProperty(target, prop, descriptor) { console.log(descriptor); return Reflect.defineProperty(target, prop, descriptor); }});p.foo = 'bar';// {value: &quot;bar&quot;, writable: true, enumerable: true, configurable: true}p.foo // &quot;bar&quot; 上面代码中，Proxy.defineProperty对属性赋值设置了拦截，然后使用Reflect.defineProperty完成了赋值。 Reflect.getOwnPropertyDescriptor(target, propertyKey)Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。 1234567891011var myObject = {};Object.defineProperty(myObject, 'hidden', { value: true, enumerable: false,});// 旧写法var theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');// 新写法var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden'); Reflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, 'foo')不报错，返回undefined，而Reflect.getOwnPropertyDescriptor(1, 'foo')会抛出错误，表示参数非法。 Reflect.isExtensible (target)Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。 1234567const myObject = {};// 旧写法Object.isExtensible(myObject) // true// 新写法Reflect.isExtensible(myObject) // true 如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。 12Object.isExtensible(1) // falseReflect.isExtensible(1) // 报错 Reflect.preventExtensions(target)Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 1234567var myObject = {};// 旧写法Object.preventExtensions(myObject) // Object {}// 新写法Reflect.preventExtensions(myObject) // true 如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环境返回传入的参数，而Reflect.preventExtensions会报错。 12345678// ES5 环境Object.preventExtensions(1) // 报错// ES6 环境Object.preventExtensions(1) // 1// 新写法Reflect.preventExtensions(1) // 报错 Reflect.ownKeys (target)Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 1234567891011121314151617var myObject = { foo: 1, bar: 2, [Symbol.for('baz')]: 3, [Symbol.for('bing')]: 4,};// 旧写法Object.getOwnPropertyNames(myObject)// ['foo', 'bar']Object.getOwnPropertySymbols(myObject)//[Symbol(baz), Symbol(bing)]// 新写法Reflect.ownKeys(myObject)// ['foo', 'bar', Symbol(baz), Symbol(bing)] 如果Reflect.ownKeys()方法的第一个参数不是对象，会报错 3.实例：使用 Proxy 实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 12345678910111213const person = observable({ name: '张三', age: 20});function print() { console.log(`${person.name}, ${person.age}`)}observe(print);person.name = '李四';// 输出// 李四, 20 上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 12345678910const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, {set});function set(target, key, value, receiver) { const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;} 上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。","link":"/JavaScript/23.Reflect/"},{"title":"ES6运算符的扩展","text":"1.指数运算符ES2016新增的指数运算符** 1234562** 2 // 42 ** 3 // 8// 相当于Math.pow(2,2)Math.pow(2,3) 指数运算符的特点是右结合 1232 ** 3 ** 2 // 512//相当于 2 ** (3 ** 2) 指数运算符可以和等号结合 123let a = 3;a **= 3; // 相当于 a = a ** 3; 2.链式判断运算符当我们想要读取变量中的某个属性并进行一定操作时，往往需要判断一下对象中的属性是否存在 12345678// 错误的写法const firstName = message.body.user.firstName || 'default';// 正确的写法(需要判断四次)const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || 'default'; 或者使用三元运算符 12const fooInput = myForm.querySelector('input[name=foo]')const fooValue = fooInput ? fooInput.value : undefined ES2020引入了链判断运算符，来简化这些判断?. 12const firstName = message?.body?.user?.firstName || 'default';const fooValue = myForm.querySelector('input[name=foo]')?.value 使用链判断运算符的语句，直接在调用时会判断左侧的对象是否为null或undefined，如果是，则停止往下执行并返回undefined 常见写法123456789101112131415a?.b// 等同于a == null ? undefined : a.ba?.[x]// 等同于a == null ? undefined : a[x]a?.b()// 等同于a == null ? undefined : a.b()a?.()// 等同于a == null ? undefined : a() 本质上，?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行 如果属性链中带有括号，那么链判断运算符对括号外部没有影响 123(a?.b).c; // 等价于 (a == null ? undefined : a.b).c 禁止使用的场景123456789101112// 构造函数new a?.()new a?.b()// 右侧是模板字符串a?.`${b}`;// 左侧是supersuper?.foo()// 在赋值的左侧a?.b = c; 3.空值合并运算符读取对象属性时，如果这个属性是null或者undefined，有时候需要为它们指定默认值，常见的做法是通过|| 1const a?.b || 'a'; 但||使用运算符会导致只要左侧转换后的布尔值是false，就会执行右侧 而在js中，false &quot;&quot; NaN 0 null undefined等都会被判断为false 为了了避免这种情况，ES2020引入了一个新的null判断运算符??，只有在左侧是null或者undefined时才会返回右侧的值 1const a?.b ?? 'a'; 优先级??本质上是逻辑运算符，与||和&amp;&amp;一起使用时存在优先级问题，必须使用括号来表示哪个优先级更高 1234567891011(lhs &amp;&amp; middle) ?? rhs;lhs &amp;&amp; (middle ?? rhs);(lhs ?? middle) &amp;&amp; rhs;lhs ?? (middle &amp;&amp; rhs);(lhs || middle) ?? rhs;lhs || (middle ?? rhs);(lhs ?? middle) || rhs;lhs ?? (middle || rhs); 4.逻辑赋值运算符ES2021引入了三个逻辑赋值运算符 12345x ||= y // 相当于 x || (x = y)x ??= y // 相当于 x ?? (x = y)x &amp;&amp;= y // 相当于 x &amp;&amp; (x = y) 它们的一个用途是，为变量或属性设置默认值。 12345// 老的写法user.id = user.id || 1;// 新的写法user.id ||= 1; 上面示例中，user.id属性如果不存在，则设为1，新的写法比老的写法更紧凑一些。 下面是另一个例子。 1234function example(opts) { opts.foo = opts.foo ?? 'bar'; opts.baz ?? (opts.baz = 'qux');} 上面示例中，参数对象opts如果不存在属性foo和属性baz，则为这两个属性设置默认值。有了“Null 赋值运算符”以后，就可以统一写成下面这样。 1234function example(opts) { opts.foo ??= 'bar'; opts.baz ??= 'qux';}","link":"/JavaScript/2.%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"原型与原型链","text":"1.prototypeJavaScript中，每一个函数都有一个prototype属性，这个属性是与生俱来的特质，特别强调，是函数，普通对象是没有这个属性的 1234567891011function Person() {}// 虽然写在注释里面，但是需要注意的是// prototype 是函数才会有的属性 （哈哈哈，看来在JavaScript中函数果然是有特权的……）Person.prototype.name = &quot;Kevin&quot;;var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 上面的代码中我们创建了一个构造函数Person，并且在实例原型上面添加了一个name属性赋值为&quot;Kevin&quot;; 然后分别创建了两个实例对象:person1、person2; 当我们打印两个实例对象上name属性时均输出了Kevin(可以亲自试一下)。 我们不禁疑惑，这个Person.prototype到底是什么，为什么在上面添加属性，在 构造函数的实例化对象上都能访问到呢？ 其实 Person这个函数的prototype属性指向了一个对象(即:Person.prototype也是一个对象)。这个对象正是调用该构造函数而创建的实例的原型。也就是这个例子中的person1和person2的原型(即实例化的对象的__proto__属性指向构造函数的原型)。 那么什么是原型呢？即： 每个JavaScript对象(null除外)，在创建的时候都会与之关联另外一个对象，这个对象就是我们所说的原型，并且每一个对象都会从原型继承属性 上面的代码中我们并没有直接在person1和person2中添加name属性 但是这两个对象 却能够访问name属性,就是这个道理。 我们用一张图表示构造函数和实例原型之间的关系: 小结 在JavaScript中，每一个函数都会有一个prototype属性，这个属性指向它的实例原型对象，而每一个对象，在创建的时候，就会关联另一个对象，这个关联的对象，就是我们所说的原型 tips：new关键字的内部执行机制 创建一个空对象 将这个空对象的原型对象指向构造函数的原型 将构造函数的this指向这个空对象并执行 返回这个空对象 手写一个new 123456789function myNew(...newArgs) { const [Fn,...arg] = newAtgs; // 创建一个空对象并将这个对象的原型指向构造函数的实例原型 const obj = Object.create(Fn.prototype); // 将构造函数的this指向空对象并执行构造函数 Fn.apply(obj, arg); // 返回这个对象 return obj;} 2.__proto__每一个JavaScript对象(null除外)，都有一个__proto__属性，作为实例对象和实例原型之间链接的桥梁 这里强调，是对象，同样，因为函数也是对象，所以函数也有这个属性 1234567function Person() {}var person = new Person();console.log(person.__proto__ === Person.prototype); //true; 有了第二个属性的帮助，我们就能更加全面的理解这张关系图了： 通过上面的关系图我们可以看到,构造函数Person 和实例对象person 分别通过 prototype和__proto__ 和实例原型Person.prototype进行关联，根据箭头指向 我们不禁要有疑问：实例原型是否有属性指向构造函数或者实例呢？ 这时候该请出我们的第三个属性了：constructor 3.constructor实例原型指向实例的属性倒是没有,因为一个构造函数可能会生成很多个实例，但是原型指向构造函数的属性倒是有的，这就是我们的constructor——每一个原型都有一个constructor属性指向关联的构造函数。 我们再来看一个示例： 1234function Person() {}console.log(Person === Person.prototype.constructor); // true 好了到这里我们再完善下关系图： 4.实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 我们再举一个例子： 1234567891011121314 function Person() { } Person.prototype.name = 'Kevin'; var person = new Person(); person.name = 'Daisy'; console.log(person.name) // Daisy delete person.name; console.log(person.name) // Kevin复制代码 在上面这个例子中，我们给实例person添加了name 属性，当我们打印person.name的时候，结果自然为Daisy 但是当我们删除了person下面的name属性后，读取person.name，依然能够成功输出Kevin，实际情况是从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是我们不禁有疑问，如果万一没有找到该怎么办？ 我们来看下一层的关系 原型的原型 5.原型与原型链我们前面提到过，原型也是一个对象，那么既然是对象，那肯定有创建它的构造函数，这个构造函数就是Object() 123const obj = new Object()obj.name = 'jiacheng';console.log(obj.name) // jiacheng 其实原型对象就是通过Object构造函数生成的，结合之前我们所说的，实例__proto__指向构造函数的 prototype 所以我们再丰富一下我们的关系图； 到了这里我们对于 构造函数、实例对象、实例原型之间的关系又有了进一步的认识。 说了这么多，终于可以介绍原型链了。 6.原型链那Object.prototype的原型呢？Object是根节点对象，再往上查找就是null 1console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.proto 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 我们可以将null 也加入最后的关系图中，这样就比较完整了。 上图中相互关联的原型组成的链状结构就是原型链，也就是红色的这条线 换句话来说，原型链就是__proto__这个属性连接的路径 7.补充最后，补充三点大家可能不会注意到的地方： constructor首先是constructor，我们看一个例子： 123456function Person() {}var person = new Person();console.log(person.constructor === Person); // true 当获取person.constructor时，其实 person 中并没有constructor 属性,当不能读取到constructor属性时，会从 person 的原型也就是 Person.prototype中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor __proto__其次是 proto ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.proto 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 构造函数的原型指向我们知道构造函数的prototype属性指向它的实例原型，但构造函数同样是通过Function()这个构造函数创建出来的，所以它的__proto__属性指向Function.prototype 1console.log(fn.__proto__ === Function.prototype); // true 同样的Object和Function的__proto__属性也是指向Function.prototype 12console.log(Object.__proto__ === Function.prototype); // trueconsole.log(Function.__proto__ === Function.prototype); // true 8.练习题第一题1234567891011121314151617var F = function() {};Object.prototype.a = function() { console.log('a');};Function.prototype.b = function() { console.log('b');}var f = new F();f.a(); // af.b(); // errorF.a(); // aF.b(); // b 第二题1234567891011121314var A = function() {};A.prototype.n = 1;var b = new A();A.prototype = { n: 2, m: 3}var c = new A();console.log(b.n); // 1console.log(b.m); // undefinedconsole.log(c.n); // 2console.log(c.m); // 3 第三题12345678910var foo = {}, F = function(){};Object.prototype.a = 'value a';Function.prototype.b = 'value b';console.log(foo.a); // value aconsole.log(foo.b); // undefinedconsole.log(F.a); // value aconsole.log(F.b); // value b 第四题12345678910111213141516function A() {}function B(a) { this.a = a; // 有实例属性时，访问会优先调用实例属性，然后调用原型上的属性}function C(a) { if (a) { this.a = a; }}A.prototype.a = 1;B.prototype.a = 1;C.prototype.a = 1;console.log(new A().a); // 1console.log(new B().a); // undefinedconsole.log(new C(2).a); // 2 第五题1console.log(123['toString'].length + 123) // 124","link":"/JavaScript/19.%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"Symbol关键字","text":"1.概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 123let s = Symbol();console.log(s); // 'symbol' 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot; 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。 不能使用new命令注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 1var sym = new Symbol(); // TypeError 这会阻止创建一个显式的 Symbol 包装器对象而不是一个 Symbol 值。围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。 也就是说，Symbol无法被new命令创建是语法故意这么做的，从ES6开始不再支持围绕原始数据类型创建一个显示包装器对象 如果你真的想创建一个 Symbol 包装器对象 (Symbol wrapper object)，你可以使用 Object() 函数 1234var sym = Symbol(&quot;foo&quot;);typeof sym; // &quot;symbol&quot;var symObj = Object(sym);typeof symObj; // &quot;object&quot; Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot; 上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 1234567const obj = { toString() { return 'abc'; }};const sym = Symbol(obj);sym // Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 1234567891011// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false 上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。 Symbol 值不能与其他类型的值进行运算，会报错。 123456let sym = Symbol('My symbol');&quot;your symbol is &quot; + sym// TypeError: can't convert symbol to string`your symbol is ${sym}`// TypeError: can't convert symbol to string 但是，Symbol 值可以显式转为字符串。 1234let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)' 另外，Symbol 值也可以转为布尔值，但是不能转为数值。 12345678910let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) { // ...}Number(sym) // TypeErrorsym + 2 // TypeError 2.Symbol.prototype.description创建 Symbol 的时候，可以添加一个描述。 1const sym = Symbol('foo'); 上面代码中，sym的描述就是字符串foo。 但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。 1234const sym = Symbol('foo');String(sym) // &quot;Symbol(foo)&quot;sym.toString() // &quot;Symbol(foo)&quot; 上面的用法不是很方便。ES2019提供了一个实例属性description，直接返回 Symbol 的描述。 123const sym = Symbol('foo');sym.description // &quot;foo&quot; 3.作为属性名由于每一个Symbol值都不相等，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性，这对于一个对象由多个模块构成的情况非常有用，能防止某一个键不小心改写或覆盖 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = 'Hello!';// 第二种写法let a = { [mySymbol]: 'Hello!'};// 第三种写法let a = {};Object.defineProperty(a, mySymbol, { value: 'Hello!' });// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; 注意：Symbol值作为对象属性名时，不能使用.运算符 123456const mySymbol = Symbol();const a = {};a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // &quot;Hello!&quot; Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。 123456789const log = {};log.levels = { DEBUG: Symbol('debug'), INFO: Symbol('info'), WARN: Symbol('warn')};console.log(log.levels.DEBUG, 'debug message');console.log(log.levels.INFO, 'info message'); 下面是另外一个例子。 12345678910111213const COLOR_RED = Symbol();const COLOR_GREEN = Symbol();function getComplement(color) { switch (color) { case COLOR_RED: return COLOR_GREEN; case COLOR_GREEN: return COLOR_RED; default: throw new Error('Undefined color'); }} 常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。 还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 4.属性名的遍历Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。 但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 1234567891011const obj = {};let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 上面代码是Object.getOwnPropertySymbols()方法的示例，可以获取所有 Symbol 属性名。 下面是另一个例子，Object.getOwnPropertySymbols()方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。 1234567891011const obj = {};const foo = Symbol('foo');obj[foo] = 'bar';for (let i in obj) { console.log(i); // 无输出}Object.getOwnPropertyNames(obj) // []Object.getOwnPropertySymbols(obj) // [Symbol(foo)] 上面代码中，使用for...in循环和Object.getOwnPropertyNames()方法都得不到 Symbol 键名，需要使用Object.getOwnPropertySymbols()方法。 另一个新的 API，Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = { [Symbol('my_key')]: 1, enum: 2, nonEnum: 3};Reflect.ownKeys(obj)// [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] 5.Symbol.for()和Symbol.keyFor()Symbol.for()方法接受同一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值，然后搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建一个以该字符串为名称的Symbol值，并将其注册到全局 1234let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。 12345let s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;let s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined 上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。 注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。 6.理解Symbol这个数据类型引入的原本目的是防止对象的属性名命名冲突。因为对象的属性名只能是字符串，所以有可能命名冲突 Symbol的值由Symbol函数进行生成，对象的属性原本只能是字符串，现在可以是Symbol类型，表示独一无二 123456789let name = Symbol();console.log(name);let obj = { [name]: 'jiacheng'} 创建Symbol变量时可以传入一个描述，如果要读取这个描述，可以使用ES2019新增的实例方法Symbol.prototype.description 12345let foo = Symbol('foo');console.log(foo.description);console.log(foo.toString()); 如果一个对象中有Symbol类型的属性名，那么它在遍历时不会出现在for...in Object.key Object.getOwnPropertyName()JSON.stringify()中 可以通过Object.getOwnPropertySymbols()获取对象中所有的Symbol对象或者使用Reflect.ownKeys()","link":"/JavaScript/20.Symbol/"},{"title":"数组的扩展","text":"1.扩展运算符扩展运算符(spread)是三个点(…)。它好比rest参数的逆运算，将一个数组用逗号分隔的参数序列 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 替代apply方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 12345678910111213// ES5 的写法function f(x, y, z) { // ...}var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) { // ...}let args = [0, 1, 2];f(...args); 扩展运算符的应用（1）复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 12345const a1 = [1, 2];const a2 = a1;a2[0] = 2;a1 // [2, 2] 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。 ES5 只能用变通方法来复制数组。 12345const a1 = [1, 2];const a2 = a1.concat();a2[0] = 2;a1 // [1, 2] 上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。 扩展运算符提供了复制数组的简便写法。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 上面的两种写法，a2都是a1的克隆。 （2）合并数组 扩展运算符提供了数组合并的新写法。 1234567891011const arr1 = ['a', 'b'];const arr2 = ['c'];const arr3 = ['d', 'e'];// ES5 的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。 12345678const a1 = [{ foo: 1 }];const a2 = [{ bar: 2 }];const a3 = a1.concat(a2);const a4 = [...a1, ...a2];a3[0] === a1[0] // truea4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。 （3）与解构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 下面是另外一些例子。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 12[...'hello']// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。 12'x\\uD83D\\uDE80y'.length // 4[...'x\\uD83D\\uDE80y'].length // 3 上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。 12345function length(str) { return [...str].length;}length('x\\uD83D\\uDE80y') // 3 凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。 1234567let str = 'x\\uD83D\\uDE80y';str.split('').reverse().join('')// 'y\\uDE80\\uD83Dx'[...str].reverse().join('')// 'y\\uD83D\\uDE80x' 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 （5）实现了 Iterator 接口的对象 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 12let nodeList = document.querySelectorAll('div');let array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。 123456789Number.prototype[Symbol.iterator] = function*() { let i = 0; let num = this.valueOf(); while (i &lt; num) { yield i++; }}console.log([...5]) // [0, 1, 2, 3, 4] 上面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 123456789let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3};// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map 和 Set 结构，Generator 函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567const go = function*(){ yield 1; yield 2; yield 3;};[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。 12const obj = {a: 1, b: 2};let arr = [...obj]; // TypeError: Cannot spread non-iterable object 2.Array.from()Array.from()方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3};// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; { return p.textContent.length &gt; 100;});// arguments对象function foo() { var args = Array.from(arguments); // ...} 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() { const args = [...arguments];}// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from({ length: 3 });// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); 3.Array.of()Array.of()方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 Array.of()总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of()方法可以用下面的代码模拟实现。 123function ArrayOf(){ return [].slice.call(arguments);} 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array()方法没有参数、一个参数、三个参数时，返回的结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。 Array.of()基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 4.数组实例copyWithin()数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。 下面是更多例子。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call({length: 5, 3: 1}, 0, 3)// {0: 1, 3: 1, length: 5}// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 5.数组实例find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于 0 的成员。 123[1, 5, 10, 15].find(function(value, index, arr) { return value &gt; 9;}) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) { return value &gt; 9;}) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v){ return v &gt; this.age;}let person = {name: 'John', age: 20};[10, 12, 26, 15].find(f, person); // 26 上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。 另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 6.数组实例fill()fill方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 123456789let arr = new Array(3).fill({name: &quot;Mike&quot;});arr[0].name = &quot;Ben&quot;;arr// [{name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 7.数组实例entries()，keys()和values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 12345678910111213141516for (let index of ['a', 'b'].keys()) { console.log(index);}// 0// 1for (let elem of ['a', 'b'].values()) { console.log(elem);}// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem);}// [0, 'a']// [1, 'b'] 8.数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 123if (arr.indexOf(el) !== -1) { // ...} indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。 12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 9.数组实例的 flat()，flatMap()数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] 上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置。 flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] 上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 12[1, [2, [3]]].flat(Infinity)// [1, 2, 3] 如果原数组有空位，flat()方法会跳过空位。 12[1, 2, , 4, 5].flat()// [1, 2, 4, 5] flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组。 123// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])// [[2], [4], [6], [8]] 上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个嵌套数组。 flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。 123arr.flatMap(function callback(currentValue[, index[, array]]) { // ...}[, thisArg]) flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。 10.数组的空位ES6明确规定将空位转为undefined Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 12Array.from(['a',,'b'])// [ &quot;a&quot;, undefined, &quot;b&quot; ] 扩展运算符（...）也会将空位转为undefined。 12[...['a',,'b']]// [ &quot;a&quot;, undefined, &quot;b&quot; ] copyWithin()会连空位一起拷贝。 1[,'a','b',,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;] fill()会将空位视为正常的数组位置。 1new Array(3).fill('a') // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;] for...of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) { console.log(1);}// 1// 1 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 11.Array.prototype.sort() 的排序稳定性排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。 1234567891011121314const arr = [ 'peach', 'straw', 'apple', 'spork'];const stableSorting = (s1, s2) =&gt; { if (s1[0] &lt; s2[0]) return -1; return 1;};arr.sort(stableSorting)// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;] 上面代码对数组arr按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法stableSorting是稳定排序。 1234567const unstableSorting = (s1, s2) =&gt; { if (s1[0] &lt;= s2[0]) return -1; return 1;};arr.sort(unstableSorting)// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;] 上面代码中，排序结果是spork在straw前面，跟原始顺序相反，所以排序算法unstableSorting是不稳定的。 常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。 早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。","link":"/JavaScript/17.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"对象的扩展","text":"1.属性的简洁表示法ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法 1234567const foo = 'bar';const baz = {foo};baz // {foo: &quot;bar&quot;}// 等同于const baz = {foo: foo}; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。 1234567891011121314const cart = { _wheels: 4, get wheels () { return this._wheels; }, set wheels (value) { if (value &lt; this._wheels) { throw new Error('数值太小了！'); } this._wheels = value; }} 2.属性表达式JavaScript 定义对象的属性，有两种方法。 12345// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。 1234var obj = { foo: true, abc: 123}; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 123456let propKey = 'foo';let obj = { [propKey]: true, ['a' + 'bc']: 123}; 3.属性的可枚举性和遍历对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj = { foo: 123 };Object.getOwnPropertyDescriptor(obj, 'foo')// {// value: 123,// writable: true,// enumerable: true,// configurable: true// } 目前，有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。 12345Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable// falseObject.getOwnPropertyDescriptor([], 'length').enumerable// false 上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。 12Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable// false 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。 可以通过Object.defineProperty()来创建对象属性的描述 1234Object.defineProperty({}, 'invisible', { enumerable: false, value: 'hello'}) 4.属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 （1）for…in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 12Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 5.Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 1234Object.is('foo', 'foo')// trueObject.is({}, {})// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true 6.Object.assign()Object.assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567const target = { a: 1 };const source1 = { b: 2 };const source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3} Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1234567const target = { a: 1, b: 1 };const source1 = { b: 2, c: 2 };const source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3} 7.Object.getOwnPropertyDescriptors()ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。 12345678910111213141516const obj = { foo: 123, get bar() { return 'abc' }};Object.getOwnPropertyDescriptors(obj)// { foo:// { value: 123,// writable: true,// enumerable: true,// configurable: true },// bar:// { get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true } } 8.__proto__，Object.setPrototypeOf()，Object.getPrototypeOf()__proto__属性__proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。 123456789// es5 的写法const obj = { method: function() { ... }};obj.__proto__ = someOtherObj;// es6 的写法var obj = Object.create(someOtherObj);obj.method = function() { ... }; 该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 Object.setPrototypeOf()Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 12345// 格式Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf({}, null); 该方法等同于下面的函数。 1234function setPrototypeOf(obj, proto) { obj.__proto__ = proto; return obj;} 下面是一个例子。 12345678910let proto = {};let obj = { x: 10 };Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。 123Object.setPrototypeOf(1, {}) === 1 // trueObject.setPrototypeOf('foo', {}) === 'foo' // trueObject.setPrototypeOf(true, {}) === true // true 由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。 12345Object.setPrototypeOf(undefined, {})// TypeError: Object.setPrototypeOf called on null or undefinedObject.setPrototypeOf(null, {})// TypeError: Object.setPrototypeOf called on null or undefined Object.getPrototypeOf()该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。 1Object.getPrototypeOf(obj); 下面是一个例子。 123456789101112function Rectangle() { // ...}const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false 9.Object.keys()，Object.values()，Object.entries()ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 123var obj = { foo: 'bar', baz: 42 };Object.keys(obj)// [&quot;foo&quot;, &quot;baz&quot;] ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。 1234567891011121314let {keys, values, entries} = Object;let obj = { a: 1, b: 2, c: 3 };for (let key of keys(obj)) { console.log(key); // 'a', 'b', 'c'}for (let value of values(obj)) { console.log(value); // 1, 2, 3}for (let [key, value] of entries(obj)) { console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]} 10.Object.fromEntries()Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。 12345Object.fromEntries([ ['foo', 'bar'], ['baz', 42]])// { foo: &quot;bar&quot;, baz: 42 } 该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。 12345678910111213// 例一const entries = new Map([ ['foo', 'bar'], ['baz', 42]]);Object.fromEntries(entries)// { foo: &quot;bar&quot;, baz: 42 }// 例二const map = new Map().set('foo', true).set('bar', false);Object.fromEntries(map)// { foo: true, bar: false } 该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象。 12Object.fromEntries(new URLSearchParams('foo=bar&amp;baz=qux'))// { foo: &quot;bar&quot;, baz: &quot;qux&quot; }","link":"/JavaScript/18.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"函数柯里化","text":"柯里化说柯里化之前，首先抛出一个疑问，如何实现一个add函数，使得这个add函数可以灵活调用和传参，支持下面的调用示例呢？ 123456add(1, 2, 3) // 6add(1) // 1add(1)(2) // 3add(1, 2)(3) // 6add(1)(2)(3) // 6add(1)(2)(3)(4) // 10 要解答这样的疑问，还是要先明白什么是柯里化。 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 这段解释看着还是挺懵逼的，不如举个例子： 本来有这么一个求和函数dynamicAdd()，接受任意个参数。 12345function dynamicAdd() { return [...arguments].reduce((prev, curr) =&gt; { return prev + curr }, 0)} 现在需要通过柯里化把它变成一个新的函数，这个新的函数预置了第一个参数，并且可以在调用时继续传入剩余参数。 看到这，我觉得有点似曾相识，预置参数的特性与bind很相像。那么我们不如用bind的思路来实现。 123456789function curry(fn, firstArg) { // 返回一个新函数 return function() { // 新函数调用时会继续传参 var restArgs = [].slice.call(arguments) // 参数合并，通过apply调用原函数 return fn.apply(this, [firstArg, ...restArgs]) }} 接着我们通过一些例子来感受一下柯里化。 123456789// 柯里化，预置参数10var add10 = curry(dynamicAdd, 10)add10(5); // 15// 柯里化，预置参数20var add20 = curry(dynamicAdd, 20);add20(5); // 25// 也可以对一个已经柯里化的函数add10继续柯里化，此时预置参数10即可var anotherAdd20 = curry(add10, 10);anotherAdd20(5); // 25 可以发现，柯里化是在一个函数的基础上进行变换，得到一个新的预置了参数的函数。最后在调用新函数时，实际上还是会调用柯里化前的原函数。 并且柯里化得到的新函数可以继续被柯里化，这看起来有点像俄罗斯套娃的感觉。 实际使用时也会出现柯里化的变体，不局限于只预置一个参数。 1234567891011function curry(fn) { // 保存预置参数 var presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 return function() { // 新函数调用时会继续传参 var restArgs = [].slice.call(arguments) // 参数合并，通过apply调用原函数 return fn.apply(this, [...presetArgs, ...restArgs]) }} 其实Function.protoype.bind就是一个柯里化的实现。不仅如此，很多流行的库都大量使用了柯里化的思想。 实际应用中，被柯里化的原函数的参数可能是定长的，也可能是不定长的。 参数定长的柯里化假设存在一个原函数fn，fn接受三个参数a, b, c，那么函数fn最多被柯里化三次（有效地绑定参数算一次）。 1234567891011function fn(a, b, c) { return a + b + c}var c1 = curry(fn, 1);var c2 = curry(c1, 2);var c3 = curry(c2, 3);c3(); // 6// 再次柯里化也没有意义，原函数只需要三个参数var c4 = curry(c3, 4);c4();复制代码 也就是说，我们可以通过柯里化缓存的参数数量，来判断是否到达了执行时机。那么我们就得到了一个柯里化的通用模式。 12345678910111213141516171819function curry(fn) { // 获取原函数的参数长度 const argLen = fn.length; // 保存预置参数 const presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 return function() { // 新函数调用时会继续传参 const restArgs = [].slice.call(arguments) const allArgs = [...presetArgs, ...restArgs] if (allArgs.length &gt;= argLen) { // 如果参数够了，就执行原函数 return fn.apply(this, allArgs) } else { // 否则继续柯里化 return curry.call(null, fn, ...allArgs) } }} 这样一来，我们的写法就可以支持以下形式。 123456789function fn(a, b, c) { return a + b + c;}var curried = curry(fn);curried(1, 2, 3); // 6curried(1, 2)(3); // 6curried(1)(2, 3); // 6curried(1)(2)(3); // 6curried(7)(8)(9); // 24 参数不定长的柯里化解决了上面的问题，我们难免会问自己，假设原函数的参数不定长呢，这种情况如何柯里化？ 首先，我们需要理解参数不定长是指函数声明时不约定具体的参数，而在函数体中通过arguments获取实参，然后进行运算。就像下面这种。 123456function dynamicAdd() { return [...arguments].reduce((prev, curr) =&gt; { return prev + curr }, 0)}复制代码 回到最开始的问题，怎么支持下面的所有调用形式？ 1234567add(1, 2, 3) // 6add(1) // 1add(1)(2) // 3add(1, 2)(3) // 6add(1)(2)(3) // 6add(1)(2)(3)(4) // 10复制代码 思考了一阵，我发现在参数不定长的情况下，要同时支持1~N次调用还是挺难的。add(1)在一次调用后可以直接返回一个值，但它也可以作为函数接着调用add(1)(2)，甚至可以继续add(1)(2)(3)。那么我们实现add函数时，到底是返回一个函数，还是返回一个值呢？这让人挺犯难的，我也不能预测这个函数将如何被调用啊。 而且我们可以拿上面的成果来验证下： 12curried(1)(2)(3)(4);复制代码 运行上面的代码会报错：Uncaught TypeError: curried(…)(…)(…) is not a function，因为执行到curried(1)(2)(3)，结果就不是一个函数了，而是一个值，一个值当然是不能作为函数继续执行的。 所以如果要支持参数不定长的场景，已经柯里化的函数在执行完毕时不能返回一个值，只能返回一个函数；同时要让JS引擎在解析得到的这个结果时，能求出我们预期的值。 大家看了这个可能还是不懂，好，说人话！我们实现的curry应该满足： 经curry处理，得到一个新函数，这一点不变。 123// curry是一个函数var curried = curry(add);复制代码 新函数执行后仍然返回一个结果函数。 123// curried10也是一个函数var curried10 = curried(10);var curried30 = curried10(20); 结果函数可以被Javascript引擎解析，得到一个预期的值。 1curried10; // 10 好，关键点在于3，如何让Javascript引擎按我们的预期进行解析，这就回到Javascript基础了。在解析一个函数的原始值时，会用到toString。 我们知道，console.log(fn)可以把函数fn的源码输出，如下所示： 1234console.log(fn)ƒ fn(a, b, c) { return a + b + c;} 那么我们只要重写toString，就可以巧妙地实现我们的需求了。 12345678910111213141516function curry(fn) { // 保存预置参数 const presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 function curried () { // 新函数调用时会继续传参 const restArgs = [].slice.call(arguments) const allArgs = [...presetArgs, ...restArgs] return curry.call(null, fn, ...allArgs) } // 重写toString curried.toString = function() { return fn.apply(null, presetArgs) } return curried;} 这样一来，魔性的add用法就都被支持了。 12345678function dynamicAdd() { return [...arguments].reduce((prev, curr) =&gt; { return prev + curr }, 0)}var add = curry(dynamicAdd);add(1)(2)(3)(4) // 10add(1, 2)(3, 4)(5, 6) // 21 柯里化总结柯里化是一种函数式编程思想，实际上在项目中可能用得少，或者说用得不深入，但是如果你掌握了这种思想，也许在未来的某个时间点，你会用得上！ 大概来说，柯里化有如下特点： 简洁代码：柯里化应用在较复杂的场景中，有简洁代码，可读性高的优点。 参数复用：公共的参数已经通过柯里化预置了。 延迟执行：柯里化时只是返回一个预置参数的新函数，并没有立刻执行，实际上在满足条件后才会执行。 管道式流水线编程：利于使用函数组装管道式的流水线工序，不污染原函数。","link":"/JavaScript/15.%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"title":"闭包","text":"1.作用域 在JavaScript中，变量的可访问性由作用域管理。作用域由函数或代码块创建。变量只能在定义它的函数或代码块内使用。超出范围则不可访问 变量隔离 我们可以把作用域理解为一种空间策略，每个函数拥有自己的私有作用域，它对变量进行了隔离，控制了变量的可访问性，因此不同的作用域可以具有相同名称的变量而不冲突。 作用域嵌套 我们可以把innerFunc()嵌套在外部函数outerFunc()中，外部作用域中的outerVar变量在内部作用域中是可访问的。 小结 作用域可以嵌套 外部作用域的变量可以在内部作用域内部访问 如果外部作用域中也找不到，最终会去全局作用域中查找，从内至外层层查找形成作用域链 扩展： 我们把内部作用域可以访问到外部作用域，而外部无法访问内部的行为叫做作用域继承，可以把全局作用域比喻成一个大房子，里面有很多层小房间（函数作用域或者块作用域），各自拥有自己的钥匙🔑。可以从里面访问外面，但是无法从外面访问里面，并且相互之间无法访问 2.闭包示例： 1234567891011function outerFunc() { let outerVar = 'I am outside!'; function innerFunc() { console.log(outerVar); // &quot;I am outside!&quot; } innerFunc();}outerFunc(); 现在我们知道在innerFunc()作用域内可以从词法作用域访问变量outerVar，这里innerFunc()调用发生在其词法作用域（outerFunc()的作用域）内。 把innerFunc()修改到其词法作用域之外（outerFunc()之外）调用。innerFunc()还能访问outerVar吗？ 让我们对代码片段进行调整： 123456789101112function outerFunc() { let outerVar = 'I am outside!'; function innerFunc() { console.log(outerVar); // &quot;I am outside!&quot; } return innerFunc;}const myInnerFunc = outerFunc();myInnerFunc(); 现在innerFunc()在其词法作用域之外执行，但是innerFunc()仍然可以从其词法作用域访问outerVar，即使是在词法作用域之外执行。也就是说innerFunc()从其词法作用域捕获(又称记忆）变量outerVar。 换句话说，innerFunc()是一个闭包，因为它在词法作用域内捕获了变量outerVar。 正常来说，当outerFunc函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却很神奇的将outerFunc的作用域存活了下来，innerFunc依然持有该作用域的引用，这个引用就是闭包。 闭包是一个函数，它从定义它的地方记住变量，形成一个私有的作用域，保护里边的私有变量不受外界的干扰，除了保护私有变量外，还可以存储一些内容，而不管它以后在哪里执行，所以无论通过哪种方式将内部的函数传递到所在的词法作用域以外，它都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。 小结某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数极限访问定义时的词法作用域。 扩展：通俗地讲闭包就是在一个函数里边再定义一个函数。这个内部函数一直保持有对外部函数中作用域的访问权限(小房间一直可以有大房子的访问权限)。 3.闭包的作用 访问其他函数内部变量 保护变量不被内存回收机制回收 避免全局变量被污染 方便调用上下文的局部变量 加强封装性 4.总结作用域决定了JavaScript中变量的可访问性。主要包括函数作用域和块作用域。 词法作用域允许函数作用域从外部作用域静态访问变量。 最后，闭包是从其词法作用域捕获变量的函数。用简单的话来说，闭包会记住从定义它的地方开始的变量，无论它在哪里执行。 闭包捕获事件处理程序，回调中的变量。它们用于函数式编程。","link":"/JavaScript/16.%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AD%E5%8C%85/"},{"title":"函数的扩展","text":"1.参数默认值ES6允许为函数的参数设置默认值，直接写在参数定义的后面 1234567function log(x, y = 'World') { console.log(x, y);}log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 这种写法比ES5简洁了很多，而且可以让阅读代码的人可以立刻意识到哪些参数是可以省略的，提高了代码的可维护性 注意：参数变量是默认声明的，所以不能在函数作用域中使用let或const再次声明 1234function foo(x = 5) { let x = 1; // error const x = 2; // error} 使用参数默认值时，函数不能有同名参数 12345678910// 不报错function foo(x, x, y) { // ...}// 报错function foo(x, x, y = 1) { // ...}// SyntaxError: Duplicate parameter name not allowed in this context 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x = 99;function foo(p = x + 1) { console.log(p);}foo() // 100x = 100;foo() // 101 上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。 与解构赋值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。 12345678function foo({x, y = 5}) { console.log(x, y);}foo({}) // undefined 5foo({x: 1}) // 1 5foo({x: 1, y: 2}) // 1 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 12345function foo({x, y = 5} = {}) { console.log(x, y);}foo() // undefined 5 上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。 下面是另一个解构赋值默认值的例子。 123456789function fetch(url, { body = '', method = 'GET', headers = {} }) { console.log(method);}fetch('http://example.com', {})// &quot;GET&quot;fetch('http://example.com')// 报错 上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。 123456function fetch(url, { body = '', method = 'GET', headers = {} } = {}) { console.log(method);}fetch('http://example.com')// &quot;GET&quot; 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) { return [x, y];}f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) { return [x, y, z];}f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 123456function foo(x = 5, y = 6) { console.log(x, y);}foo(undefined, null)// 5 null 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。 2.作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567var x = 1;function f(x, y = x) { console.log(y);}f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 再看下面的例子。 12345678let x = 1;function f(y = x) { let x = 2; console.log(y);}f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 123456function f(y = x) { let x = 2; console.log(y);}f() // ReferenceError: x is not defined 下面这样写，也会报错。 1234567var x = 1;function foo(x = x) { // ...}foo() // ReferenceError: Cannot access 'x' before initialization 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错。 3.rest参数ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567function fn(x,...args){ for(const item of args) { console.log(item) }}fn(1,2,3,4) // 2, 3, 4 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.from先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。 注意：如果指定了rest参数，那么它后面就不能跟其他的参数，否则会报错 4.严格模式从 ES5 开始，函数内部可以设定为严格模式。 1234function doSomething(a, b) { 'use strict'; // code} ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) { 'use strict'; // code}// 报错const doSomething = function ({a, b}) { 'use strict'; // code};// 报错const doSomething = (...a) =&gt; { 'use strict'; // code};const obj = { // 报错 doSomething({a, b}) { 'use strict'; // code }}; 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 12345// 报错function doSomething(value = 070) { 'use strict'; return value;} 5.name属性函数的name属性，返回该函数的函数名 函数的name属性，返回该函数的函数名。 12function foo() {}foo.name // &quot;foo&quot; 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。 1234567var f = function () {};// ES5f.name // &quot;&quot;// ES6f.name // &quot;f&quot; 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。 1234567const bar = function baz() {};// ES5bar.name // &quot;baz&quot;// ES6bar.name // &quot;baz&quot; Function构造函数返回的函数实例，name属性的值为anonymous。 1(new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀。 1234function foo() {};foo.bind({}).name // &quot;bound foo&quot;(function(){}).bind({}).name // &quot;bound &quot; 6.箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function (v) { return v;}; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () { return 5 };var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) { return num1 + num2;}; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; { return num1 + num2; } 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; };// 不报错let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; }); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。 12let foo = () =&gt; { a: 1 };foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 1let fn = () =&gt; void doesNotReturn(); 箭头函数可以与变量解构结合使用。 123456const full = ({ first, last }) =&gt; first + ' ' + last;// 等同于function full(person) { return person.first + ' ' + person.last;} 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 === 0;const square = n =&gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。 箭头函数的一个用处是简化回调函数。 1234567// 普通函数写法[1,2,3].map(function (x) { return x * x;});// 箭头函数写法[1,2,3].map(x =&gt; x * x); 另一个例子是 1234567// 普通函数写法var result = values.sort(function (a, b) { return a - b;});// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是 rest 参数与箭头函数结合的例子。 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 注意点 箭头函数没有自己的this对象 不可以当作构造函数 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 最重要的一点，普通函数this是指向函数运行时所在的对象，而箭头函数没有自己的this，内部的this就是定义时上层作用域的this，也就是说，箭头函数内部的this指向是固定的，相比之下，普通函数的this指向是可变的。 12345678910function foo() { setTimeout(() =&gt; { console.log('id:', this.id); }, 100);}var id = 21;foo.call({ id: 42 });// id: 42 上面代码中，setTimeout()的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以打印出来的是42。 下面例子是回调函数分别为箭头函数和普通函数，对比它们内部的this指向。 1234567891011121314151617function Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () { this.s2++; }, 1000);}var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数实际上可以让this指向固定化，绑定this使得它不再可变，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。 123456789101112var handler = { id: '123456', init: function() { document.addEventListener('click', event =&gt; this.doSomething(event.type), false); }, doSomething: function(type) { console.log('Handling ' + type + ' for ' + this.id); }}; 上面代码的init()方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。如果回调函数是普通函数，那么运行this.doSomething()这一行会报错，因为此时this指向document对象。 总之，箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 下面是 Babel 转箭头函数产生的 ES5 代码，就能清楚地说明this的指向。 123456789101112131415// ES6function foo() { setTimeout(() =&gt; { console.log('id:', this.id); }, 100);}// ES5function foo() { var _this = this; setTimeout(function () { console.log('id:', _this.id); }, 100);} 上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中，this的指向有几个？ 123456789101112131415function foo() { return () =&gt; { return () =&gt; { return () =&gt; { console.log('id:', this.id); }; }; };}var f = foo.call({id: 1});var t1 = f.call({id: 2})()(); // id: 1var t2 = f().call({id: 3})(); // id: 1var t3 = f()().call({id: 4}); // id: 1 答案是this的指向只有一个，就是函数foo的this，这是因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。所以不管怎么嵌套，t1、t2、t3都输出同样的结果。如果这个例子的所有内层函数都写成普通函数，那么每个函数的this都指向运行时所在的不同对象。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() { setTimeout(() =&gt; { console.log('args:', arguments); }, 100);}foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() { return [ (() =&gt; this.x).bind({ x: 'inner' })() ];}).call({ x: 'outer' });// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 7.尾调用优化什么是尾调用尾调用，是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数 123function f(x){ return g(x);} 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 123456789101112131415// 情况一function f(x){ let y = g(x); return y;}// 情况二function f(x){ return g(x) + 1;}// 情况三function f(x){ g(x);} 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。 1234function f(x){ g(x); return undefined;} 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) { if (x &gt; 0) { return m(x) } return n(x);} 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() { let m = 1; let n = 2; return g(m + n);}f();// 等同于function f() { return g(3);}f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a){ var one = 1; function inner(b){ return b + one; } return inner(a);} 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1);}factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5, 1) // 120 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。 非尾递归的 Fibonacci 数列实现如下。 123456789function Fibonacci (n) { if ( n &lt;= 1 ) {return 1}; return Fibonacci(n - 1) + Fibonacci(n - 2);}Fibonacci(10) // 89Fibonacci(100) // 超时Fibonacci(500) // 超时 尾递归优化过的 Fibonacci 数列实现如下。 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) { if( n &lt;= 1 ) {return ac2}; return Fibonacci2 (n - 1, ac2, ac1 + ac2);}Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 12345678910function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}function factorial(n) { return tailFactorial(n, 1);}factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 1234567891011121314function currying(fn, n) { return function (m) { return fn.call(this, m, n); };}function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。 第二种方法就简单多了，就是采用 ES6 的函数默认值。 123456function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5) // 120 上面代码中，参数total有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 8.Function.prototype.toString()ES2019 对函数实例的toString()方法做出了修改。 toString()方法返回函数代码本身，以前会省略注释和空格。 1234function /* foo comment */ foo () {}foo.toString()// function foo() {} 上面代码中，函数foo的原始代码包含注释，函数名foo和圆括号之间有空格，但是toString()方法都把它们省略了。 修改后的toString()方法，明确要求返回一模一样的原始代码。 1234function /* foo comment */ foo () {}foo.toString()// &quot;function /* foo comment */ foo () {}&quot; 9.catch 命令的参数省略JavaScript 语言的try...catch结构，以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象。 12345try { // ...} catch (err) { // 处理错误} 上面代码中，catch命令后面带有参数err。 很多时候，catch代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。ES2019 做出了改变，允许catch语句省略参数。 12345try { // ...} catch { // ...}","link":"/JavaScript/14.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"字符串新增语法","text":"1.字符的Unicode表示法(了解)ES6增强了对Unicode的支持，允许采用\\uxxxx形式表示一个字符 上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1234567891011&quot;\\u{20BB7}&quot;// &quot;𠮷&quot;&quot;\\u{41}\\u{42}\\u{43}&quot;// &quot;ABC&quot;let hello = 123;hell\\u{6F} // 123'\\u{1F680}' === '\\uD83D\\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 12345'\\z' === 'z' // true'\\172' === 'z' // true'\\x7A' === 'z' // true'\\u007A' === 'z' // true'\\u{7A}' === 'z' // true 2.字符串遍历接口ES6为字符串添加了遍历接口(Iterator)，使得字符串可以被for...of循环遍历，也可以被数组形式的解构识别 12345678910111213const str = 'hello';const [a, b, c, d, e] = 'hello';for (const i of str) { console.log(i); // h e l l o}console.log(a); // hconsole.log(b); // econsole.log(c); // lconsole.log(d); // lconsole.log(e); // o 3.JSON.stringify()的改造根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。 具体来说，UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。比如，\\uD834\\uDF06是两个码点，但是必须放在一起配对使用，代表字符𝌆。这是为了表示码点大于0xFFFF的字符的一种变通方法。单独使用\\uD834和\\uDF06这两个码点是不合法的，或者颠倒顺序也不行，因为\\uDF06\\uD834并没有对应的字符。 JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。 1JSON.stringify('\\u{D834}') // &quot;\\u{D834}&quot; 为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。 12JSON.stringify('\\u{D834}') // &quot;&quot;\\\\uD834&quot;&quot;JSON.stringify('\\uDF06\\uD834') // &quot;&quot;\\\\udf06\\\\ud834&quot;&quot; 4.模板字符串模板字符串，是增强版的字符串，用反引号(`)标识，它可以当作普通字符串使用，页可以用来定义多行字符串，或者在字符串中嵌入变量 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello ${name}, how are you ${time}?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\\`Yo\\` World!`; 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789101112function authorize(user, action) { if (!user.hasPrivilege(action)) { throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User ${user.name} is not authorized to do ${action}.`); }} 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。 12`Hello ${'World'}`// &quot;Hello World&quot; 模板字符串甚至还能嵌套。 12345678const tmpl = addrs =&gt; ` &lt;table&gt; ${addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt; `).join('')} &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 123456789101112131415const data = [ { first: '&lt;Jane&gt;', last: 'Bond' }, { first: 'Lars', last: '&lt;Croft&gt;' },];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以写成函数。 12let func = (name) =&gt; `Hello ${name}!`;func('Jack') // &quot;Hello Jack!&quot; 上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。 5.字符串的新增方法String.fromCodePoint()ES6提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符并返回对应的字符串 1234String.fromCodePoint(0x20BB7)// &quot;𠮷&quot;String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'// true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 String.raw()ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。 12345String.raw`Hi\\n${2+3}!`// 实际返回 &quot;Hi\\\\n5!&quot;，显示的是转义后的结果 &quot;Hi\\n5!&quot;String.raw`Hi\\u000A!`;// 实际返回 &quot;Hi\\\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\\u000A!&quot; 如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。 1234String.raw`Hi\\\\n`// 返回 &quot;Hi\\\\\\\\n&quot;String.raw`Hi\\\\n` === &quot;Hi\\\\\\\\n&quot; // true String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。 123// `foo${1 + 2}bar`// 等同于String.raw({ raw: ['foo', 'bar'] }, 1 + 2) // &quot;foo3bar&quot; 上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。 作为函数，String.raw()的代码实现基本如下。 12345678910String.raw = function (strings, ...values) { let output = ''; let index; for (index = 0; index &lt; values.length; index++) { output += strings.raw[index] + values[index]; } output += strings.raw[index] return output;} 实例方法：codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 1234567var s = &quot;𠮷&quot;;s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。 ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。 总之，codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。 codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。 1234let s = '𠮷a';s.codePointAt(0).toString(16) // &quot;20bb7&quot;s.codePointAt(2).toString(16) // &quot;61&quot; 你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。 123456let s = '𠮷a';for (let ch of s) { console.log(ch.codePointAt(0).toString(16));}// 20bb7// 61 另一种方法也可以，使用扩展运算符（...）进行展开运算。 123456let arr = [...'𠮷a']; // arr.length === 2arr.forEach( ch =&gt; console.log(ch.codePointAt(0).toString(16)));// 20bb7// 61 codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 123function is32Bit(c) { return c.codePointAt(0) &gt; 0xFFFF;} 实例方法：normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。 1234'\\u01D1'==='\\u004F\\u030C' //false'\\u01D1'.length // 1'\\u004F\\u030C'.length // 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12'\\u004F\\u030C'.normalize('NFC').length // 1'\\u004F\\u030C'.normalize('NFD').length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 实例方法：includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 **includes()**：返回布尔值，表示是否找到了参数字符串。 **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。 **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 实例方法：repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3) // &quot;xxx&quot;'hello'.repeat(2) // &quot;hellohello&quot;'na'.repeat(0) // &quot;&quot; 参数如果是小数，会被取整。 1'na'.repeat(2.9) // &quot;nana&quot; 如果repeat的参数是负数或者Infinity，会报错。 1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。 1'na'.repeat(-0.9) // &quot;&quot; 参数NaN等同于 0。 1'na'.repeat(NaN) // &quot;&quot; 如果repeat的参数是字符串，则会先转换成数字。 12'na'.repeat('na') // &quot;&quot;'na'.repeat('3') // &quot;nanana&quot; 实例方法：padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 12'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 123'1'.padStart(10, '0') // &quot;0000000001&quot;'12'.padStart(10, '0') // &quot;0000000012&quot;'123456'.padStart(10, '0') // &quot;0000123456&quot; 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // &quot;YYYY-MM-12&quot;'09-12'.padStart(10, 'YYYY-MM-DD') // &quot;YYYY-09-12&quot; 实例方法：trimStart()，trimEnd()ES2019对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 12345const s = ' abc ';s.trim() // &quot;abc&quot;s.trimStart() // &quot;abc &quot;s.trimEnd() // &quot; abc&quot; 上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。 浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名 实例方法：matchAll()matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。 实例方法：replaceAll()历史上，字符串的实例方法replace()只能替换第一个匹配。 12'aabbcc'.replace('b', '_')// 'aa_bcc' 上面例子中，replace()只将第一个b替换成了下划线。 如果要替换所有的匹配，不得不使用正则表达式的g修饰符。 12'aabbcc'.replace(/b/g, '_')// 'aa__cc' 正则表达式毕竟不是那么方便和直观，ES2021 引入了replaceAll()方法，可以一次性替换所有匹配。 12'aabbcc'.replaceAll('b', '_')// 'aa__cc' 它的用法与replace()相同，返回一个新字符串，不会改变原字符串。 1String.prototype.replaceAll(searchValue, replacement) 上面代码中，searchValue是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有g修饰符）。 如果searchValue是一个不带有g修饰符的正则表达式，replaceAll()会报错。这一点跟replace()不同。 12345// 不报错'aabbcc'.replace(/b/, '_')// 报错'aabbcc'.replaceAll(/b/, '_') 上面例子中，/b/不带有g修饰符，会导致replaceAll()报错。 replaceAll()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。 $&amp;：匹配的字符串。 $ `：匹配结果前面的文本。 $'：匹配结果后面的文本。 $n：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。 $$：指代美元符号$。 下面是一些例子。 12345678910111213141516171819202122232425// $&amp; 表示匹配的字符串，即`b`本身// 所以返回结果与原字符串一致'abbc'.replaceAll('b', '$&amp;')// 'abbc'// $` 表示匹配结果之前的字符串// 对于第一个`b`，$` 指代`a`// 对于第二个`b`，$` 指代`ab`'abbc'.replaceAll('b', '$`')// 'aaabc'// $' 表示匹配结果之后的字符串// 对于第一个`b`，$' 指代`bc`// 对于第二个`b`，$' 指代`c`'abbc'.replaceAll('b', `$'`)// 'abccc'// $1 表示正则表达式的第一个组匹配，指代`ab`// $2 表示正则表达式的第二个组匹配，指代`bc`'abbc'.replaceAll(/(ab)(bc)/g, '$2$1')// 'bcab'// $$ 指代 $'abc'.replaceAll('b', '$$')// 'a$c' replaceAll()的第二个参数replacement除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数searchValue匹配的文本。 12'aabbcc'.replaceAll('b', () =&gt; '_')// 'aa__cc' 上面例子中，replaceAll()的第二个参数是一个函数，该函数的返回值会替换掉所有b的匹配。 这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。 123456789const str = '123abc456';const regex = /(\\d+)([a-z]+)(\\d+)/g;function replacer(match, p1, p2, p3, offset, string) { return [p1, p2, p3].join(' - ');}str.replaceAll(regex, replacer)// 123 - abc - 456 上面例子中，正则表达式有三个组匹配，所以replacer()函数的第一个参数match是捕捉到的匹配内容（即字符串123abc456），后面三个参数p1、p2、p3则依次为三个组匹配。","link":"/JavaScript/10.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"数值的扩展","text":"1.二进制和八进制表示发ES6提供了二进制和八进制数值的新写法，二进制使用0b(0B)八进制使用0o(0O)来表示 120b111110111 === 503 // true0o767 === 503 // true 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 12Number('0b111') // 7Number('0o10') // 8 2.数值分隔符ES2021中，允许JavaScript的数值使用下划线(_)作为分隔符 1let num = 1_000_000_000_000 这个数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。 1234123_00 === 12_300 // true12345_00 === 123_4500 // true12345_00 === 1_234_500 // true 小数和科学计数法也可以使用数值分隔符。 12345// 小数0.000_001// 科学计数法1e10_000 数值分隔符有几个使用注意点。 不能放在数值的最前面（leading）或最后面（trailing）。 不能两个或两个以上的分隔符连在一起。 小数点的前后不能有分隔符。 科学计数法里面，表示指数的e或E前后不能有分隔符。 下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是语言的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。 Number() parseInt() parseFloat() 12Number('123_456') // NaNparseInt('123_456') // 123 3.Number.isFinite()和Number.isNaN()ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false 注意，如果参数类型不是数值，Number.isFinite一律返回false。 Number.isNaN()用来检查一个值是否为NaN。 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true' / 0) // trueNumber.isNaN('true' / 'true') // true 如果参数类型不是NaN，Number.isNaN一律返回false。 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 12345678910isFinite(25) // trueisFinite(&quot;25&quot;) // trueNumber.isFinite(25) // trueNumber.isFinite(&quot;25&quot;) // falseisNaN(NaN) // trueisNaN(&quot;NaN&quot;) // trueNumber.isNaN(NaN) // trueNumber.isNaN(&quot;NaN&quot;) // falseNumber.isNaN(1) // false 4.Number.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true 5.Number.isInteger()Number.isInteger()用来判断一个数值是否为整数。 12Number.isInteger(25) // trueNumber.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 12Number.isInteger(25) // trueNumber.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。 1234Number.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger('15') // falseNumber.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 1Number.isInteger(3.0000000000000002) // true 上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。 类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。 12Number.isInteger(5E-324) // falseNumber.isInteger(5E-325) // true 上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。 总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。 6.Number.EPSILON和Number.isSafeInteager() 最小精度值 ES6在Number对象上面，新增了一个极小的常量Number.EPSILON它表示1与大于1的最小浮点数之间的差 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 123456Number.EPSILON === Math.pow(2, -52)// trueNumber.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// &quot;0.00000000000000022204&quot; 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// '0.00000000000000005551' 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。 10.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 125.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)// true 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。 123456789function withinErrorMargin (left, right) { return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);}0.1 + 0.2 === 0.3 // falsewithinErrorMargin(0.1 + 0.2, 0.3) // true1.1 + 1.3 === 2.4 // falsewithinErrorMargin(1.1 + 1.3, 2.4) // true 上面的代码为浮点数运算，部署了一个误差检查函数。 安全整数 JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 注意：实际使用这个API时，必须注意验证运算的结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值 123456789Number.isSafeInteger(9007199254740993)// falseNumber.isSafeInteger(990)// trueNumber.isSafeInteger(9007199254740993 - 990)// true9007199254740993 - 990// 返回结果 9007199254740002// 正确答案应该是 9007199254740003 上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。","link":"/JavaScript/11.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"Math的扩展","text":"1.Math.trunc()用于去除一个数值的小数部分，返回整数部分 12345Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 对于非数值，会先调用Number方法将其转为数值 123456789Math.trunc('123.456') // 123Math.trunc(true) //1Math.trunc(false) // 0Math.trunc(null) // 0Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaNMath.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.trunc = Math.trunc || function(x) { return x &lt; 0 ? Math.ceil(x) : Math.floor(x);}; 2.Math.sign()用来判断一个数到底是正数，负数，还是零。对于非数值，会先将其转换为数值 它会返回五种值 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 12345Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。 12345678Math.sign('') // 0Math.sign(true) // +1Math.sign(false) // 0Math.sign(null) // 0Math.sign('9') // +1Math.sign('foo') // NaNMath.sign() // NaNMath.sign(undefined) // NaN 3.Math.cbrt()用于计算一个数的立方根，对于非数值，会先调用Number方法将其转为数值 1234567Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948732Math.cbrt('8') // 2Math.cbrt('hello') // NaN 4.Math.clz32()将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2 上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。 clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。 左移运算符（&lt;&lt;）与Math.clz32方法直接相关。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1 &lt;&lt; 1) // 30Math.clz32(1 &lt;&lt; 2) // 29Math.clz32(1 &lt;&lt; 29) // 2 对于小数，Math.clz32方法只考虑整数部分。 12Math.clz32(3.2) // 30Math.clz32(3.9) // 30 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。 12345678Math.clz32() // 32Math.clz32(NaN) // 32Math.clz32(Infinity) // 32Math.clz32(null) // 32Math.clz32('foo') // 32Math.clz32([]) // 32Math.clz32({}) // 32Math.clz32(true) // 31 5.Math.imul()Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。 123Math.imul(2, 4) // 8Math.imul(-1, 8) // -8Math.imul(-2, -2) // 4 如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。 1(0x7fffffff * 0x7fffffff)|0 // 0 上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。 1Math.imul(0x7fffffff, 0x7fffffff) // 1 6.Math.fround()Math.fround方法返回一个数的32位单精度浮点数形式。 对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。 123Math.fround(0) // 0Math.fround(1) // 1Math.fround(2 ** 24 - 1) // 16777215 如果参数的绝对值大于 224，返回的结果便开始丢失精度。 12Math.fround(2 ** 24) // 16777216Math.fround(2 ** 24 + 1) // 16777216 Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。 12345678// 未丢失有效精度Math.fround(1.125) // 1.125Math.fround(7.25) // 7.25// 丢失精度Math.fround(0.3) // 0.30000001192092896Math.fround(0.7) // 0.699999988079071Math.fround(1.0000000123) // 1 对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。 12345678Math.fround(NaN) // NaNMath.fround(Infinity) // InfinityMath.fround('5') // 5Math.fround(true) // 1Math.fround(null) // 0Math.fround([]) // 0Math.fround({}) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.fround = Math.fround || function (x) { return new Float32Array([x])[0];}; 7.Math.hypot()Math.hypot方法返回所有参数的平方和的平方根。 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 上面代码中，3 的平方加上 4 的平方，等于 5 的平方。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。 8.对数方法ES6 新增了 4 个对数相关方法。 （1） Math.expm1() Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。 123Math.expm1(-1) // -0.6321205588285577Math.expm1(0) // 0Math.expm1(1) // 1.718281828459045 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.expm1 = Math.expm1 || function(x) { return Math.exp(x) - 1;}; （2）Math.log1p() Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 1234Math.log1p(1) // 0.6931471805599453Math.log1p(0) // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log1p = Math.log1p || function(x) { return Math.log(1 + x);}; （3）Math.log10() Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。 12345Math.log10(2) // 0.3010299956639812Math.log10(1) // 0Math.log10(0) // -InfinityMath.log10(-2) // NaNMath.log10(100000) // 5 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log10 = Math.log10 || function(x) { return Math.log(x) / Math.LN10;}; （4）Math.log2() Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。 1234567Math.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log2 = Math.log2 || function(x) { return Math.log(x) / Math.LN2;}; 9.双曲函数方法ES6 新增了 6 个双曲函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 10.BigIntJavaScript 原生提供BigInt函数，可以用它生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。 1234BigInt(123) // 123nBigInt('123') // 123nBigInt(false) // 0nBigInt(true) // 1n BigInt()函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。 12345new BigInt() // TypeErrorBigInt(undefined) //TypeErrorBigInt(null) // TypeErrorBigInt('123n') // SyntaxErrorBigInt('abc') // SyntaxError 上面代码中，尤其值得注意字符串123n无法解析成 Number 类型，所以会报错。 参数如果是小数，也会报错。 12BigInt(1.5) // RangeErrorBigInt('1.5') // SyntaxError BigInt 继承了 Object 对象的两个实例方法。 BigInt.prototype.toString() BigInt.prototype.valueOf() 它还继承了 Number 对象的一个实例方法。 BigInt.prototype.toLocaleString() 此外，还提供了三个静态方法。 BigInt.asUintN(width, BigInt)： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。 BigInt.asIntN(width, BigInt)：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。 BigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。 12345678const max = 2n ** (64n - 1n) - 1n;BigInt.asIntN(64, max)// 9223372036854775807nBigInt.asIntN(64, max + 1n)// -9223372036854775808nBigInt.asUintN(64, max + 1n)// 9223372036854775808n 上面代码中，max是64位带符号的 BigInt 所能表示的最大值。如果对这个值加1n，BigInt.asIntN()将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt.asUintN()方法由于不存在符号位，所以可以正确返回结果。 如果BigInt.asIntN()和BigInt.asUintN()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。 1234const max = 2n ** (64n - 1n) - 1n;BigInt.asIntN(32, max) // -1nBigInt.asUintN(32, max) // 4294967295n 上面代码中，max是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。 下面是BigInt.parseInt()的例子。 12345// Number.parseInt() 与 BigInt.parseInt() 的对比Number.parseInt('9007199254740993', 10)// 9007199254740992BigInt.parseInt('9007199254740993', 10)// 9007199254740993n 上面代码中，由于有效数字超出了最大限度，Number.parseInt方法返回的结果是不精确的，而BigInt.parseInt方法正确返回了对应的 BigInt。 对于二进制数组，BigInt 新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位 BigInt。DataView对象的实例方法DataView.prototype.getBigInt64()和DataView.prototype.getBigUint64()，返回的也是 BigInt。 转换规则可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。 1234Boolean(0n) // falseBoolean(1n) // trueNumber(1n) // 1String(1n) // &quot;1&quot; 上面代码中，注意最后一个例子，转为字符串时后缀n会消失。 另外，取反运算符（!）也可以将 BigInt 转为布尔值。 12!0n // true!1n // false 数学运算数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。 129n / 5n// 1n 几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。 不带符号的右移位运算符&gt;&gt;&gt; 一元的求正运算符+ 上面两个运算符用在 BigInt 会报错。前者是因为&gt;&gt;&gt;运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符&gt;&gt;。后者是因为一元运算符+在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定+1n会报错。 BigInt 不能与普通数值进行混合运算。 11n + 1.3 // 报错 上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如(2n**53n + 1n) + 0.5这个表达式，如果返回 BigInt 类型，0.5这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。 同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。 12345// 错误的写法Math.sqrt(4n) // 报错// 正确的写法Math.sqrt(Number(4n)) // 2 上面代码中，Math.sqrt的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用Number方法转一下类型，才能进行计算。 asm.js 里面，|0跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与|0进行运算会报错。 11n | 0 // 报错 其他运算BigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true。 123456if (0n) { console.log('if');} else { console.log('else');}// else 上面代码中，0n对应false，所以会进入else子句。 比较运算符（比如&gt;）和相等运算符（==）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。 123450n &lt; 1 // true0n &lt; true // true0n == 0 // true0n == false // true0n === 0 // false BigInt 与字符串混合运算时，会先转为字符串，再进行运算。 1'' + 123n // &quot;123&quot;","link":"/JavaScript/12.Math%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"事件模型","text":"Javascript事件使得Html网页具备互动性， 常见的加载事件、鼠标事件、自定义事件等 1.事件模型JavaScript事件流是为了描述父子元素之间事件触发的顺序 Javascript事件模型一共有三种分别是 原始事件模型（DOM0级） 所有的浏览器都支持的一种事件模型， 没有事件流，事件一旦发生马上进行处理，有两种方式可以实现原始事件模型 以on开头的标签属性 123456789&lt;p onclick=&quot;console.log('p')&quot;&gt; &lt;span onclick=&quot;console.log('span')&quot;&gt;clieck me&lt;/span&gt;&lt;/p&gt;&lt;!--标签属性值是事件点击后要执行的javascript代码；显示与行为没有分离；没法为同一个事件绑定多个函数事件发生在冒泡阶段(当点击span标签时，console依次打印span、p)--&gt; 元素节点对象的事件属性 123456789101112 var pDom = document.getElementById(&quot;p&quot;);pDom.onclick = sayHello;function sayHello() { console.log(&quot;hello world&quot;) } /** 节点对象的事件属性值是函数 没法为同一个事件绑定多个函数，后者会覆盖前者 事件依然发生在冒泡阶段 */ 标准事件模型（DOM2级） 标准事件模型是W3C组织制定的标准事件模型，现代浏览器（IE6～8之外）都支持，该模型将事件分为三个阶段： 捕获阶段 当某个事件触发时，事件会从window对象至上而下传播直至事件发生的目标元素，默认在这个过程中相应的事件监听函数不会触发。 目标阶段 当事件传播到目标元素之后，执行目标元素上该事件的监听函数，如果没有就不执行。 冒泡阶段 事件再从目标元素开始逐层向上传播， 如果途中有该事件的监听函数就执行；所有事件都有捕获阶段，但是只有部分事件才有冒泡阶段。 依次给下面的div、ul、li、p、span元素添加一个click事件，并给该事件绑定两个监听函数（函数相同，但是调用阶段不同，一个在捕获阶段触发， 一个在冒泡阶段触发） 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt;clieck me&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; var elArray = ['div', 'p', 'span'] var domArray = elArray.map(item =&gt; { return document.querySelector(item) }) domArray.forEach(item =&gt; { item.addEventListener('click', hello, false) item.addEventListener('click', hello, true) }) function hello(event) { console.log(` target:${event.target.nodeName.toLowerCase()} currentTarget: ${event.currentTarget.nodeName.toLowerCase()} eventPhase: ${[&quot;not happen&quot;, &quot;capture&quot;, &quot;target&quot;, &quot;bubble&quot;][event.eventPhase]}`) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当点击span时，事件从window对象至上而下传播， 先触发捕获阶段的事件，当事件传播到目标元素时触发目标元素的两个监听事件发生，所以在target阶段console打印了两次， 接着冒泡阶段事件由里向外传播，依次触发对应事件。 IE事件模型 在IE老版本浏览器中（IE6～8），事件对象不作为函数传入， 而是作为window全局对象的一个属性传入 window.event 现已基本不用了，太老了。 2.EventTargetDOM的事件操作（监听和触发），都定义在EventTarget接口， 所有节点对象都部署了这个接口（window, document, element等对象） 该接口主要提供三个实例方法： addEventListener : 添加事件监听器 removeEventListener : 移除事件监听器 dispatchEvent ： 派发事件 1.1 addEventListeneraddEventListener(type, fn, useCapture) 方法为事件添加对应的处理函数，在事件触发时调用。 type: 事件名称（click、dubleclick、keydown…） fn： 事件触发时的回调函数 useCapture: 指定回调函数是在捕获阶段调用还是在冒泡阶段调用， 默认值为false在冒泡阶段调用。 可以通过该方法为同一个事件添加多个监听函数； 可以手动控制事件发生是在捕获阶段还是在冒泡阶段触发； 可以将子元素上的事件统一委托给父元素代为处理 事件对象event以监听函数参数的形式出现， 其常用属性： target： 监听事件所在的节点对象， 只会出现在目标阶段 currentTarget: 事件传播过程中当前所在的节点对象， 会发生在捕获、目标、冒泡三阶段 eventPhase: 事件发生的阶段： 0: 事件未发生； 1:捕获阶段；2:目标阶段； 3:冒泡阶段 3.事件代理通过事件冒泡机制，统一将添加在子元素上的事件，委托给父元素代为处理，这样的好处： 减少元素上的事件绑定、减少内存占用 统一在父元素上代为处理， 即便后面再动态添减元素，上面的事件依然有效","link":"/JavaScript/13.%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"},{"title":"基础语法整理","text":"1.数据类型JavaScript数据类型包括7种基本类型和1种引用类型 基本类型 Number JavaScript的Number类型是采用IEEE754格式来表示整数和浮点的值，Number类型的值一般默认是十进制表示，当然也可以直接表示八进制和十六进制，八进制以0为首位，十六进制以0x为首位，但无论是几进制，在运算时都是以十进制的方式进行运算 双精度64位浮点格式 数值范围：-2^53-1~2^53-1 浮点数值：浮点数值最高精度是17位，超出的位数会被截掉，这也是为什么0.1+0.2 !== 0.3，在运算时，先将数值转换为二进制，运算结束后转换回来，最后得到的值是0.300000000004,所以不相等 NaN：NaN用于表示一个本来要返回数值的操作数未返回数值的情况，以防止抛出错误，NaN与任何值都不相等，包括其本身。isNaN()这个函数可以判断一个参数是否是数值，若不是数值，则会尝试转换为数值，无法转换的情况会返回false，这个函数适用于对象，在参数是对象的时候，会首先调用对象的valueof()方法，如果不能转为数值，则会调用toString()方法 数值的转换：这里指显示转换，主要通过三个方法进行转换：Number() parseInt()，第一个参数是要转换的值，第二个参数是进制，parseFloat()只会转换为十进制 String 字符串是非常常用的类型，主要需要注意两个地方，一个是字符串是不可变的，如果需要改变一个字符串的值，那么就需要销毁原来的字符串，然后再创建一个新的字符串。第二个是在转换为字符串的时候，有两个方法，toString()和String()，后者其实是调用前者 Boolean Boolean只有两个值，即true和false，该类型的字面值是区分大小写的，只有全小写才是boolean的值，其他的都是标识符。Boolean类型本身包含一个Boolean()方法，可以将其他类型转换为Boolean类型。 Symbol(ES6) ES6新增的基础数据类型，可以避免对象属性命名冲突，多个模块共享独一的属性 BigInt(ES2020) 用于表示对任意长度整数的支持 创建BigInt：在一个整数字面量后面加n或者调用BigInt函数 不要把BigInt和Number数字类型混用 BigInt不支持一元加法 Null null的主要作用是用来判断一个值是否存储了对象的引用 使用typeof操作符对null值进行检测时，会返回一个object值，这是因为null从逻辑的角度来说表示一个空指针对象。 在创建一个变量用来保存对象的时候，建议将变量初始化为null undefined 用来表示一个已经声明但没有被初始化的变量 引用类型 object 有一句话叫做JavaScript一切皆对象，对象是JavaScript的基础 所具有的属性和方法： constructor：执向对应的构造函数 hasOwnProperty()：用来检查当前对象实例(不是原型)是否具有某个属性 isPrototypeOf()：检测一个对象是否在另一个对象的原型链中 prototypeIsEnumberable()：是否允许for-in枚举 toLocalString() toString() valueOf() 包括了Array Function Date RegExp Error 类型判断 typeof()：除了null以外的基础类型都能判断，引用类型可以判断function Object.prototype.toString.call()：可以检测出所有数据类型 instanceof：查找该属性是否属于原型链上的某个构造函数 constructor：通过构造函数去判断 2.深拷贝与浅拷贝 深拷贝层层拷贝，浅拷贝只拷贝第一层，深层只是引用 在深拷贝中，新对象中的更改不会影响原始对象。而浅拷贝新对象中的更改原始对象也会跟着更改 深拷贝中，原始对象不与新对象共享相同的属性，浅拷贝中，他们具有相同的属性 3.闭包闭包是一个能读取其他函数内部变量的函数 优点：使外部能访问到局部的变量 缺点：使用不当容易造成内存泄漏问题 1234567891011function a () { let num = 0 // 这是个闭包 return function () { return ++num }}const b = a()console.log(b()) // 1console.log(b()) // 2 4.变量提升使用var关键字声明的变量存在变量提升 12345678console.log(name) // undefinedvar name = &quot;hjc&quot;if(false) { var age = 23;}console.log(age) // undefined 函数提升 1234567console.log(fun) // function fun() {}function fun() {}if (false) { function fun2(){}}console.log(fun2) // undefined 不会报错 优先级：函数提升 &gt; 变量提升 5.isNaN和Number.isNaN()的区别 isNaN：除了判断NaN为true，还会把不能转成数字的判断为true Number.isNaN：只有判断NaN时为true，其余情况都为false 6.遍历对象时，如何避免遍历出原型上的属性 使用hasOwnProperty() 1234567891011121314function Person(name) { this.name = name;}Person.prototype.age = 22;const person = new Person('jiacheng');for(const key in person) { console.log(key) // name age}for(const key in person) { person.hasoOwnProperty(key) &amp;&amp; console.log(key) // name} 7.valueof与toString valueOf偏向于运算，toString偏向于显示 对象转换时，会优先调用toString 强转字符串优先调用toString，强转数字优先调用valueOf 正常情况下优先调用toString，运算操作符情况下优先调用valueOf 调用valueOf 调用者 返回值 返回值类型 Array 数组本身 Array Boolean 布尔值 Boolean Date 毫秒数 Number Function 函数本身 Function Number 数字值 Number Object 对象本身 Object String 字符串 String 调用toString 调用者 返回值 返回值类型 Array 数组转字符串，相当于Array.join() String Boolean 转字符串’true’、’false’ String Date 字符串日期，如’Fri Dec 23 2016 11:24:47 GMT+0800 (中国标准时间)’ String Number 数字字符串 String Object ‘[object Object]’ String String 字符串 String 8.JavaScript变量在内存中的具体存储形式 基本数据类型：存在栈内存中 引用数据类型：指针存在栈内存中，指向堆内存中一块地址，内容存在堆内存中 9.JavaScript装箱和拆箱装箱：把基本数据类型转化为对应的引用数据类型的操作 在声明一个基本数据类型时，若要调用对应引用数据类型上面的api，则直接调用即可 123456789var a = 'jiacheng'var index = a.indexOf('j')console.log(index) // 0// 装箱操作 1.创建String类型的一个实例；2.在实例上调用指定的方法；3.销毁这个实例var temp = new String('jiacheng');var index = temp.indexOf('j');temp = null;console.log(index) 拆箱：将引用数据类型转化为对应的基本数据类型的操作 通过valueOf和toString方法实现拆箱操作 123456789var objNum = new Number(123);var objStr =new String(&quot;123&quot;);console.log( typeof objNum ); //objectconsole.log( typeof objStr ); //objectconsole.log( typeof objNum.valueOf() ); //numberconsole.log( typeof objStr.valueOf() ); //stringconsole.log( typeof objNum.toString() ); // stringconsole.log( typeof objStr.toString() ); // string 注意：从ES6开始语法禁止显示地实例化基本数据类型所对应的包装类，因此Symbol和BigInt的构造函数无法被new关键字实例化 10. null和undefined的异同点相同的 都是空变量 对应的布尔值都为false null == undefined为true 不同点 typeof判断null为object，判断undefined为undefined null转为number类型为0，undefined转成number类型为NaN null表示一个对象未初始化，undefined表示初始化了但为赋值 null === undefined为false 11.如何判断数据类型 typeof xxx：能判断出number，string，undefined，boolean，symbol，bigint，object，function（null是object） Object.prototype.toString.call(xxx)：能判断出大部分类型 Array.isArray(xxx)：判断是否为数组 12.为什么typeof null是object不同的数据类型在底层都是通过二进制来表示的，二进制的前三位全是0的会被判断为object，而null的底层全是0，所以会被判断为object 13、== 与 === 的区别？ ==：在比较过程中会存在隐式转换 ===：需要类型相同，值相同，才能为true 14、JavaScript的隐式转换规则？ 1、转成string类型： +（字符串连接符） 2、转成number类型：++/–(自增自减运算符) + - * / %(算术运算符) &gt; &lt; &gt;= &lt;= == != === !== (关系运算符) 3、转成boolean类型：!（逻辑非运算符) 15.双等号左右两边的转换规则 null == undefined为true 如果有一个为boolean，则在比较之前会先转换成number类型再比较，true转为1，false转为0 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值 如果一个操作数是对象，另一个操作数不是，则调用对象的toString()方法，用得到的基本类型值按照前面的规则进行比较 16. undefined &gt;= undefined为什么是false按照隐式转换规则，可以转为NaN &gt;=NaN，所以是false 17.null &gt;= null为什么是true按照隐式转换规则，可以转为 0 &gt;= 0 ，所以为true 18.[] == ![] 为什么是true按照双等号左右两边的转换规则 ! 优先级高于 ==，[]不是假值，所以先转换成 ![] == false 右边为布尔值，false先转数字0，所以可转换为[] == 0 左边为对象，[]调用toString转为 ''，转换为'' == 0 左边为字符串，''转换为0，最终为 0 == 0 19.0.1 + 0.2 === 0.3，对吗？不对，JavaScript的计算存在精度丢失问题 原因：JavaScript中小数是浮点数，需转二进制进行运算，有些小数无法用二进制表示，所以只能取近似值，所以造成误差 解决方法： 先变成整数运算，然后再变回小数 toFixed() 性能不好，不推荐 20.什么是匿名函数就是没有函数名的函数 21.绑定点击事件有几种方式 xxx.onclick = function (){} &lt;xxx onclick=&quot;&quot;&gt;&lt;/xxx&gt; xxx.addEventListence('click', function(){}, false) 22. addEventListence的第三个参数是干嘛的第三个变量传一个布尔值，是否要阻止冒泡，默认是false，不阻止冒泡 23.函数声明和函数表达式的区别 函数声明：享受函数提升 函数表达式：归于类变量声明，享受变量提升 函数提升优先级 &gt; 变量提升优先级 123456console.log(fun) // fun () {}// 函数表达式var fun = function(name) {}// 函数声明function fun () {}console.log(fun) // fun (name) {} 24.JavaScript事件流模型 事件冒泡：由具体的元素接收，并往上传播 事件捕获：由最不具体的元素接收，并往下传播 DOM事件流：捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段 25.Ajax Axios Fetch Ajax：是对XMLHttpRequest对象（XHR）的封装 Axios：是基于Promise对XHR对象的封装 Fetch：是window的一个方法，也是基于Promise，但是与XHR无关，不支持IE 26.load、$(document).ready、DOMContentLoaded的区别？DOM文档加载的步骤为： 解析HTML结构。 加载外部脚本和样式表文件。 解析并执行脚本代码。 DOM树构建完成。// DOMContentLoaded触发、$(document).ready触发 加载图片等外部文件。 页面加载完毕。// load触发 27.阻住事件冒泡1234567function stopBubble(e) { if (e.stopPropagation) { e.stopPropagation() } else { window.event.cancelBubble = true; }} 28.阻住事件默认行为 比如说链接a，input type为submit等 123456function stopDefault(e) { if (e.preventDefault) { e.preventDefault(); } else { window.event.returnValue = false;} 29.事件委托当所有子元素都需要绑定相同的事件的时候，可以把事件绑定在父元素上，这就是事件委托，优点有： 绑定在父元素上只需要绑定一次，节省性能 子元素不需要每个都去绑定同一事件 如果后续又有新的子元素添加，会由于事件委托的原因，自动接收到父元素的事件监听 30.如何实现数组去重1234// 使用 Set 去重function quchong (arr) { return [...new Set(arr)]} 31.NaN是什么，有什么特点 NaN不等于自身，也就是 NaN === NaN 为 false NaN为假值，转布尔值为false NaN本质是一个number，typeof NaN === number 32.处理异步的方法有哪些 回调函数 Promise 事件监听 发布订阅 Generator(async/await) 33.创建一个对象new Object创建12const obj = new Object()obj.name = 'Sunshine_Lin' 字面量创建1const obj = { name: 'Sunshin_Lin' } 工厂模式创建123456function createObj(name) { const obj = new Object() obj.name = name return obj}const obj = createObj('Sunshine_Lin') 构造函数创建1234function Person(name) { this.name = name}const person = new Person('Sunshine_Lin') 34.this指向的四种情况 指向new操作符创建的实例 12345function Person(name) { this.name = name; console.log(this)}const person = new Person('jiacheng') // this指向当前person的实例对象 指向window 12345function() { console.log(this);}fn() // 指向window 指向对象调用方法 1234567const target = { fn: function () { console.log(this) }}target.fn() // targetconst fn = target.fnfn() // 浏览器window，node里global call apply bind改变this 123456789101112131415161718const obj1 = { name: '黄家程', sayName: function() { console.log(this.name) }}const obj2 = { name: 'jiacheng_huang'}// 改变sayName的this指向obj2obj1.sayName.call(obj2) // jiacheng_huang// 改变sayName的this指向obj2obj1.sayName.apply(obj2) // jiacheng_huang// 改变sayName的this指向obj2const fn = obj1.sayName.bind(obj2)fn() // jiacheng_huang 35、数组的常用方法有哪些？ 方法 作用 是否影响原数组 push 在数组后添加元素，返回数组长度 ✅ pop 删除数组最后一项，返回被删除项 ✅ shift 删除数组第一项，并返回数组 ✅ unshift 数组开头添加元素，返回添加的元素 ✅ reserve 反转一个数组，返回修改后的数组 ✅ sort 排序一个数组，返回修改后的数组 ✅ splice 截取数组，返回被截取的区间 ✅ join 将一个数组所有元素连接成字符串并返回这个字符串 ❌ concat arr1.concat(arr2, arr3) 连接数组 ❌ map 操作数组每一项并返回一个新数组 ❌ forEach 遍历数组，没有返回值 ❌ find 对数组进行筛选，返回第一个符合条件的元素 ❌ filter 对数组所有项进行判断，返回符合规则的新数组 ❌ every 数组每一项都符合规则才返回true ❌ some 数组有符合规则的一项就返回true ❌ reduce 接收上一个return和数组的下一项 ❌ flat 数组扁平化 ❌ slice 截取数组，返回被截取的区间 ❌ 36、Math的常用方法有哪些？ 方法 作用 Math.max(arr) 取arr中的最大值 Math.min(arr) 取arr中的最小值 Math.ceil(小数) 小数向上取整 Math.floor(小数) 小数向下取整 Math.round(小数) 小数四舍五入 Math.sqrt(num) 对num进行开方 Math.pow(num, m) 对num取m次幂 Math.random() * num 取[0,num)的随机数 37、哪些因素导致内存泄漏？如何解决？请看我这篇文章哪是大神？只是用他人七夕约会时间，整理「JS避免内存泄漏」罢了 38、讲讲JavaScript的垃圾回收机制看我这篇文章：赠你13张图，助你20分钟打败了「V8垃圾回收机制」 39、JS中有哪些不同类型的弹出框？在JS中有三种类型的弹出框可用，分别是： Alert Confirm Prompt 40. 如何将 JS 日期转换为ISO标准toISOString() 方法用于将js日期转换为ISO标准。 它使用ISO标准将js Date对象转换为字符串。如： 12345var date = new Date();var n = date.toISOString();console.log(n);// YYYY-MM-DDTHH:mm:ss.sssZ复制代码 41、如何在JS中编码和解码 URLencodeURI() 函数用于在JS中对URL进行编码。它将url字符串作为参数并返回编码的字符串。 注意： encodeURI()不会编码类似这样字符： / ? : @ &amp; = + $ #，如果需要编码这些字符，请使用encodeURIComponent()。 用法： 12var uri = &quot;my profile.php?name=sammer&amp;occupation=pāntiNG&quot;;var encoded_uri = encodeURI(uri); decodeURI() 函数用于解码js中的URL。它将编码的url字符串作为参数并返回已解码的字符串，用法： 123var uri = &quot;my profile.php?name=sammer&amp;occupation=pāntiNG&quot;;var encoded_uri = encodeURI(uri);decodeURI(encoded_uri); 42、什么是BOM？有哪些api？BOM就是browser object model，浏览器对象模型 api 作用 代表方法或属性 window.history 操纵浏览器的记录 history.back() history.go(-1) window.innerHeight 获取浏览器窗口的高度 window.innerWidth 获取浏览器窗口的宽度 window.location 操作刷新按钮和地址栏 location.host：获取域名和端口 location.hostname：获取主机名 location.port：获取端口号 location.pathname：获取url的路径 location.search：获取?开始的部分 location.href：获取整个url location.hash：获取#开始的部分 location.origin：获取当前域名 location.navigator：获取当前浏览器信息 43、BOM 和 DOM 的关系BOM全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架。 DOM全称Document Object Model，即文档对象模型，是 HTML 和XML 的应用程序接口（API），遵循W3C 的标准，所有浏览器公共遵守的标准。 JS是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM的根节点。 可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。 44、JS中的substr()和substring()函数有什么区别substr() 函数的形式为substr(startIndex,length)。 它从startIndex返回子字符串并返回’length’个字符数。 12var s = &quot;hello&quot;;( s.substr(1,4) == &quot;ello&quot; ) // true substring() 函数的形式为substring(startIndex,endIndex)。 它返回从startIndex到endIndex - 1的子字符串。 123var s = &quot;hello&quot;;( s.substring(1,4) == &quot;ell&quot; ) // true复制代码 45、解释一下 “use strict” ?“use strict”是Es5中引入的js指令。 使用“use strict”指令的目的是强制执行严格模式下的代码。 在严格模式下，咱们不能在不声明变量的情况下使用变量。 早期版本的js忽略了“use strict”。 46.ES5继承方式 定义一个类 123456789101112// 定义一个类function Animal(name) { this.name = name || 'Animal'; // 实例方法 this.sleep = function() { console.log(this.name + '正在睡觉'); }}// 原型方法Animal.prototype.eat = function(food) { console.log(this.name + '正在吃' + food)} 1.原型链继承核心：将父类的实例作为子类的原型 优点 实例是子类的实例，也是父类的实例 父类新增原型方法/属性，子类都能访问到 简单，易于实现 缺点 子类要想新增属性和方法，必须要在new Animal()这样的语句之后，不能放在构造器中 原型对象的所有属性被所有实例共享 实现子类实例时，无法向父类构造函数传参 不支持多继承 12345678910111213function Cat() { }Cat.prototype = new Animal();Cat.prototype.name = 'cat';var cat = new Cat();console.log(cat.name);cat.eat('fish'); // cat正在吃fishcat.sleep(); // cat正在睡觉console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 2.构造继承核心：使用父类的构造器来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 优点 解决了原型链继承中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承(call多个父类对象) 缺点 实例并不是父类实例，只是子类的实例 只能继承父类的实例属性和实例方法，不能继承父类原型上的属性和方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 123456789101112function Cat(name) { Animal.call(this); this.name = name || 'Tom';}var cat = new Cat();console.log(cat.name); // Tomcat.sleep(); // Tom正在睡觉cat.eat('fish'); // 报错console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 3.实例继承核心：为父类实例添加新特性，作为子类实例返回 优点： 不限制调用方式，不管是new 子类()还是子类()，返回的对象具有相同效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 123456789101112131415161718function Cat(name) { var instance = new Animal(); instance.name = name || 'Tom'; return instance;}var cat = new Cat();console.log(cat.name); // Tomcat.sleep(); // Tom正在睡觉cat.eat('fish'); // Tom正在吃fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 4.拷贝继承核心：一个一个拷贝 优点 支持多继承 缺点 因为要一个一个拷贝，所以效率很低 无法获取父类的不可枚举方法 12345678910111213141516function Cat(name) { var animal = new Animal(); for (var p in animal) { Cat.prototype[p] = animal[p]; } this.name = name || 'Tom'}var cat = new Cat();console.log(cat.name); // Tomcat.sleep() // Tom正在睡觉！cat.eat('fish'); // Tom正在吃fishconsole.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 5.组合继承(原型链继承+构造继承)核心：通过父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 优点 弥补了构造继承的缺陷，可以继承实例的属性/方法，也可以继承原型上的属性/方法 既是子类的实例，也是父类的实例 可以向父类传参 函数可以复用 缺点 调用了两次父类的构造函数，生成了两份实例 123456789101112131415function Cat(name) { Animal.call(this); this.name = name || 'Tom';}Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat = new Cat();console.log(cat.name); // Tomcat.sleep() // Tom正在睡觉！cat.eat('fish'); // Tom正在吃fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 6.寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造时，就不会初始化两次实例方法/属性，避免继承组合的缺点 优点 几乎完美 缺点 实现复杂 123456789101112131415161718function Cat(name) { Animal.call(this); this.name = name || 'Tom';}// 创建一个没有实例方法的构造函数var Super = function () { }Super.prototype = Animal.prototype;// 将实例作为子类的原型Cat.prototype = new Super();// Test Codevar cat = new Cat();console.log(cat.name); // Tomcat.sleep() // Tom正在睡觉！cat.eat('fish') // // Tom正在吃fishconsole.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true","link":"/JavaScript/1.%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"},{"title":"字符串和数组常用方法","text":"1.Unicode表示法12//es6中将编码放入{}即可解析console.log('hell\\u{6f}'); 2.字符串常用方法 常规方法 charAt(index)：返回指定索引的字符串 indexOf(item)：返回指定字符串第一次出现的位置 lastIndexOf(item)：返回指定字符串最后一次出现的位置 substring[start,end)：提取指定区间的字符串，索引不能为负值 slice[start,end)：提取指定区间的字符串（索引可以为负值，-1就是倒数第二位） substr(start,length)：返回指定长度的字符串，可以从末尾开始取数据(-2就是取后面两位) concat(str1,str2…)：字符串拼接方法，连接两个或多个字符串，返回连接后的新字符串 toString()：返回字符串对象方法 toLowerCase()，把字符串转换成小写的 toUpperCase()，把字符串转换成大写的 String.fromCharCode(ASCII)：将对应的ASCII值转为字符串 String.fromCodePoint(ASCII)：将对应的ASCII值转为字串串，可处理高位编码 charCodeAt()：字符串转为对应的ASCII值 与正则表达式有关的方法 match(正则表达式)：在字符串中匹配是否有符合正则表达式的字符串，返回匹配到的字符串数组，未匹配到则返回null replace(oldStr/正则,newStr)：字符串替换方法，用新的子串将旧的子串替换掉，返回替换后的字符串 search(子串/正则)：字符串查询方法，找到子串第一次出现的位置并返回，未找到则返回-1 split(分割字符/正则)：字符串分割方法，传入分割符，把字符串分割为子字符串数组，返回分割后的数组 es6新增方法 includes(item)：返回布尔值，判断字符串是否包含某串字符。接受两个参数，第二个参数是起始的位置 startsWith(item)：返回布尔值，判断字符串开头是否包含某串字符 endsWith(item)：回布尔值，判断字符串结尾是否包含某串字符 repeat：返回一个新的字符串，将原字符串重复 n 次 padStart：返回新的字符串，在字符串前面补全，接受两个参数，第一个参数补全字符串长度，第二个参数补全的字符 padEnd：返回新的字符串，在字符串后面补全，接受两个参数，第一个参数补全字符串长度，第二个参数补全的字符 trimStart：去除前面空格 tiemEnd：去除后面空格 matchAll：返回一个正则表达式在当前字符串的所有匹配 1234567891011121314151617181920let str = &quot;How are you Are are are&quot;;// console.log(str.charAt(4)); //返回指定索引的字符串// console.log(str.indexOf(&quot;are&quot;)); // 返回指定字符串第一次出现的索引// console.log(str.lastIndexOf(&quot;are&quot;)); // 返回指定字符串最后一次出现的索引// console.log(str.substring(0,9)); // 返回指定区间的字符串// console.log(str.slice(0,0)); // 返回指定区间的字符串，索引可以为负值// console.log(str.substr(0,3)); // 返回指定长度的子串// console.log(str.concat(&quot; yes&quot;,&quot; no&quot;));/* let num = 123;console.log(num.toString()); */// console.log(str.toLocaleLowerCase());// console.log(str.toLocaleUpperCase());// console.log(str.match(/are/));// console.log(str.replace(/are/g,&quot;at&quot;));// console.log(str.split(/are/ig));// console.log(str.includes(&quot;are&quot;));// console.log(str.endsWith(&quot;e&quot;));// console.log(str.repeat(2));// console.log(str.match(/are/g)); 数组常用方法 常规方法 push()：从数组末尾插入数据，返回插入完成后数组的长度 pop()：从数组末尾取下数据，返回取下的数据 unshift()：从数组头部插入数据，返回插入完成后数组的长度 shift()：从数组头部取下数据，返回取下的数据 splice()：实现数组的插入，删除，替换： 插入：3个参数，起始位置，0，插入的项。 删除：2个参数，起始位置，删除的项数 替换：任意参数，起始位置，删除的项数，插入任意数量的项数 sort()：数组排序方法，默认按照ASCII值进行升序排序 fill()：使用一个固定值替换数组中的元素 reverse()：逆序输出数组 at()：接收一个整数值并返回该索引的项目，允许负数 indexOf(item)：返回对应元素的下标 concat(arr2,数据1,数据2…)：拷贝原数组生成新数组。合并数组 slice[start,end)：提取数组中指定区间的数据 join(分割符)：数组分割方法 copyWithin(target,[start,end))：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 高阶函数 forEach(callback)：遍历数组 map(callback)：遍历数组，可返回对数组的item和index进行一定操作后的结果。 filter(callback)：返回数组中全部符合条件的元素 find(callbakc)：返回数组中第一个符合条件的元素 findIndex(callback)：返回数组中第一个符合条件的元素的下标 some(callback)：返回布尔值，查找数组中是否有符合条件的元素(找到第一个符合条件的元素便会停止循环) every(callbakc)：返回布尔值，遍历数组中的每一个元素是否都符合条件 reduce(callback(prev, curr, index, array),initValue)：归并，为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 各值的累加const arr = [1,2,3,4,5];const result = arr.reduce((acc, cur) =&gt; acc + cur);arr.forEach(item =&gt; console.log(item));// 数组降维const result = [[1,2],[3,4],[5,6]].reduce((acc, cur) =&gt; [...acc, ...cur], []);console.log(result);// 计算数组中每个元素出现的次数const arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;2&quot;, &quot;1&quot;, &quot;1&quot;];const result = arr.reduce((acc, cur) =&gt; { if( cur in acc ) { acc[cur]++; } else { acc[cur] = 1; } return acc;}, {});// 按属性对object分类const people = [ { name: 'Alice', age: 21 }, { name: 'Max', age: 20 }, { name: 'Jane', age: 20 },]function groupBy( objectArray, property ) { return objectArray.reduce( (acc, obj) =&gt; { const key = obj[property]; if (!acc[key]) { acc[key] = []; } acc[key].push(obj); return acc; }, {});}const groupedPeople = groupBy(people, 'age');console.log(groupedPeople);","link":"/JavaScript/0.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"CSS笔记","text":"1.FlexFlex布局是将元素进行水平或者垂直排列的一维布局方案，通过设置display为flex或inline-flex进行开启。采用Flex布局的容器，默认存在两根轴，水平的主轴和垂直的交叉轴，容器内的子元素默认成为容器的成员，称为项目。主轴的开始位置与边框的交叉点称为main start，结束位置称为end start，交叉轴的开始位置叫cross start，结束位置叫cross end Flex项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 Flex属性分为两部分，一部分作于于容器，另一部分作于于容器内的项目 容器属性 属性 功能 flex-direction 决定主轴的方向 `row flex-wrap 决定主轴上的项目排列不下时，是否换行排列 `nowrap flex-flow flex-direction和flex-wrap的简写形式。默认值：row nowrap justify-content 定义了项目在主轴上的对齐方式和额外空间的分配方式 `flex-start align-item 决定项目在交叉轴上的对齐方式 `stretch align-content 定义了多根轴线的对齐方式，设置了flex-wrap属性为wrap后align-content属性才能生效 `stretch 项目属性 属性 功能 order 定义项目的排列顺序，数值越小，排列越靠前，默认为0，可以是负数 flex-grow 扩展规则，规定flex容器中剩余的空间应该拿出多少分配给项目，默认为0，最大值是1，超过1按照1来扩展 flex-shrink 规定了flex项目的收缩规则，flex项目仅在默认宽度之和大于容器的时候才会发生收缩，默认值是1 flex-basis 指定了子项在容器主轴方向上的初始大小，优先级高于自身的宽度width，默认值是auto flex 该属性是flex-grow flex-shrink flex-basis的简写，默认值是0 1 auto，后两个值可选 align-self 该属性用于设置单个项目在交叉轴的对齐方式，可覆盖align-item属性 `stretch 2.CSS选择器 选择器 格式 优先级权重 id选择器 #id 100 类选择器 #class 10 伪类选择器 li:last-child 10 属性选择器 a[href=”aaa”] 10 标签选择器 div 1 伪元素选择器 li::after 1 相邻兄弟选择器 h1+p 0 子元素选择器 ul &gt; li 0 后代选择器 li a 0 通配符选择器 * 0 对于样式的优先级： !important：优先级最高 内联样式：1000 id选择器：100 类，伪类，属性选择器：10 元素选择器，伪元素选择器：1 通配符选择器，后代选择器，兄弟选择器：0 3.规则 @namespace：告诉CSS引擎必须考虑XML命名空间 @media：媒体查询 @page：描述打印文档时布局的变化 @font-face：描述将下载的外部字体 @keyframes：描述CSS动画关键帧 @import：用于告诉CSS引擎引入一个外部样式表 link和@import的区别 link是HTML标签，除了能导入CSS外，还可以导入其他资源，比如图片，脚本和字体等；而@import是CSS语法，只能用来导入CSS link导入的样式会在页面加载时同时加载，@import导入的样式需要等页面加载完成后再加载 link没有兼容性问题，@import不兼容ie5以下 link可以通过js操作访问 4.继承性 可继承属性：font-family font-style font-size font-weight color 不可继承属性：weigth height margin padding 5.清除浮动浮动的元素会脱离文档流，导致父元素高度塌陷 通过BFC清除浮动 123.parent { overflow: hidden;} 通过clear清除浮动 12345678.clearfix { zoom: 1;}.clearfix::after { content: &quot;&quot;; display: block; clear: both;} 6.消除浏览器默认样式12345678910111213141516171819202122232425262728293031323334353637383940414243html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header, hgroup,menu, nav, output, ruby, section, summary,time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;}/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section { display: block;}body { line-height: 1;}ol, ul { list-style: none;}blockquote, q { quotes: none;}blockquote:before, blockquote:after,q:before, q:after { content: ''; content: none;}table { border-collapse: collapse; border-spacing: 0;} 7.长文本处理 字符超出部分换行 1overflow-wrap: break-word; 字符超出部分使用连接字符 1hyphens: auto; 单行文本超出省略 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 多行文本超出省略 12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box-;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 8.line-height和height的区别height就是元素的高度值 line-height是每一行文字的高度，如果文字换行，则整个格子高度会增大 9.BFC块级格式化上下文，它是一个独立容器，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。 创建规则： 根元素 float不是none的元素 绝对定位的元素(position为absolute或fixed) display取值为inline-block table-cell table-caption inline-flex之一的元素 overflow不是visible的元素 作用： 清除浮动 阻止父子元素的margin折叠 10.居中方式单行的文本、inline 或 inline-block 元素 水平居中 1text-align: center 垂直居中 123456789.single-line { padding-top: 10px; padding-bottom: 10px;}// 或.single-line { height: 100px; line-height: 100px;} 固定宽高的块级盒子 absolute+负margin 1234567891011.parent { position: relative;}.child { width: 100px; height: 100px; position: absolute; left: 50%; top: 50%; margin: -50px 0 0 -50px} absolute + margin auto 12345678910111213.parent { position: relative;}.child { width: 100px; height: 100px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;} absolute + calc 12345678910.parent { position: relative;}.child { width: 100px; height: 100px; position: absolute; left: calc(50% - 50px); top: calc(50% - 50px)} 不固定宽高的块级盒子 absolute + transform 123456789.praent { position: relative;}.child { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%)} line-height + vertical-align 123456789.parent { line-height: 150px; text-aligin: center;}.child { display: inline-block; line-height: initial; vertical-align: middle;} writing-mode 12345678910111213.parent { writing-mode: vertical-lr; text-align: center;}.middle { display: inline-block; writing-mode: horizontal-tb; width: 100%}.child { display: inline-block;} table-cell 12345678.parent { display: table-cell; vertical-aligin:middle; text-align: center;}.child { display: inline-block;} flex 12345.parent { display: flex; justify-content: center; align-items: center} grid 1234567.parent { display: grid;}.child { justify-self: center; align-self: center;} 11.常用布局双栏布局(边栏定宽主栏自适应) float+overflow(BFC原理) 1234567aside { float: left; width: 200px}main { overflow: hidden;} float+margin 1234567aside { float: left; width: 200px;}main { margin-left:200px} flex 123456789layout { display: flex;}aside { width:200px}main { flex-grow: 1} grid 1234layout { display: grid; grid-template-columns: 200px auto;} 三栏布局(两侧定宽主栏自适应) 圣杯布局 123456789101112131415161718192021layout { padding: 0 200px;}main { float: left; width: 100%;}aside { float: left; width: 200px;}left { position: relative; left: -200px; margin-left: -100%;}right { position: relative; right: -200px; margin-left: -200px} 双飞翼布局 1234567891011121314151617main { float: left; width: 100%;}.inner { margin: 0 200px;}aside { float: left; width: 200px;}.left { margin-left: -100%;}.right { margin-left: -200px;} float+overflow 123456789101112aside { width: 200px;}left { float: left;}right { float: right;}main { overflow: hidden;} flex 123456789layout { display: flex;}aside { width: 200px;}main { flex-grow: 1;} grid 1234layout { display: grid; grid-template-columns: 200px auto 200px} 12.Grid给&lt;div&gt;这类块状元素元素设置display:grid或者给&lt;span&gt;这类内联元素设置display:inline-grid，Grid布局即创建 此时该div就是grid容器，其子元素称为grid子项 容器属性 子项属性 grid-template-columns grid-column-start grid-template-rows grid-column-end grid-template-areas grid-row-start grid-template grid-row-end grid-column-gap grid-column grid-gap grid-row justify-items grid-area align-items justify-self place-items align-self justify-content place-self align-content place-content grid-auto-columns grid-auto-rows grid-auto-flow grid 13.nth-of-type和nth-child的区别 nth-of-type：:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素。n 可以是数字、关键词或公式 12345678910111213141516&lt;style&gt;div&gt;p:nth-of-type(2){ color:red;}&lt;/style&gt;&lt;div&gt; &lt;p&gt;我是第1个段落&lt;/p&gt; &lt;p&gt;我是第2个段落&lt;/p&gt;&lt;!--符合条件：1、是特定元素类型&lt;p&gt;，2、是父元素&lt;div&gt;的第二个&lt;p&gt;元素。这里被选择，会变成红色--&gt; &lt;p&gt;我是第3个段落&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;我是第1个段落&lt;/p&gt; &lt;blockquote&gt;第1个引用&lt;/blockquote&gt; &lt;p&gt;我是第2个段落&lt;/p&gt;&lt;!--符合条件：1、是特定元素类型&lt;p&gt;，2、是父元素&lt;div&gt;的第二个&lt;p&gt;元素。这里被选择，会变成红色--&gt; &lt;p&gt;我是第3个段落&lt;/p&gt;&lt;/div&gt; nth-child：:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型。n 可以是数字、关键词或公式。 注意：如果第 N 个子元素与选择的元素类型不同则样式无效！ 123456789101112131415&lt;style&gt;div&gt;p:nth-child(2){ color:red;}&lt;/style&gt;&lt;div&gt; &lt;p&gt;我是第1个段落&lt;/p&gt; &lt;p&gt;我是第2个段落&lt;/p&gt;&lt;!--符合条件：1、是&lt;p&gt;元素，2、父元素&lt;div&gt;的第二个元素。这里被选择，会变成红色。--&gt; &lt;p&gt;我是第3个段落&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;我是第1个段落&lt;/p&gt; &lt;span&gt;我是第1个文本&lt;/span&gt;&lt;!--不符合条件：不是&lt;p&gt;元素，没有被选择--&gt; &lt;p&gt;我是第2个段落&lt;/p&gt;&lt;/div&gt;","link":"/CSS/"},{"title":"HTML笔记","text":"1.HTML XHTML XML的区别 HTML: 超文本标记语言 XHTML：可扩展的超文本标记语言，基于XML，作用与HTML类似，但语法更加严格 XML：可扩展标记语言，主要用于存储数据和结构 XHTML标签名必须手写，元素必须以双标签形式存在，元素必须被正确嵌套，元素必须有根元素 2.HTML5和HTML的区别HTML5是HTML的新标准，其主要目标是无需任何额外的插件就可以传输所有内容，它包括了动画，视频等丰富的图形界面 从文档声明 HTML的文档声明是很长的一段代码，而HTML5 只需要在文档头部使用&lt;!DOCTYPE html&gt;标签即可声明 从语义结构 HTML4.0没有体现语义化的标签，而HTML5加入了很多语义化标签，如header main footer acticle等 3.DOCTYPE标签&lt;!DOCTYPE html&gt;的作用就是让浏览器进入标准模式，使用最新的W3C标准来解析渲染页面，若文档头部不写则浏览器会使用兼容模式来解析和渲染页面 标准模式：指浏览器按照W3C标准解析文档 兼容模式：浏览器通常会为了兼容老旧站点而不使用最新的W3C标准来解析文档 4.块元素 行内元素 行内块元素 块元素 独占一行 可以设置宽高，不设置宽度情况下默认继承父元素的宽度 常见的块元素：div p h1~h6 ul ol table form 行内元素 相邻的元素会排列在同一行 无法设置宽高，其大小由内容决定 可以设置水平方向的margin padding的值，但无法使用auto属性居中 常见的行内元素：span a strong b em i label等 行内块元素 不独占一行 可以设置宽高，默认大小由内容决定 可以设置margin padding等属性，但无法使用auto属性居中 常见的行内块元素：button input img iframe等 5.Link和@import导入样式的区别 link是HTML标签，@import用于CSS文件中导入另一个CSS文件 link标签在页面加载时就会被加载，@import引用会等到页面加载完在加载 link标签权重高于@import引用 @import引用有兼容性问题，而link标签无兼容问题 6.label标签label标签用来定义表单控制间的关系，当用户与该标签发生交互的时候，浏览器会自动对焦到绑定的表单标签上 12&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;&lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt; 7.标签上的title和alt属性的区别title属性用于为该元素设置建议性信息，在鼠标移到该元素上面时会显示 alt属性用于在图片未能正常显示时给予文字说明 8.语义化的好处 便于开发者阅读和写出更加优雅的代码 有利于SEO：让浏览器爬虫更好地解析，爬虫依赖于标签来确定上下文和各个关键字的权重 方便其它设备(如移动设备)解析文档 9.iframe的优缺点 优点 跨域通信 无刷新文件上传 可以用于加载一些第三方图标或广告等 缺点 会阻塞主页面onload事件 无法被一些搜索引擎识别 会产生很多页面，不利于管理 10.src与href的区别 href: 指向网络资源所在的位置，并建立该资源和当前元素(锚点)或当前文档(链接)之间的链路，用于超链接 src：指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片，iframe等。 11.HTML5新特性 Canvas SVG：用于绘图的元素 video audio:用于播放视频和音频的媒体 Drag，Drop：用于拖拽的元素 Geolocation：用于获取地理位置 LocalStorage SessionStorage：用于本地离线存储 web Worker：运行在后台的JavaScript脚本 webSocket：基于TCP的全双工通信协议 语义化标签：header main footer nav section等 新的表单控件：date time url email search等 12.标准模式和怪异模式的区别 盒模型：标准模式中一个元素的宽高是它内容的宽高，怪异模式下元素的宽高还包含了padding和border 行内元素宽高：标准模式下行内元素无法设置宽高，怪异模式下则可以 水平居中：标准模式下margin: 0 auto可以使元素水平居中，怪异模式下则不行 13.标准盒模型和怪异盒模型HTML中每一个元素都可以看作一个盒模型，一个盒模型由content + padding + border + margin组成 标准盒模型：设置盒模型的width和height属性其实是设置内容的宽高，盒模型的宽度等于width + padding + border + margin 怪异盒模型：设置盒模型的的width和height属性其实是设置了content + padding + border的值。例如设置width为100px，padding为10px，那么此时内容区域的宽度只有80px(100 - 20 * 2) box-sizing：content-box|border-box|inherit 14.前端结构样式和行为分离结构(HTML)相当于人的骨架，样式(CSS)相当于人的装饰，行为(JavaScript)相当于人的动作，前端将这三者分离开，各自负责各自的内容，各部分可以通过引用进行使用 在分离的基础上，我们需要做到代码的精简，重用，有序 分离的好处 代码分离，利于团队的开发和后期的维护； 减少维护成本，提高可读性和更好的兼容性； 15.如何对网站的文件和资源进行优化 文件合并，减少http请求 文件压缩（gzip压缩需要的css和js文件） 使用缓存 使用cdn托管资源 网站外链接优化 meta标签优化,设置title keywords description优化等 16.渐进增强和优雅降级的区别 渐进增强：优先考虑低版本浏览器的兼容，在保证基本功能可以使用的情况下，再考虑对高级浏览器进行效果，交互等方面的优化 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 17.为什么HTML5不需要DTDHTML5中没有使用SGML或XHTML，不需要参考DTD 18.form表单关闭自动完成(自动联想)功能设置autocomplete=off 19.几种图片格式的区别 png：图片背景透明，可以支持很多颜色 jpg：图片背景不透明，静态图，可压缩 gif：动态图，支持颜色较少 20.meta标签meta标签常用于定义页面的说明，关键字等元数据，这些数据一般服务于浏览器，搜索引擎，并不会直接向用户展示 charset：规定HTML文档的字符编码 http-equiv：一般用于设置一些与http请求头相关的信息，例如content-Type refresh等 X-UA-Compatible：一般用于设置浏览器兼容 keywords：设置网页关键字 description：设置网页的描述内容 viewport：用于移动端的显示优化","link":"/HTML/"},{"title":"JavaScript笔记","text":"1.深拷贝和浅拷贝 浅拷贝：创建一个对象，这个对象有着原始对象的一份精确拷贝。如果属性是基本数据类型，拷贝的就是基本类型的值，如果是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象 深拷贝：将一个对象从一个内存中完整地拷贝出来，从堆内存中开辟一个新的区域存放这个新对象，新对象的修改不会影响原对象 浅拷贝实现 Object.assign() 扩展运算符(…) Array.prototype.slice() 深拷贝实现 JSON.parase(JSON.stringify(obj)) 会忽略undefined Symbol 不能序列化函数 不能解决循环引用的对象 不能正确处理 new Date() 不能处理正则 手写 123456789101112131415function deepClone(obj) { let res; if(Object.prototype.toString.call(obj).slice(8,-1) === 'Object') { res = {} } else if(Array.isArray(obj)) { res = [] } else { return obj } for(const key in obj) { res[key] = deepClone(obj[key]) } return res;} 2.跨域1.同源策略跨越的本质其实就是指两个地址不同源，同源指的是：两个URL的协议，域名和端口号都相同，则就是两个同源的URL 1234567// 非同源http://www.baidu.comhttps://www.baidu.com// 同源http://www.baidu.comhttp://www.baidu.com?query=1 同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。其主要目的是为了保护用户信息的安全，防止恶意网站窃取数据，是浏览器在Web页面层面做的安全保护 2.同源策略的表现同源策略主要的限制有三个层面：DOM层面，数据层面和网络层面 DOM层面同源策略限制了来自不同源的JavaScript脚本对当前源的DOM对象进行读和写的操作 数据层面同源策略限制了不同源站点读取当前站点的Cookie，IndexDB，LocalStorage等数据 网络层面同源策略限制了通过XMLHttpRequest等方式将站点的数据发送给不同源的站点 3.跨域分类同源策略虽然保证了浏览器的安全，但有时候我们需要访问不同源的数据等，因此有时我们需要进行跨越操作 1.DOM层面片段标识符 片段标识符的核心原理就是通过监听url中hash的改变来实现数据的传递 123456789101112131415161718192021// 父页面parentHtml.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是父页面 &lt;button id='btn'&gt;父传给子&lt;/button&gt; &lt;iframe src=&quot;./childHtml.html&quot; id=&quot;childHtmlId&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script&gt; window.onhashchange = function() { console.log(decodeURIComponent(window.location.hash)); }; document.getElementById('btn').addEventListener('click', () =&gt; { const iframeDom = document.getElementById('childHtmlId'); iframeDom.src += '#父传给子'; }); &lt;/script&gt;&lt;/html&gt; 1234567891011121314151617181920// 子页面childHtml.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是子页面 &lt;button id='btn'&gt;子传给父&lt;/button&gt; &lt;/body&gt; &lt;script&gt; window.onhashchange = function() { console.log(decodeURIComponent(window.location.hash)); }; document.getElementById('btn').addEventListener('click', () =&gt; { parent.location.href += '#子传给父'; }); &lt;/script&gt;&lt;/html&gt; window.name 浏览器窗口有window.name属性，这个属性最大的特点就是，无论是否同源，只要在同一个窗口里面，前一个网页设置的属性后一个网页就可以读取它。如果需要实现父页面和跨域的子页面之间的通信，需要一个和父页面同源的子页面作为中介，将跨域的子页面中的信息传递过来。 document.domain document.domain是存放文档的服务器主机名，可通过手动设置将其设置成当前域名或者上级域名，当具有同document.domain的页面就相当于处于同域名的服务器上，如果其域名和端口号相同，就可以实现跨越访问资源 postMessage postMessage是HTML5新增的跨文档通信API 通过监听message事件来接受数据 通过contentWindow.postMessage()函数来发生数据 123456789101112131415161718192021// 父页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是父页面 &lt;button id='btn'&gt;父传给子&lt;/button&gt; &lt;iframe src=&quot;http://127.0.0.1:5500/024/childHtml.html&quot; id=&quot;childHtmlId&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script&gt; window.addEventListener('message', function(event) { console.log('父页面接收到信息', event.data); }); document.getElementById('btn').addEventListener('click', () =&gt; { const iframeDom = document.getElementById('childHtmlId'); iframeDom.contentWindow.postMessage('我是执鸢者1', 'http://127.0.0.1:5500/024/childHtml1.html'); }); &lt;/script&gt;&lt;/html&gt; 1234567891011121314151617181920// 子页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是子页面 &lt;button id='btn'&gt;子传给父&lt;/button&gt; &lt;/body&gt; &lt;script&gt; window.addEventListener('message', function(event) { console.log('子页面接收到信息', event.data); }); document.getElementById('btn').addEventListener('click', () =&gt; { parent.postMessage('我是执鸢者2', 'http://127.0.0.1:5500/024/parentHtml1.html'); }); &lt;/script&gt;&lt;/html&gt; 2.网络层面同源策略对网络层面的限制主要在于不允许通过XMLHttpRequest等方式访问非同源站点的资源，目前主要的解决方法有三种 通过代理实现 同源策略主要是浏览器为了安全而制定的策略，而服务端之间不存在这样的限制，因此可以先将请求发送到同源的服务器上，然后通过同源服务器代理至最终服务器，从而实现跨域访问资源，比如Node中间件代理，Nginx方向代理等 NodeJS代理 123456789101112131415161718192021222324252627282930313233343536// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; { // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, { 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': '*', 'Access-Control-Allow-Headers': 'Content-Type' }) // 第二步：将请求转发给服务器 http.request( { host: '127.0.0.1', port: 4000, url: '/', method: request.method, headers: request.headers }, serverResponse =&gt; { // 第三步：收到服务器的响应 var body = '' serverResponse.on('data', chunk =&gt; { body += chunk }) serverResponse.on('end', () =&gt; { console.log('The data is ' + body) // 第四步：将响应结果转发给浏览器 response.end(body) }) } ).end()})server.listen(3000, () =&gt; { console.log('The proxyServer is running at http://localhost:3000')}) JSONP JSONP的原理其实就是利用script标签不会被同源策略限制的特点，通过监听一个回调函数，将这个回调函数的函数名作为参数发送给服务端，服务端直接运行这个函数并将数据通过形参的方式传回即可 script标签特点：src属性能够访问任何URL资源，不会受到同源策略的限制。如果访问的资源包含JavaScript代码，其会在下载后自动执行 CORS 跨域共享资源，主要的原理是服务端设置Access-Control-Allow-Origin等响应头，携带这个响应头的http请求，并不会被浏览器拦截 简单请求 请求方式仅限于GET POST HEAD Content-Type仅限于text/plain mutipart/form-data application/x-www-form-urlencoded 非简单请求 PUT DELETE方法 发送json格式 携带自定义请求头 3.原型和原型链 原型 在JavaScript中每个函数都有一个prototype属性(注意是函数，普通对象是没有的)，指向一个实例原型对象，每个对象在创建的时候，都会有一个__proto__属性关联它们构造函数的实例原型对象，这个就是该对象的原型 实例原型没有指向实例的属性，但有指向构造函数的属性，每个实例原型通过constructor属性指向对应的构造函数 原型链 当我们要读取对象上的一个属性时，JavaScript引擎会先在该对象上寻找，如果找不到，就会沿着__proto__属性到它构造函数的实例原型上寻找，若实例原型上找不到，就会沿着实例原型的原型(实例原型本质上是一个对象)去Object()这个构造函数对应的实例原型上寻找，而对象的构造函数的实例原型的__proto__属性指向null，原型链就是__proto__的检索路径 3.声明变量关键字var 使用var关键字声明的变量会被直接绑定到window对象上 12var a = 2;console.log(window.a); // 2 使用var关键字声明的变量存在变量提升，也就是说即使在声明之前输出该变量也不会报错 12console.log(a) // undefinedvar a = 2; 可以重复声明变量 123var a = 1;var a = 2;console.log(a); // 2 let和const 使用let/const关键字声明的变量不存在变量提升 12console.log(a); // Errorlet a; 使用let/const关键字声明的变量存在暂时性死区 12345let a = 2;{ console.log(a); // Error let a = 3;} 使用let/const关键字声明的变量无法重复声明 123let a = 1;let a = 2;console.log(a); // Error 使用let/const关键字声明的变量，存在块级作用域 123456let a = 1;{ let a = 2; console.log(a); // 2}console.log(a); // 1 使用const关键字声明变量时，必须指定初始值 12const a;console.log(a); // Error 4.作用域作用域，指的是变量存在的范围。在JavaScript中，一共有三种作用域，分别是全局作用域，函数作用域和块级作用域 全局作用域在全局声明的变量存在于全局作用域中 12345var a = 1;function fn() { console.log(a); // 1} 函数作用域在函数内声明的变量，无法在函数外获取 123456function fn() { var a = 1; console.log(a); // 1}fn();console.log(a); // Error 对于var关键字来说，局部变量只能在函数内部声明，在其它区块中声明，一律都是全局变量 1234if (true) { var x = 5;}console.log(x); // 5 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生变量提升现象 12345678910111213function fn() { console.log(x); // undefined if (false) { var x; }}fn();// 等同于function fn() { var x; console.log(x); // undefined} 函数本身的作用域函数本身也是一个值，也有自己的作用域，它的作用域和其它变量一样，就是声明时所在的作用域，与其运行时所在的作用域无关 123456789101112var a = 1;function x() { console.log(a);}function f() { var a = 2; x();}f() // 1 即使传入一个回调函数，其作用域也是绑定在其定义时所在的作用域 123456789101112var a = 1;function x() { console.log(a);}function f(fn) { var a = 2; fn();}f(x) // 1 同样的，如果在函数内部定义的函数，其作用域就是绑定在函数内部 12345678910111213var a = 1;function fn() { var a = 2; return function () { console.log(a); }}var x = fn();x(); // 2 5.PromisePromise是异步编程的一种解决方案，提供统一的API用来处理各种异步操作。简单来说，Promise就是一个容器，里面保存着某个未来才会结束的事件(通常是异步操作)的结果；从语法上来讲，Promise是一个对象，从它可以获取异步操作的消息。 Promise对象有两个特点： 一是对象的状态不受外界的影响。它有三种状态，pending(进行中)，fulfilled(已完成)和rejected(已失败)，只有异步操作的结果，才能决定当前是哪一种状态 二是一旦状态改变，就不会再变，Promise对象状态的改变只有两种可能：从pending变为fulfilled和从pending变为rejected Promise对象的缺点： 无法取消，一旦新建它就会立即执行。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成) 构造函数上的方法 Promise.all()：接受一个数组，数组中的每个成员都是一个Promise实例，返回一个新的Promise实例 只有成员中所有状态都变成resolve，新实例的状态才会变成resolve，只要有一个成员的状态变成reject，新实例的状态就会变成reject 如果成员有自己的catch方法，那么当该成员状态变成reject时，新实例的状态并不会变为reject Promise.allSettled() 只有所有成员的状态发生了改变，包装实例才会结束 返回一个Promise对象，对象包裹着一个对象数组，每个对象有status和value字段，如果status的值为rejected，则返回reason字段 如果成员有自己的catch方法，则不会触发allSettled()的reject状态 Promise.race() race意为赛跑，只要有一个成员的状态率先改变，那么race的状态就直接发生改变并接受那个成员的返回值 如果成员有自己的catch方法，则不会触发race状态的改变 Promise.any() 与race类似，只要有一个参数实例变成resolve状态，包装器就会变为fulfilled状态，如果所有参数实例都变成rejected状态，包装器实例就会变成rejected状态 Promise.resolve()：将一个对象转为Promise对象 参数分为四种情况，分别如下： 参数是一个Promise实例，则原封不动地返回这个实例 参数是一个thenable对象，则会将这个对象转为Promise对象，并立即执行该对象的then方法 参数不是具有then方法的对象，或根本不是对象，Promise.resolve()会返回一个新的Promise对象，并且状态为resolve 没有参数时，直接返回一个resolve状态的Promise对象 Promise.reject()：返回一个状态为rejected的Promise对象 实例上的方法 then()：是Promise实例状态发生改变时的回调，第一个参数是resolve状态的回调函数，第二个参数是rejected状态的回调函数，then方法返回值是一个Promise实例，这也是Promise可以进行链式书写的原因 catch()：catch方法是then方法第二个回调函数的别名，用于指定发生错误时的回调函数 finally()：用于指定不管Promise对象最后状态如何，都会执行的操作 6.继承 原型链继承 直接将父类的实例赋值给子类的原型对象，缺点是所有继承的属性和方法都会在子类实例对象之间共享，无法做到属性私有化 12345678910111213function Parent() { this.name = 'Parent';}Parent.prototype.getName = function() { return this.name;}function Child() {}Child.prototype = new Parent();const c = new Child();const c2 = new Child2(); 盗用构造函数继承 在子类构造函数中使用call(或apply)方法调用父类构造函数，缺点是子类无法使用父类原型对象上的属性和方法 1234567891011121314function Parent() { this.name = 'Parent';}Parent.prototype.getName = function() { return this.name;}function Child() { Parent.call(this)}const c = new Child();const c2 = new Child2(); 组合式继承 结合原型链继承和盗用构造函数继承，缺点是父类的构造函数会被实例化两次，造成性能浪费 12345678910111213141516function Parent() { this.name = 'Parent';}Parent.prototype.getName = function() { return this.name;}function Child() { // 第二次调用父类 Parent.call(this)}Child.prototype = new Parent();// 第一次调用父类Child.prototype.constructor = Child;const c = new Child();const c2 = new Child2(); 原型式继承 原型式继承可以无需明确定义构造函数而实现继承。使用Object.create()方法，对现有的普通对象进行一份浅拷贝，优点是无需调用构造函数，缺点是对象中的引用值共享同一内存，很可能造成值的篡改 12345678910const parent = { name: 'parent', age: 18, getName: function() { return this.name; }}const child1 = Object.create(parent);const child2 = Object.create(parent); 寄生式继承 和原型式继承类型，多了一个用于继承的函数，在函数中会先基于原对象创建一个新的对象，然后再增强这个新对象，最后返回新对象 1234567891011121314151617function _extend(parent) { const object = Object.create(object); object.prototype.getAge = function() { return this.age; } return object;}const parent = { name: 'parent', age: 18, getName: function() { return this.name; }}const child = _extend(parent); 寄生组合式继承 在组合继承的基础上加入寄生式继承，减少一次父类的调用 12345678910111213141516171819function _extend(parent, child) { const object = Object.create(parent.prototype); object.constructor = child; // 手动指定原型对象上的constructor指向子类 child.prototype = object;}function Parent() { this.name = 'Parent';}Parent.prototype.getName = function() { return this.name;}function Child() { Parent.call(this);}_extend(Parent, Child);const c = new Child(); 7.手写new 创建一个新对象 将该对象的原型指向构造函数的原型对象 调用call(或apply)方法，将构造函数的this指向该对象 判断构造函数的返回值是否是对象，若是则直接返回该对象，否则就返回这个创建的临时对象 123456function _new(tarent, ...rest) { const object = {}; Object.setPrototypeOf(object, target.prototype); const result = tarent.apply(object, rest); return (result instanceOf Object) ? result : object;} 8.闭包一个函数和其周围状态的引用捆绑在一起，这样的组合就是闭包，闭包让你可以在一个内层函数中，访问到外层函数的作用域。 在JavaScript中，任何闭包的使用场景基本上包含两点：创建私有变量，延长变量的生命周期 柯里化函数：柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能轻松的复用。 函数的防抖和节流 9.函数防抖和节流 防抖：一个事件在n秒后执行一次，若在n秒内被重复触发，则重新计时 12345678910111213141516171819202122232425262728293031323334353637function debounce(fn: Function,wait: number) { let timer = 0; return function(...args) { if(timer) { window.clearTimeout(timer); } timer = window.setTimeout(() =&gt; { fn.apply(this, args); }, wait) }}// 立即执行版本function debounce(fn: Function, wait: number, immdiately = false) { let timer = 0; return function (...args: unknown[]) { if (timer) { window.clearTimeout(timer); } if (immdiately) { let callNow = !timer; timer = window.setTimeout(() =&gt; { timer = 0; }, wait); if (callNow) { fn.apply(this, args); } } else { timer = window.setTimeout(() =&gt; { fn.apply(this, args); }, wait); } };} 节流：一个事件在n秒内只执行一次，若在n秒内重复触发，只有一次生效 12345678910function throttled(fn: Function, delay: number) { let timer = 0; return function(...args) { if(timer) return; timer = window.setTimeout(() =&gt; { fn.apply(this, args); timer = 0; }, delay) }} 10.async awaitasync函数是generator和Promise的语法糖，它可以让我们以同步的形式去处理异步问题，async函数返回的一定是一个Promise对象，内部可以使用await关键字，返回异步信息的结果，await关键字后面通常也是跟着一个Promise对象，也可以跟一个基本值 手写实现async awiat函数的效果 12345678910111213141516171819202122232425262728function asyncGenerator(generatorFunc) { return function () { const gen = generatorFunc.apply(this, arguments); return new Promise((resolve, reject) =&gt; { function step(key, arg) { let generatorResult; try { generatorResult = gen[key](arg); } catch (error) { reject(error) } const { value, done } = generatorResult; if (done) { return resolve(value) } else { return Promise.resolve(value).then( (val) =&gt; step('next', val), (err) =&gt; step('throw', err) ) } } step('next'); }) }} 11.异步编程的实现方案 回调函数：最常见的异步编程解决方式，缺点是多个回调函数嵌套会造成回调地狱，不利于维护 Promise：使用Promise可以将嵌套的回调函数作为链式调用，但多个then的链式调用，可能会造成代码语义不够明确 generator：generator函数可以在函数执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来，当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权转移回来。因此我们在generator内部对于异步操作的方式，可以以同步的顺序来写。只需要我们考虑何时将函数执行权转移回来。所以我们需要一个自动执行generator的机制，比如co模块等方式来实现generator的自动执行 async函数：async函数其实就是generator和promise实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个await语句时，如果语句返回一个promise对象，那么函数将会等待promise对象的状态变为resolve后再继续向下执行。因此我们可以将异步逻辑转换为同步的顺序来书写。 12.co模块的原理Generator函数在处理异步操作时，需要一种自动执行的机制，当异步操作有了结果，能够自动交回执行权，两种方法可以做到这一点： 回调函数：将异步操作包装成Thunk函数，在回调函数里面交回执行权 Promise对象，将异步操作包装成Promise对象，用then方法交回执行权 co模块其实就是将这两种自动执行权器包转成的一个模块，所以使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象 13.观察者模式和发布订阅模式 观察者模式：一个对象(观察者)订阅另一个对象(主题)，当主题被激活的时候，触发观察者里面的事件 发布订阅模式：订阅者把自己想要的事件注册到调度中心，当发布者触发事件时，由调度中心统一调度订阅者注册到调度中心的代码 14.判断数据类型的方法 typeof：可以判断除null之外的基本数据类型和函数，其余的引用数据类型全部返回object instanceof：判断某个引用数据类型是否是对应构造函数的实例 1234567891011121314151617181920212223// 手写instanceoffunction _instanceof(left, right) { // 如果是基本数据类型，则直接返回false if (typeof left !== 'object' || left === null) { return false; } // 取右侧的实例原型 let rightProto = right.prototype; // 取左侧的原型 let leftProto = Object.getPrototypeOf(left); while (true) { if (leftProto === null) { return false; } if (leftProto === rightProto) { return true; } leftProto = Object.getPrototypeOf(leftProto) }} Object.prototype.toString.call()：因为toString()是Object实例原型上的方法，而Array，Function等类型作为Object的实例，都重写了toString方法，不同的对象类型调用toString方法，返回的值是不相同的，Array返回元素组成的字符串，Function返回函数体等，因此想要返回具体的类型，必须直接调用Object实例原型上的方法 constructor：每个对象的原型都指向其构造函数的实例原型，而实例原型上的constructor属性又直接指向对应的构造函数，因此直接调用constructor可以判断该对象是否是某个构造函数的实例","link":"/JavaScript/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"前端工程化","slug":"前端工程化","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"DOM","slug":"前端/JavaScript/DOM","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/DOM/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"前端工程化","slug":"前端/前端工程化","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"pages":[]}