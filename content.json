{"posts":[{"title":"打包图片资源","text":"1.打包图片资源 webpack打包图片资源需要下载两个loader: url-loader file-loader url-loader 依赖于file-loader，在配置时只需要引入一个loader即可 1234567891011121314151617181920212223const dirs = require('./dirs');module.exports = { module: { rules: [ /** 处理图片资源，需要 url-loader file-loader */ { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [ { loader: 'url-loader', options: { limit: 5 * 1000, include: dirs.src, // 打包后的图片路径以及命名 name: 'images/[path][name].[ext]' } } ] } ] }}","link":"/webpack/5.%E6%89%93%E5%8C%85%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/"},{"title":"devServer","text":"1.devServer基本配置 开发环境下自动编译，自动打开浏览器 123456789101112131415{ module.exports = { // 开发服务器， 在开发过程中热加载项目 devServer: { // 构建后的项目运行的目录 contentBase: path.resolve(dirs.build), // 启动gzip压缩 compress: true, // 端口号 port: 8100, // 自动打开浏览器 open: false, } }}","link":"/webpack/6.devServer/"},{"title":"打包HTML资源","text":"1.打包html文件 下载plugin: html-webpack-plugin 使用 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { plugins: [ new HtmlWebpackPlugin({ // 复制指定的html文件，并自动引入打包后的所有资源 template: path.resolve(__dirname, '../src/index.html') }), ]}","link":"/webpack/4.%E6%89%93%E5%8C%85html%E8%B5%84%E6%BA%90/"},{"title":"打包样式资源","text":"1.打包样式资源 常用的样式资源有 css less (sa|sc)ss，这些分别需要引入不同的loader 固定依赖： style-loader css-loader前者将打包好的资源引入到根文件的&lt;head&gt;&lt;/head&gt;标签内，后者将css样式文件编译成commjs可识别的字符串 引入less： less less-loader 引入(sa|sc)ss：sass sass-loader 1234567891011121314151617181920212223242526272829303132const { resolve } = require('path');module.exports = { ... // loader配置 module: { rules: [ { // 匹配哪些文件 test: /\\.css$/, // 使用哪些loader 执行顺序是数组降序(从下往上) use: [ // 创建style标签，将js中的样式资源插入到资源中进行，并将标签添加到页面head标签中 'style-loader', // 将 css文件变成commonjs模块加载到js中，里面的内容是字符串 'css-loader' ] }, /** 支持引入less 需要 less和less-loader依赖 */ { test: /\\.less$/, use: ['style-loader','css-loader','less-loader'] }, /** 支持引入(sa|sc)ss 需要sass和sass-loader依赖 */ { test: /\\.(sa|sc)ss$/, use: ['style-loader','css-loader','sass-loader'] } ] }, ...} 2.支持css module写法 只需在对应的css-loader中加入modules配置即可 12345678910111213141516171819202122232425262728293031const { resolve } = require('path');module.exports = { ... // loader配置 module: { rules: [ ... /** 支持引入(sa|sc)ss 需要sass和sass-loader依赖 */ { test: /\\.(sa|sc)ss$/, use: [ 'style-loader', { loader: 'css-loader', options: { importLoaders: true, // 支持 css module写法 modules: { localIdentName: '[local]__[name]-[hash:base64:4]' } } }, 'sass-loader' ] } ... ] }, ...}","link":"/webpack/3.%E6%89%93%E5%8C%85%E6%A0%B7%E5%BC%8F%E8%B5%84%E6%BA%90/"},{"title":"Webpack简介","text":"1.简介 Webpack是一种前端资源构建工具，一个静态模块打包器(module bundler) 在Webpack看来，前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理 它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle) 2.原理当前端需要引入模块(js文件，样式资源，图片，字体等其他资源)时，webpack会将这些资源交给构建工具去处理，构建工具会从webpack指定的入口文件作为起点开始打包，会将每一个模块记录好，形成依赖关系结构图，然后根据依赖关系图的先后顺序将这些模块引入，形成一个chunk代码块，最后将这个代码块中的模块(ts,less,scss…)进行编译打包，形成浏览器所能识别的文件，最后将处理好的资源进行输出，输出的文件称为bundle 3.五个核心概念 Entry 入口(Entry)指示，Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图 Output 输出(Output)指示Webpack打包后的资源bundles输出到哪里去，以及如何命名 Loader(loader放在module模块的rules数组中) Loader让Webpack能够去处理那些非JavaScript文件(Webpack自身只能理解JavaScript) Plugins 插件(Plugins)可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。 Mode 打包的模式(development production)","link":"/webpack/1.webpack%E7%AE%80%E4%BB%8B/"},{"title":"Webpack初始化","text":"1.初始化webpack12$ yarn init -y$ yarn webpack webpack-cli webpack-dev-server -D package.json 1234&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack server --config ./scripts/webpack.config.js --mode=development&quot;, // 开发时的启动服务命令 &quot;build&quot;: &quot;webpack --config ./scripts/webpack.config.js --mode=production&quot; // 编译命令}, webpack.config.js**(注意webpack配置文件的路径，需要和package.json中启动命令的路径对应)** 123456789101112131415161718// /script/webpack.config.jsconst path = require('path');module.exports = { // 入口 entry: path.resolve(__dirname, '../src/index.js'), // 出口 output: { filename: 'index.js', path: path.resolve(__dirname, '../dist'), }, // loader module: [], // plugins plugins: [],} 2.配置目录文件 在scripts文件夹中新建dirs.js，此文件中专门用于存储各种需要用到的路径 123456789101112131415161718192021const path = require('path');const root = path.resolve(__dirname, '../../');const dirs = { // 根目录 root, // 源码目录 src: path.resolve(root, './src'), // 输出目录 dist: path.resolve(root, './dist'), // 第三方库 lib: path.resolve(root, './lib'), // 构建脚本目录 build: path.resolve(root, './webpack'), // modules modules: path.resolve(root, './node_modules'), // package package: path.resolve(root, './package.json')};module.exports = dirs;","link":"/webpack/2.%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"CSS笔记","text":"1.FlexFlex布局是将元素进行水平或者垂直排列的一维布局方案，通过设置display为flex或inline-flex进行开启。采用Flex布局的容器，默认存在两根轴，水平的主轴和垂直的交叉轴，容器内的子元素默认成为容器的成员，称为项目。主轴的开始位置与边框的交叉点称为main start，结束位置称为end start，交叉轴的开始位置叫cross start，结束位置叫cross end Flex项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 Flex属性分为两部分，一部分作于于容器，另一部分作于于容器内的项目 容器属性 属性 功能 flex-direction 决定主轴的方向 `row flex-wrap 决定主轴上的项目排列不下时，是否换行排列 `nowrap flex-flow flex-direction和flex-wrap的简写形式。默认值：row nowrap justify-content 定义了项目在主轴上的对齐方式和额外空间的分配方式 `flex-start align-item 决定项目在交叉轴上的对齐方式 `stretch align-content 定义了多根轴线的对齐方式，设置了flex-wrap属性为wrap后align-content属性才能生效 `stretch 项目属性 属性 功能 order 定义项目的排列顺序，数值越小，排列越靠前，默认为0，可以是负数 flex-grow 扩展规则，规定flex容器中剩余的空间应该拿出多少分配给项目，默认为0，最大值是1，超过1按照1来扩展 flex-shrink 规定了flex项目的收缩规则，flex项目仅在默认宽度之和大于容器的时候才会发生收缩，默认值是1 flex-basis 指定了子项在容器主轴方向上的初始大小，优先级高于自身的宽度width，默认值是auto flex 该属性是flex-grow flex-shrink flex-basis的简写，默认值是0 1 auto，后两个值可选 align-self 该属性用于设置单个项目在交叉轴的对齐方式，可覆盖align-item属性 `stretch 2.CSS选择器 选择器 格式 优先级权重 id选择器 #id 100 类选择器 #class 10 伪类选择器 li:last-child 10 属性选择器 a[href=”aaa”] 10 标签选择器 div 1 伪元素选择器 li::after 1 相邻兄弟选择器 h1+p 0 子元素选择器 ul &gt; li 0 后代选择器 li a 0 通配符选择器 * 0 对于样式的优先级： !important：优先级最高 内联样式：1000 id选择器：100 类，伪类，属性选择器：10 元素选择器，伪元素选择器：1 通配符选择器，后代选择器，兄弟选择器：0 3.规则 @namespace：告诉CSS引擎必须考虑XML命名空间 @media：媒体查询 @page：描述打印文档时布局的变化 @font-face：描述将下载的外部字体 @keyframes：描述CSS动画关键帧 @import：用于告诉CSS引擎引入一个外部样式表 link和@import的区别 link是HTML标签，除了能导入CSS外，还可以导入其他资源，比如图片，脚本和字体等；而@import是CSS语法，只能用来导入CSS link导入的样式会在页面加载时同时加载，@import导入的样式需要等页面加载完成后再加载 link没有兼容性问题，@import不兼容ie5以下 link可以通过js操作访问 4.继承性 可继承属性：font-family font-style font-size font-weight color 不可继承属性：weigth height margin padding 5.清除浮动浮动的元素会脱离文档流，导致父元素高度塌陷 通过BFC清除浮动 123.parent { overflow: hidden;} 通过clear清除浮动 12345678.clearfix { zoom: 1;}.clearfix::after { content: &quot;&quot;; display: block; clear: both;} 6.消除浏览器默认样式12345678910111213141516171819202122232425262728293031323334353637383940414243html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header, hgroup,menu, nav, output, ruby, section, summary,time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;}/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section { display: block;}body { line-height: 1;}ol, ul { list-style: none;}blockquote, q { quotes: none;}blockquote:before, blockquote:after,q:before, q:after { content: ''; content: none;}table { border-collapse: collapse; border-spacing: 0;} 7.长文本处理 字符超出部分换行 1overflow-wrap: break-word; 字符超出部分使用连接字符 1hyphens: auto; 单行文本超出省略 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 多行文本超出省略 12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box-;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 8.line-height和height的区别height就是元素的高度值 line-height是每一行文字的高度，如果文字换行，则整个格子高度会增大 9.BFC块级格式化上下文，它是一个独立容器，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。 创建规则： 根元素 float不是none的元素 绝对定位的元素(position为absolute或fixed) display取值为inline-block table-cell table-caption inline-flex之一的元素 overflow不是visible的元素 作用： 清除浮动 阻止父子元素的margin折叠 10.居中方式单行的文本、inline 或 inline-block 元素 水平居中 1text-align: center 垂直居中 123456789.single-line { padding-top: 10px; padding-bottom: 10px;}// 或.single-line { height: 100px; line-height: 100px;} 固定宽高的块级盒子 absolute+负margin 1234567891011.parent { position: relative;}.child { width: 100px; height: 100px; position: absolute; left: 50%; top: 50%; margin: -50px 0 0 -50px} absolute + margin auto 12345678910111213.parent { position: relative;}.child { width: 100px; height: 100px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;} absolute + calc 12345678910.parent { position: relative;}.child { width: 100px; height: 100px; position: absolute; left: calc(50% - 50px); top: calc(50% - 50px)} 不固定宽高的块级盒子 absolute + transform 123456789.praent { position: relative;}.child { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%)} line-height + vertical-align 123456789.parent { line-height: 150px; text-aligin: center;}.child { display: inline-block; line-height: initial; vertical-align: middle;} writing-mode 12345678910111213.parent { writing-mode: vertical-lr; text-align: center;}.middle { display: inline-block; writing-mode: horizontal-tb; width: 100%}.child { display: inline-block;} table-cell 12345678.parent { display: table-cell; vertical-aligin:middle; text-align: center;}.child { display: inline-block;} flex 12345.parent { display: flex; justify-content: center; align-items: center} grid 1234567.parent { display: grid;}.child { justify-self: center; align-self: center;} 11.常用布局双栏布局(边栏定宽主栏自适应) float+overflow(BFC原理) 1234567aside { float: left; width: 200px}main { overflow: hidden;} float+margin 1234567aside { float: left; width: 200px;}main { margin-left:200px} flex 123456789layout { display: flex;}aside { width:200px}main { flex-grow: 1} grid 1234layout { display: grid; grid-template-columns: 200px auto;} 三栏布局(两侧定宽主栏自适应) 圣杯布局 123456789101112131415161718192021layout { padding: 0 200px;}main { float: left; width: 100%;}aside { float: left; width: 200px;}left { position: relative; left: -200px; margin-left: -100%;}right { position: relative; right: -200px; margin-left: -200px} 双飞翼布局 1234567891011121314151617main { float: left; width: 100%;}.inner { margin: 0 200px;}aside { float: left; width: 200px;}.left { margin-left: -100%;}.right { margin-left: -200px;} float+overflow 123456789101112aside { width: 200px;}left { float: left;}right { float: right;}main { overflow: hidden;} flex 123456789layout { display: flex;}aside { width: 200px;}main { flex-grow: 1;} grid 1234layout { display: grid; grid-template-columns: 200px auto 200px} 12.Grid给&lt;div&gt;这类块状元素元素设置display:grid或者给&lt;span&gt;这类内联元素设置display:inline-grid，Grid布局即创建 此时该div就是grid容器，其子元素称为grid子项 容器属性 子项属性 grid-template-columns grid-column-start grid-template-rows grid-column-end grid-template-areas grid-row-start grid-template grid-row-end grid-column-gap grid-column grid-gap grid-row justify-items grid-area align-items justify-self place-items align-self justify-content place-self align-content place-content grid-auto-columns grid-auto-rows grid-auto-flow grid 13.nth-of-type和nth-child的区别 nth-of-type：:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素。n 可以是数字、关键词或公式 12345678910111213141516&lt;style&gt;div&gt;p:nth-of-type(2){ color:red;}&lt;/style&gt;&lt;div&gt; &lt;p&gt;我是第1个段落&lt;/p&gt; &lt;p&gt;我是第2个段落&lt;/p&gt;&lt;!--符合条件：1、是特定元素类型&lt;p&gt;，2、是父元素&lt;div&gt;的第二个&lt;p&gt;元素。这里被选择，会变成红色--&gt; &lt;p&gt;我是第3个段落&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;我是第1个段落&lt;/p&gt; &lt;blockquote&gt;第1个引用&lt;/blockquote&gt; &lt;p&gt;我是第2个段落&lt;/p&gt;&lt;!--符合条件：1、是特定元素类型&lt;p&gt;，2、是父元素&lt;div&gt;的第二个&lt;p&gt;元素。这里被选择，会变成红色--&gt; &lt;p&gt;我是第3个段落&lt;/p&gt;&lt;/div&gt; nth-child：:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型。n 可以是数字、关键词或公式。 注意：如果第 N 个子元素与选择的元素类型不同则样式无效！ 123456789101112131415&lt;style&gt;div&gt;p:nth-child(2){ color:red;}&lt;/style&gt;&lt;div&gt; &lt;p&gt;我是第1个段落&lt;/p&gt; &lt;p&gt;我是第2个段落&lt;/p&gt;&lt;!--符合条件：1、是&lt;p&gt;元素，2、父元素&lt;div&gt;的第二个元素。这里被选择，会变成红色。--&gt; &lt;p&gt;我是第3个段落&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;我是第1个段落&lt;/p&gt; &lt;span&gt;我是第1个文本&lt;/span&gt;&lt;!--不符合条件：不是&lt;p&gt;元素，没有被选择--&gt; &lt;p&gt;我是第2个段落&lt;/p&gt;&lt;/div&gt;","link":"/CSS/"},{"title":"HTML笔记","text":"1.HTML XHTML XML的区别 HTML: 超文本标记语言 XHTML：可扩展的超文本标记语言，基于XML，作用与HTML类似，但语法更加严格 XML：可扩展标记语言，主要用于存储数据和结构 XHTML标签名必须手写，元素必须以双标签形式存在，元素必须被正确嵌套，元素必须有根元素 2.HTML5和HTML的区别HTML5是HTML的新标准，其主要目标是无需任何额外的插件就可以传输所有内容，它包括了动画，视频等丰富的图形界面 从文档声明 HTML的文档声明是很长的一段代码，而HTML5 只需要在文档头部使用&lt;!DOCTYPE html&gt;标签即可声明 从语义结构 HTML4.0没有体现语义化的标签，而HTML5加入了很多语义化标签，如header main footer acticle等 3.DOCTYPE标签&lt;!DOCTYPE html&gt;的作用就是让浏览器进入标准模式，使用最新的W3C标准来解析渲染页面，若文档头部不写则浏览器会使用兼容模式来解析和渲染页面 标准模式：指浏览器按照W3C标准解析文档 兼容模式：浏览器通常会为了兼容老旧站点而不使用最新的W3C标准来解析文档 4.块元素 行内元素 行内块元素 块元素 独占一行 可以设置宽高，不设置宽度情况下默认继承父元素的宽度 常见的块元素：div p h1~h6 ul ol table form 行内元素 相邻的元素会排列在同一行 无法设置宽高，其大小由内容决定 可以设置水平方向的margin padding的值，但无法使用auto属性居中 常见的行内元素：span a strong b em i label等 行内块元素 不独占一行 可以设置宽高，默认大小由内容决定 可以设置margin padding等属性，但无法使用auto属性居中 常见的行内块元素：button input img iframe等 5.Link和@import导入样式的区别 link是HTML标签，@import用于CSS文件中导入另一个CSS文件 link标签在页面加载时就会被加载，@import引用会等到页面加载完在加载 link标签权重高于@import引用 @import引用有兼容性问题，而link标签无兼容问题 6.label标签label标签用来定义表单控制间的关系，当用户与该标签发生交互的时候，浏览器会自动对焦到绑定的表单标签上 12&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;&lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt; 7.标签上的title和alt属性的区别title属性用于为该元素设置建议性信息，在鼠标移到该元素上面时会显示 alt属性用于在图片未能正常显示时给予文字说明 8.语义化的好处 便于开发者阅读和写出更加优雅的代码 有利于SEO：让浏览器爬虫更好地解析，爬虫依赖于标签来确定上下文和各个关键字的权重 方便其它设备(如移动设备)解析文档 9.iframe的优缺点 优点 跨域通信 无刷新文件上传 可以用于加载一些第三方图标或广告等 缺点 会阻塞主页面onload事件 无法被一些搜索引擎识别 会产生很多页面，不利于管理 10.src与href的区别 href: 指向网络资源所在的位置，并建立该资源和当前元素(锚点)或当前文档(链接)之间的链路，用于超链接 src：指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片，iframe等。 11.HTML5新特性 Canvas SVG：用于绘图的元素 video audio:用于播放视频和音频的媒体 Drag，Drop：用于拖拽的元素 Geolocation：用于获取地理位置 LocalStorage SessionStorage：用于本地离线存储 web Worker：运行在后台的JavaScript脚本 webSocket：基于TCP的全双工通信协议 语义化标签：header main footer nav section等 新的表单控件：date time url email search等 12.标准模式和怪异模式的区别 盒模型：标准模式中一个元素的宽高是它内容的宽高，怪异模式下元素的宽高还包含了padding和border 行内元素宽高：标准模式下行内元素无法设置宽高，怪异模式下则可以 水平居中：标准模式下margin: 0 auto可以使元素水平居中，怪异模式下则不行 13.标准盒模型和怪异盒模型HTML中每一个元素都可以看作一个盒模型，一个盒模型由content + padding + border + margin组成 标准盒模型：设置盒模型的width和height属性其实是设置内容的宽高，盒模型的宽度等于width + padding + border + margin 怪异盒模型：设置盒模型的的width和height属性其实是设置了content + padding + border的值。例如设置width为100px，padding为10px，那么此时内容区域的宽度只有80px(100 - 20 * 2) box-sizing：content-box|border-box|inherit 14.前端结构样式和行为分离结构(HTML)相当于人的骨架，样式(CSS)相当于人的装饰，行为(JavaScript)相当于人的动作，前端将这三者分离开，各自负责各自的内容，各部分可以通过引用进行使用 在分离的基础上，我们需要做到代码的精简，重用，有序 分离的好处 代码分离，利于团队的开发和后期的维护； 减少维护成本，提高可读性和更好的兼容性； 15.如何对网站的文件和资源进行优化 文件合并，减少http请求 文件压缩（gzip压缩需要的css和js文件） 使用缓存 使用cdn托管资源 网站外链接优化 meta标签优化,设置title keywords description优化等 16.渐进增强和优雅降级的区别 渐进增强：优先考虑低版本浏览器的兼容，在保证基本功能可以使用的情况下，再考虑对高级浏览器进行效果，交互等方面的优化 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 17.为什么HTML5不需要DTDHTML5中没有使用SGML或XHTML，不需要参考DTD 18.form表单关闭自动完成(自动联想)功能设置autocomplete=off 19.几种图片格式的区别 png：图片背景透明，可以支持很多颜色 jpg：图片背景不透明，静态图，可压缩 gif：动态图，支持颜色较少 20.meta标签meta标签常用于定义页面的说明，关键字等元数据，这些数据一般服务于浏览器，搜索引擎，并不会直接向用户展示 charset：规定HTML文档的字符编码 http-equiv：一般用于设置一些与http请求头相关的信息，例如content-Type refresh等 X-UA-Compatible：一般用于设置浏览器兼容 keywords：设置网页关键字 description：设置网页的描述内容 viewport：用于移动端的显示优化","link":"/HTML/"},{"title":"JavaScript笔记","text":"1.深拷贝和浅拷贝 浅拷贝：创建一个对象，这个对象有着原始对象的一份精确拷贝。如果属性是基本数据类型，拷贝的就是基本类型的值，如果是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象 深拷贝：将一个对象从一个内存中完整地拷贝出来，从堆内存中开辟一个新的区域存放这个新对象，新对象的修改不会影响原对象 浅拷贝实现 Object.assign() 扩展运算符(…) Array.prototype.slice() 深拷贝实现 JSON.parase(JSON.stringify(obj)) 会忽略undefined Symbol 不能序列化函数 不能解决循环引用的对象 不能正确处理 new Date() 不能处理正则 手写 123456789101112131415function deepClone(obj) { let res; if(Object.prototype.toString.call(obj).slice(8,-1) === 'Object') { res = {} } else if(Array.isArray(obj)) { res = [] } else { return obj } for(const key in obj) { res[key] = deepClone(obj[key]) } return res;} 2.跨域1.同源策略跨越的本质其实就是指两个地址不同源，同源指的是：两个URL的协议，域名和端口号都相同，则就是两个同源的URL 1234567// 非同源http://www.baidu.comhttps://www.baidu.com// 同源http://www.baidu.comhttp://www.baidu.com?query=1 同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。其主要目的是为了保护用户信息的安全，防止恶意网站窃取数据，是浏览器在Web页面层面做的安全保护 2.同源策略的表现同源策略主要的限制有三个层面：DOM层面，数据层面和网络层面 DOM层面同源策略限制了来自不同源的JavaScript脚本对当前源的DOM对象进行读和写的操作 数据层面同源策略限制了不同源站点读取当前站点的Cookie，IndexDB，LocalStorage等数据 网络层面同源策略限制了通过XMLHttpRequest等方式将站点的数据发送给不同源的站点 3.跨域分类同源策略虽然保证了浏览器的安全，但有时候我们需要访问不同源的数据等，因此有时我们需要进行跨越操作 1.DOM层面片段标识符 片段标识符的核心原理就是通过监听url中hash的改变来实现数据的传递 123456789101112131415161718192021// 父页面parentHtml.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是父页面 &lt;button id='btn'&gt;父传给子&lt;/button&gt; &lt;iframe src=&quot;./childHtml.html&quot; id=&quot;childHtmlId&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script&gt; window.onhashchange = function() { console.log(decodeURIComponent(window.location.hash)); }; document.getElementById('btn').addEventListener('click', () =&gt; { const iframeDom = document.getElementById('childHtmlId'); iframeDom.src += '#父传给子'; }); &lt;/script&gt;&lt;/html&gt; 1234567891011121314151617181920// 子页面childHtml.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是子页面 &lt;button id='btn'&gt;子传给父&lt;/button&gt; &lt;/body&gt; &lt;script&gt; window.onhashchange = function() { console.log(decodeURIComponent(window.location.hash)); }; document.getElementById('btn').addEventListener('click', () =&gt; { parent.location.href += '#子传给父'; }); &lt;/script&gt;&lt;/html&gt; window.name 浏览器窗口有window.name属性，这个属性最大的特点就是，无论是否同源，只要在同一个窗口里面，前一个网页设置的属性后一个网页就可以读取它。如果需要实现父页面和跨域的子页面之间的通信，需要一个和父页面同源的子页面作为中介，将跨域的子页面中的信息传递过来。 document.domain document.domain是存放文档的服务器主机名，可通过手动设置将其设置成当前域名或者上级域名，当具有同document.domain的页面就相当于处于同域名的服务器上，如果其域名和端口号相同，就可以实现跨越访问资源 postMessage postMessage是HTML5新增的跨文档通信API 通过监听message事件来接受数据 通过contentWindow.postMessage()函数来发生数据 123456789101112131415161718192021// 父页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是父页面 &lt;button id='btn'&gt;父传给子&lt;/button&gt; &lt;iframe src=&quot;http://127.0.0.1:5500/024/childHtml.html&quot; id=&quot;childHtmlId&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script&gt; window.addEventListener('message', function(event) { console.log('父页面接收到信息', event.data); }); document.getElementById('btn').addEventListener('click', () =&gt; { const iframeDom = document.getElementById('childHtmlId'); iframeDom.contentWindow.postMessage('我是执鸢者1', 'http://127.0.0.1:5500/024/childHtml1.html'); }); &lt;/script&gt;&lt;/html&gt; 1234567891011121314151617181920// 子页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是子页面 &lt;button id='btn'&gt;子传给父&lt;/button&gt; &lt;/body&gt; &lt;script&gt; window.addEventListener('message', function(event) { console.log('子页面接收到信息', event.data); }); document.getElementById('btn').addEventListener('click', () =&gt; { parent.postMessage('我是执鸢者2', 'http://127.0.0.1:5500/024/parentHtml1.html'); }); &lt;/script&gt;&lt;/html&gt; 2.网络层面同源策略对网络层面的限制主要在于不允许通过XMLHttpRequest等方式访问非同源站点的资源，目前主要的解决方法有三种 通过代理实现 同源策略主要是浏览器为了安全而制定的策略，而服务端之间不存在这样的限制，因此可以先将请求发送到同源的服务器上，然后通过同源服务器代理至最终服务器，从而实现跨域访问资源，比如Node中间件代理，Nginx方向代理等 NodeJS代理 123456789101112131415161718192021222324252627282930313233343536// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; { // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, { 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': '*', 'Access-Control-Allow-Headers': 'Content-Type' }) // 第二步：将请求转发给服务器 http.request( { host: '127.0.0.1', port: 4000, url: '/', method: request.method, headers: request.headers }, serverResponse =&gt; { // 第三步：收到服务器的响应 var body = '' serverResponse.on('data', chunk =&gt; { body += chunk }) serverResponse.on('end', () =&gt; { console.log('The data is ' + body) // 第四步：将响应结果转发给浏览器 response.end(body) }) } ).end()})server.listen(3000, () =&gt; { console.log('The proxyServer is running at http://localhost:3000')}) JSONP JSONP的原理其实就是利用script标签不会被同源策略限制的特点，通过监听一个回调函数，将这个回调函数的函数名作为参数发送给服务端，服务端直接运行这个函数并将数据通过形参的方式传回即可 script标签特点：src属性能够访问任何URL资源，不会受到同源策略的限制。如果访问的资源包含JavaScript代码，其会在下载后自动执行 CORS 跨域共享资源，主要的原理是服务端设置Access-Control-Allow-Origin等响应头，携带这个响应头的http请求，并不会被浏览器拦截 简单请求 请求方式仅限于GET POST HEAD Content-Type仅限于text/plain mutipart/form-data application/x-www-form-urlencoded 非简单请求 PUT DELETE方法 发送json格式 携带自定义请求头 3.原型和原型链 原型 在JavaScript中每个函数都有一个prototype属性(注意是函数，普通对象是没有的)，指向一个实例原型对象，每个对象在创建的时候，都会有一个__proto__属性关联它们构造函数的实例原型对象，这个就是该对象的原型 实例原型没有指向实例的属性，但有指向构造函数的属性，每个实例原型通过constructor属性指向对应的构造函数 原型链 当我们要读取对象上的一个属性时，JavaScript引擎会先在该对象上寻找，如果找不到，就会沿着__proto__属性到它构造函数的实例原型上寻找，若实例原型上找不到，就会沿着实例原型的原型(实例原型本质上是一个对象)去Object()这个构造函数对应的实例原型上寻找，而对象的构造函数的实例原型的__proto__属性指向null，原型链就是__proto__的检索路径 3.声明变量关键字var 使用var关键字声明的变量会被直接绑定到window对象上 12var a = 2;console.log(window.a); // 2 使用var关键字声明的变量存在变量提升，也就是说即使在声明之前输出该变量也不会报错 12console.log(a) // undefinedvar a = 2; 可以重复声明变量 123var a = 1;var a = 2;console.log(a); // 2 let和const 使用let/const关键字声明的变量不存在变量提升 12console.log(a); // Errorlet a; 使用let/const关键字声明的变量存在暂时性死区 12345let a = 2;{ console.log(a); // Error let a = 3;} 使用let/const关键字声明的变量无法重复声明 123let a = 1;let a = 2;console.log(a); // Error 使用let/const关键字声明的变量，存在块级作用域 123456let a = 1;{ let a = 2; console.log(a); // 2}console.log(a); // 1 使用const关键字声明变量时，必须指定初始值 12const a;console.log(a); // Error 4.作用域作用域，指的是变量存在的范围。在JavaScript中，一共有三种作用域，分别是全局作用域，函数作用域和块级作用域 全局作用域在全局声明的变量存在于全局作用域中 12345var a = 1;function fn() { console.log(a); // 1} 函数作用域在函数内声明的变量，无法在函数外获取 123456function fn() { var a = 1; console.log(a); // 1}fn();console.log(a); // Error 对于var关键字来说，局部变量只能在函数内部声明，在其它区块中声明，一律都是全局变量 1234if (true) { var x = 5;}console.log(x); // 5 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生变量提升现象 12345678910111213function fn() { console.log(x); // undefined if (false) { var x; }}fn();// 等同于function fn() { var x; console.log(x); // undefined} 函数本身的作用域函数本身也是一个值，也有自己的作用域，它的作用域和其它变量一样，就是声明时所在的作用域，与其运行时所在的作用域无关 123456789101112var a = 1;function x() { console.log(a);}function f() { var a = 2; x();}f() // 1 即使传入一个回调函数，其作用域也是绑定在其定义时所在的作用域 123456789101112var a = 1;function x() { console.log(a);}function f(fn) { var a = 2; fn();}f(x) // 1 同样的，如果在函数内部定义的函数，其作用域就是绑定在函数内部 12345678910111213var a = 1;function fn() { var a = 2; return function () { console.log(a); }}var x = fn();x(); // 2 5.PromisePromise是异步编程的一种解决方案，提供统一的API用来处理各种异步操作。简单来说，Promise就是一个容器，里面保存着某个未来才会结束的事件(通常是异步操作)的结果；从语法上来讲，Promise是一个对象，从它可以获取异步操作的消息。 Promise对象有两个特点： 一是对象的状态不受外界的影响。它有三种状态，pending(进行中)，fulfilled(已完成)和rejected(已失败)，只有异步操作的结果，才能决定当前是哪一种状态 二是一旦状态改变，就不会再变，Promise对象状态的改变只有两种可能：从pending变为fulfilled和从pending变为rejected Promise对象的缺点： 无法取消，一旦新建它就会立即执行。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成) 构造函数上的方法 Promise.all()：接受一个数组，数组中的每个成员都是一个Promise实例，返回一个新的Promise实例 只有成员中所有状态都变成resolve，新实例的状态才会变成resolve，只要有一个成员的状态变成reject，新实例的状态就会变成reject 如果成员有自己的catch方法，那么当该成员状态变成reject时，新实例的状态并不会变为reject Promise.allSettled() 只有所有成员的状态发生了改变，包装实例才会结束 返回一个Promise对象，对象包裹着一个对象数组，每个对象有status和value字段，如果status的值为rejected，则返回reason字段 如果成员有自己的catch方法，则不会触发allSettled()的reject状态 Promise.race() race意为赛跑，只要有一个成员的状态率先改变，那么race的状态就直接发生改变并接受那个成员的返回值 如果成员有自己的catch方法，则不会触发race状态的改变 Promise.any() 与race类似，只要有一个参数实例变成resolve状态，包装器就会变为fulfilled状态，如果所有参数实例都变成rejected状态，包装器实例就会变成rejected状态 Promise.resolve()：将一个对象转为Promise对象 参数分为四种情况，分别如下： 参数是一个Promise实例，则原封不动地返回这个实例 参数是一个thenable对象，则会将这个对象转为Promise对象，并立即执行该对象的then方法 参数不是具有then方法的对象，或根本不是对象，Promise.resolve()会返回一个新的Promise对象，并且状态为resolve 没有参数时，直接返回一个resolve状态的Promise对象 Promise.reject()：返回一个状态为rejected的Promise对象 实例上的方法 then()：是Promise实例状态发生改变时的回调，第一个参数是resolve状态的回调函数，第二个参数是rejected状态的回调函数，then方法返回值是一个Promise实例，这也是Promise可以进行链式书写的原因 catch()：catch方法是then方法第二个回调函数的别名，用于指定发生错误时的回调函数 finally()：用于指定不管Promise对象最后状态如何，都会执行的操作 6.继承 原型链继承 直接将父类的实例赋值给子类的原型对象，缺点是所有继承的属性和方法都会在子类实例对象之间共享，无法做到属性私有化 12345678910111213function Parent() { this.name = 'Parent';}Parent.prototype.getName = function() { return this.name;}function Child() {}Child.prototype = new Parent();const c = new Child();const c2 = new Child2(); 盗用构造函数继承 在子类构造函数中使用call(或apply)方法调用父类构造函数，缺点是子类无法使用父类原型对象上的属性和方法 1234567891011121314function Parent() { this.name = 'Parent';}Parent.prototype.getName = function() { return this.name;}function Child() { Parent.call(this)}const c = new Child();const c2 = new Child2(); 组合式继承 结合原型链继承和盗用构造函数继承，缺点是父类的构造函数会被实例化两次，造成性能浪费 12345678910111213141516function Parent() { this.name = 'Parent';}Parent.prototype.getName = function() { return this.name;}function Child() { // 第二次调用父类 Parent.call(this)}Child.prototype = new Parent();// 第一次调用父类Child.prototype.constructor = Child;const c = new Child();const c2 = new Child2(); 原型式继承 原型式继承可以无需明确定义构造函数而实现继承。使用Object.create()方法，对现有的普通对象进行一份浅拷贝，优点是无需调用构造函数，缺点是对象中的引用值共享同一内存，很可能造成值的篡改 12345678910const parent = { name: 'parent', age: 18, getName: function() { return this.name; }}const child1 = Object.create(parent);const child2 = Object.create(parent); 寄生式继承 和原型式继承类型，多了一个用于继承的函数，在函数中会先基于原对象创建一个新的对象，然后再增强这个新对象，最后返回新对象 1234567891011121314151617function _extend(parent) { const object = Object.create(object); object.prototype.getAge = function() { return this.age; } return object;}const parent = { name: 'parent', age: 18, getName: function() { return this.name; }}const child = _extend(parent); 寄生组合式继承 在组合继承的基础上加入寄生式继承，减少一次父类的调用 12345678910111213141516171819function _extend(parent, child) { const object = Object.create(parent.prototype); object.constructor = child; // 手动指定原型对象上的constructor指向子类 child.prototype = object;}function Parent() { this.name = 'Parent';}Parent.prototype.getName = function() { return this.name;}function Child() { Parent.call(this);}_extend(Parent, Child);const c = new Child(); 7.手写new 创建一个新对象 将该对象的原型指向构造函数的原型对象 调用call(或apply)方法，将构造函数的this指向该对象 判断构造函数的返回值是否是对象，若是则直接返回该对象，否则就返回这个创建的临时对象 123456function _new(tarent, ...rest) { const object = {}; Object.setPrototypeOf(object, target.prototype); const result = tarent.apply(object, rest); return (result instanceOf Object) ? result : object;} 8.闭包一个函数和其周围状态的引用捆绑在一起，这样的组合就是闭包，闭包让你可以在一个内层函数中，访问到外层函数的作用域。 在JavaScript中，任何闭包的使用场景基本上包含两点：创建私有变量，延长变量的生命周期 柯里化函数：柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能轻松的复用。 函数的防抖和节流 9.函数防抖和节流 防抖：一个事件在n秒后执行一次，若在n秒内被重复触发，则重新计时 12345678910111213141516171819202122232425262728293031323334353637function debounce(fn: Function,wait: number) { let timer = 0; return function(...args) { if(timer) { window.clearTimeout(timer); } timer = window.setTimeout(() =&gt; { fn.apply(this, args); }, wait) }}// 立即执行版本function debounce(fn: Function, wait: number, immdiately = false) { let timer = 0; return function (...args: unknown[]) { if (timer) { window.clearTimeout(timer); } if (immdiately) { let callNow = !timer; timer = window.setTimeout(() =&gt; { timer = 0; }, wait); if (callNow) { fn.apply(this, args); } } else { timer = window.setTimeout(() =&gt; { fn.apply(this, args); }, wait); } };} 节流：一个事件在n秒内只执行一次，若在n秒内重复触发，只有一次生效 12345678910function throttled(fn: Function, delay: number) { let timer = 0; return function(...args) { if(timer) return; timer = window.setTimeout(() =&gt; { fn.apply(this, args); timer = 0; }, delay) }} 10.async awaitasync函数是generator和Promise的语法糖，它可以让我们以同步的形式去处理异步问题，async函数返回的一定是一个Promise对象，内部可以使用await关键字，返回异步信息的结果，await关键字后面通常也是跟着一个Promise对象，也可以跟一个基本值 手写实现async awiat函数的效果 12345678910111213141516171819202122232425262728function asyncGenerator(generatorFunc) { return function () { const gen = generatorFunc.apply(this, arguments); return new Promise((resolve, reject) =&gt; { function step(key, arg) { let generatorResult; try { generatorResult = gen[key](arg); } catch (error) { reject(error) } const { value, done } = generatorResult; if (done) { return resolve(value) } else { return Promise.resolve(value).then( (val) =&gt; step('next', val), (err) =&gt; step('throw', err) ) } } step('next'); }) }} 11.异步编程的实现方案 回调函数：最常见的异步编程解决方式，缺点是多个回调函数嵌套会造成回调地狱，不利于维护 Promise：使用Promise可以将嵌套的回调函数作为链式调用，但多个then的链式调用，可能会造成代码语义不够明确 generator：generator函数可以在函数执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来，当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权转移回来。因此我们在generator内部对于异步操作的方式，可以以同步的顺序来写。只需要我们考虑何时将函数执行权转移回来。所以我们需要一个自动执行generator的机制，比如co模块等方式来实现generator的自动执行 async函数：async函数其实就是generator和promise实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个await语句时，如果语句返回一个promise对象，那么函数将会等待promise对象的状态变为resolve后再继续向下执行。因此我们可以将异步逻辑转换为同步的顺序来书写。 12.co模块的原理Generator函数在处理异步操作时，需要一种自动执行的机制，当异步操作有了结果，能够自动交回执行权，两种方法可以做到这一点： 回调函数：将异步操作包装成Thunk函数，在回调函数里面交回执行权 Promise对象，将异步操作包装成Promise对象，用then方法交回执行权 co模块其实就是将这两种自动执行权器包转成的一个模块，所以使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象 13.观察者模式和发布订阅模式 观察者模式：一个对象(观察者)订阅另一个对象(主题)，当主题被激活的时候，触发观察者里面的事件 发布订阅模式：订阅者把自己想要的事件注册到调度中心，当发布者触发事件时，由调度中心统一调度订阅者注册到调度中心的代码 14.判断数据类型的方法 typeof：可以判断除null之外的基本数据类型和函数，其余的引用数据类型全部返回object instanceof：判断某个引用数据类型是否是对应构造函数的实例 1234567891011121314151617181920212223// 手写instanceoffunction _instanceof(left, right) { // 如果是基本数据类型，则直接返回false if (typeof left !== 'object' || left === null) { return false; } // 取右侧的实例原型 let rightProto = right.prototype; // 取左侧的原型 let leftProto = Object.getPrototypeOf(left); while (true) { if (leftProto === null) { return false; } if (leftProto === rightProto) { return true; } leftProto = Object.getPrototypeOf(leftProto) }} Object.prototype.toString.call()：因为toString()是Object实例原型上的方法，而Array，Function等类型作为Object的实例，都重写了toString方法，不同的对象类型调用toString方法，返回的值是不相同的，Array返回元素组成的字符串，Function返回函数体等，因此想要返回具体的类型，必须直接调用Object实例原型上的方法 constructor：每个对象的原型都指向其构造函数的实例原型，而实例原型上的constructor属性又直接指向对应的构造函数，因此直接调用constructor可以判断该对象是否是某个构造函数的实例","link":"/JavaScript/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"pages":[]}