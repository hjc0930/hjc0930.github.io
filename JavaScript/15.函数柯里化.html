<hr>
<p>title: 函数柯里化<br>excerpt: 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
</ul>
<hr>
<h1 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h1><p>说柯里化之前，首先抛出一个疑问，如何实现一个<code>add</code>函数，使得这个<code>add</code>函数可以灵活调用和传参，支持下面的调用示例呢？</p>
<pre><code class="javascript">add(1, 2, 3) // 6
add(1) // 1
add(1)(2) // 3
add(1, 2)(3) // 6
add(1)(2)(3) // 6
add(1)(2)(3)(4) // 10
</code></pre>
<p>要解答这样的疑问，还是要先明白什么是柯里化。</p>
<blockquote>
<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
</blockquote>
<p>这段解释看着还是挺懵逼的，不如举个例子：</p>
<p>本来有这么一个求和函数<code>dynamicAdd()</code>，接受任意个参数。</p>
<pre><code class="javascript">function dynamicAdd() {
  return [...arguments].reduce((prev, curr) =&gt; {
    return prev + curr
  }, 0)
}
</code></pre>
<p>现在需要通过柯里化把它变成一个新的函数，这个新的函数预置了第一个参数，并且可以在调用时继续传入剩余参数。</p>
<p>看到这，我觉得有点似曾相识，预置参数的特性与<code>bind</code>很相像。那么我们不如用<code>bind</code>的思路来实现。</p>
<pre><code class="javascript">function curry(fn, firstArg) {
  // 返回一个新函数
  return function() {
    // 新函数调用时会继续传参
    var restArgs = [].slice.call(arguments)
    // 参数合并，通过apply调用原函数
    return fn.apply(this, [firstArg, ...restArgs])
  }
}
</code></pre>
<p>接着我们通过一些例子来感受一下柯里化。</p>
<pre><code class="javascript">// 柯里化，预置参数10
var add10 = curry(dynamicAdd, 10)
add10(5); // 15
// 柯里化，预置参数20
var add20 = curry(dynamicAdd, 20);
add20(5); // 25
// 也可以对一个已经柯里化的函数add10继续柯里化，此时预置参数10即可
var anotherAdd20 = curry(add10, 10);
anotherAdd20(5); // 25
</code></pre>
<p>可以发现，柯里化是在一个函数的基础上进行变换，得到一个新的预置了参数的函数。最后在调用新函数时，实际上还是会调用柯里化前的原函数。</p>
<p>并且柯里化得到的新函数可以继续被柯里化，这看起来有点像<strong>俄罗斯套娃</strong>的感觉。</p>
<p>实际使用时也会出现柯里化的变体，<strong>不局限于只预置一个参数</strong>。</p>
<pre><code class="javascript">function curry(fn) {
  // 保存预置参数
  var presetArgs = [].slice.call(arguments, 1)
  // 返回一个新函数
  return function() {
    // 新函数调用时会继续传参
    var restArgs = [].slice.call(arguments)
    // 参数合并，通过apply调用原函数
    return fn.apply(this, [...presetArgs, ...restArgs])
  }
}
</code></pre>
<p>其实<code>Function.protoype.bind</code>就是一个柯里化的实现。不仅如此，很多流行的库都大量使用了柯里化的思想。</p>
<p>实际应用中，被柯里化的原函数的参数可能是定长的，也可能是不定长的。</p>
<h2 id="参数定长的柯里化"><a href="#参数定长的柯里化" class="headerlink" title="参数定长的柯里化"></a>参数定长的柯里化</h2><p>假设存在一个原函数<code>fn</code>，<code>fn</code>接受三个参数<code>a</code>, <code>b</code>, <code>c</code>，那么函数<code>fn</code>最多被柯里化三次（<strong>有效地绑定参数算一次</strong>）。</p>
<pre><code class="javascript">function fn(a, b, c) {
  return a + b + c
}
var c1 = curry(fn, 1);
var c2 = curry(c1, 2);
var c3 = curry(c2, 3);
c3(); // 6
// 再次柯里化也没有意义，原函数只需要三个参数
var c4 = curry(c3, 4);
c4();
复制代码
</code></pre>
<p>也就是说，我们可以<strong>通过柯里化缓存的参数数量，来判断是否到达了执行时机</strong>。那么我们就得到了一个柯里化的通用模式。</p>
<pre><code class="javascript">function curry(fn) {
  // 获取原函数的参数长度
  const argLen = fn.length;
  // 保存预置参数
  const presetArgs = [].slice.call(arguments, 1)
  // 返回一个新函数
  return function() {
    // 新函数调用时会继续传参
    const restArgs = [].slice.call(arguments)
    const allArgs = [...presetArgs, ...restArgs]
    if (allArgs.length &gt;= argLen) {
      // 如果参数够了，就执行原函数
      return fn.apply(this, allArgs)
    } else {
      // 否则继续柯里化
      return curry.call(null, fn, ...allArgs)
    }
  }
}
</code></pre>
<p>这样一来，我们的写法就可以支持以下形式。</p>
<pre><code class="javascript">function fn(a, b, c) {
  return a + b + c;
}
var curried = curry(fn);
curried(1, 2, 3); // 6
curried(1, 2)(3); // 6
curried(1)(2, 3); // 6
curried(1)(2)(3); // 6
curried(7)(8)(9); // 24
</code></pre>
<h2 id="参数不定长的柯里化"><a href="#参数不定长的柯里化" class="headerlink" title="参数不定长的柯里化"></a>参数不定长的柯里化</h2><p>解决了上面的问题，我们难免会问自己，假设原函数的参数不定长呢，这种情况如何柯里化？</p>
<p>首先，我们需要理解参数不定长是指函数声明时不约定具体的参数，而在函数体中通过<code>arguments</code>获取实参，然后进行运算。就像下面这种。</p>
<pre><code>function dynamicAdd() {
  return [...arguments].reduce((prev, curr) =&gt; {
    return prev + curr
  }, 0)
}
复制代码
</code></pre>
<p>回到最开始的问题，怎么支持下面的所有调用形式？</p>
<pre><code class="javascript">add(1, 2, 3) // 6
add(1) // 1
add(1)(2) // 3
add(1, 2)(3) // 6
add(1)(2)(3) // 6
add(1)(2)(3)(4) // 10
复制代码
</code></pre>
<p>思考了一阵，我发现在<strong>参数不定长</strong>的情况下，要同时支持<code>1~N</code>次调用还是挺难的。<code>add(1)</code>在一次调用后可以直接返回一个值，但它也可以作为函数接着调用<code>add(1)(2)</code>，甚至可以继续<code>add(1)(2)(3)</code>。那么我们实现<code>add</code>函数时，到底是返回一个函数，还是返回一个值呢？这让人挺犯难的，我也不能预测这个函数将如何被调用啊。</p>
<p>而且我们可以拿上面的成果来验证下：</p>
<pre><code class="javascript">curried(1)(2)(3)(4);
复制代码
</code></pre>
<p>运行上面的代码会报错：<strong>Uncaught TypeError: curried(…)(…)(…) is not a function</strong>，因为执行到<code>curried(1)(2)(3)</code>，结果就不是一个函数了，而是一个值，一个值当然是不能作为函数继续执行的。</p>
<p>所以如果要支持参数不定长的场景，<strong>已经柯里化的函数在执行完毕时不能返回一个值，只能返回一个函数；同时要让JS引擎在解析得到的这个结果时，能求出我们预期的值。</strong></p>
<p>大家看了这个可能还是不懂，好，说人话！我们实现的<code>curry</code>应该满足：</p>
<ol>
<li>经<code>curry</code>处理，得到一个新函数，这一点不变。</li>
</ol>
<pre><code class="javascript">// curry是一个函数
var curried = curry(add);
复制代码
</code></pre>
<ol>
<li>新函数执行后仍然返回一个结果函数。</li>
</ol>
<pre><code class="javascript">// curried10也是一个函数
var curried10 = curried(10);
var curried30 = curried10(20);
</code></pre>
<ol>
<li>结果函数可以被Javascript引擎解析，得到一个预期的值。</li>
</ol>
<pre><code class="javascript">curried10; // 10
</code></pre>
<p>好，关键点在于3，如何让Javascript引擎按我们的预期进行解析，这就回到Javascript基础了。在解析一个函数的原始值时，会用到<code>toString</code>。</p>
<p>我们知道，<code>console.log(fn)</code>可以把函数fn的源码输出，如下所示：</p>
<pre><code class="javascript">console.log(fn)
ƒ fn(a, b, c) {
  return a + b + c;
}
</code></pre>
<p>那么我们只要重写<code>toString</code>，就可以巧妙地实现我们的需求了。</p>
<pre><code class="javascript">function curry(fn) {
  // 保存预置参数
  const presetArgs = [].slice.call(arguments, 1)
  // 返回一个新函数
  function curried () {
    // 新函数调用时会继续传参
    const restArgs = [].slice.call(arguments)
    const allArgs = [...presetArgs, ...restArgs]
    return curry.call(null, fn, ...allArgs)
  }
  // 重写toString
  curried.toString = function() {
    return fn.apply(null, presetArgs)
  }
  return curried;
}
</code></pre>
<p>这样一来，魔性的<code>add</code>用法就都被支持了。</p>
<pre><code class="javascript">function dynamicAdd() {
  return [...arguments].reduce((prev, curr) =&gt; {
    return prev + curr
  }, 0)
}
var add = curry(dynamicAdd);
add(1)(2)(3)(4) // 10
add(1, 2)(3, 4)(5, 6) // 21
</code></pre>
<h2 id="柯里化总结"><a href="#柯里化总结" class="headerlink" title="柯里化总结"></a>柯里化总结</h2><p>柯里化是一种<strong>函数式编程</strong>思想，实际上在项目中可能用得少，或者说用得不深入，但是如果你掌握了这种思想，也许在未来的某个时间点，你会用得上！</p>
<p>大概来说，柯里化有如下特点：</p>
<ul>
<li><strong>简洁代码</strong>：柯里化应用在较复杂的场景中，有简洁代码，可读性高的优点。</li>
<li><strong>参数复用</strong>：公共的参数已经通过柯里化预置了。</li>
<li><strong>延迟执行</strong>：柯里化时只是返回一个预置参数的新函数，并没有立刻执行，实际上在满足条件后才会执行。</li>
<li><strong>管道式流水线编程</strong>：利于使用函数组装管道式的流水线工序，不污染原函数。</li>
</ul>
