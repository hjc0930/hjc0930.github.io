<hr>
<p>title: 基础语法整理<br>excerpt: JavaScript基础整理<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
</ul>
<hr>
<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><p>JavaScript数据类型包括7种基本类型和1种引用类型</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li><p>Number</p>
<p>JavaScript的Number类型是采用IEEE754格式来表示整数和浮点的值，Number类型的值一般默认是十进制表示，当然也可以直接表示八进制和十六进制，八进制以0为首位，十六进制以0x为首位，但无论是几进制，在运算时都是以十进制的方式进行运算</p>
<ul>
<li>双精度64位浮点格式</li>
<li>数值范围：-2^53-1~2^53-1</li>
<li>浮点数值：浮点数值最高精度是17位，超出的位数会被截掉，这也是为什么0.1+0.2 !== 0.3，在运算时，先将数值转换为二进制，运算结束后转换回来，最后得到的值是0.300000000004,所以不相等</li>
<li>NaN：NaN用于表示一个本来要返回数值的操作数未返回数值的情况，以防止抛出错误，NaN与任何值都不相等，包括其本身。isNaN()这个函数可以判断一个参数是否是数值，若不是数值，则会尝试转换为数值，无法转换的情况会返回false，这个函数适用于对象，在参数是对象的时候，会首先调用对象的valueof()方法，如果不能转为数值，则会调用toString()方法</li>
<li>数值的转换：这里指显示转换，主要通过三个方法进行转换：Number() parseInt()，第一个参数是要转换的值，第二个参数是进制，parseFloat()只会转换为十进制</li>
</ul>
</li>
<li><p>String</p>
<p>字符串是非常常用的类型，主要需要注意两个地方，一个是字符串是不可变的，如果需要改变一个字符串的值，那么就需要销毁原来的字符串，然后再创建一个新的字符串。第二个是在转换为字符串的时候，有两个方法，<code>toString()</code>和<code>String()</code>，后者其实是调用前者</p>
</li>
<li><p>Boolean</p>
<p>Boolean只有两个值，即true和false，该类型的字面值是区分大小写的，只有全小写才是boolean的值，其他的都是标识符。Boolean类型本身包含一个Boolean()方法，可以将其他类型转换为Boolean类型。</p>
</li>
<li><p>Symbol(ES6)</p>
<p>ES6新增的基础数据类型，可以避免对象属性命名冲突，多个模块共享独一的属性</p>
</li>
<li><p>BigInt(ES2020)</p>
<p>用于表示对任意长度整数的支持</p>
<p>创建BigInt：在一个整数字面量后面加n或者调用BigInt函数</p>
<ul>
<li>不要把BigInt和Number数字类型混用</li>
<li>BigInt不支持一元加法</li>
</ul>
</li>
<li><p>Null</p>
<p>null的主要作用是用来判断一个值是否存储了对象的引用</p>
<p>使用typeof操作符对null值进行检测时，会返回一个object值，这是因为null从逻辑的角度来说表示一个空指针对象。</p>
<p>在创建一个变量用来保存对象的时候，建议将变量初始化为null</p>
</li>
<li><p>undefined</p>
<p>用来表示一个已经声明但没有被初始化的变量</p>
</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li><p>object</p>
<p>有一句话叫做JavaScript一切皆对象，对象是JavaScript的基础</p>
</li>
<li><p>所具有的属性和方法：</p>
<ul>
<li>constructor：执向对应的构造函数</li>
<li>hasOwnProperty()：用来检查当前对象实例(不是原型)是否具有某个属性</li>
<li>isPrototypeOf()：检测一个对象是否在另一个对象的原型链中</li>
<li>prototypeIsEnumberable()：是否允许for-in枚举</li>
<li>toLocalString()</li>
<li>toString()</li>
<li>valueOf()</li>
</ul>
</li>
</ul>
<p>包括了Array Function Date RegExp Error</p>
<h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><ul>
<li>typeof()：除了null以外的基础类型都能判断，引用类型可以判断function</li>
<li>Object.prototype.toString.call()：可以检测出所有数据类型</li>
<li>instanceof：查找该属性是否属于原型链上的某个构造函数</li>
<li>constructor：通过构造函数去判断</li>
</ul>
<h2 id="2-深拷贝与浅拷贝"><a href="#2-深拷贝与浅拷贝" class="headerlink" title="2.深拷贝与浅拷贝"></a>2.深拷贝与浅拷贝</h2><ul>
<li>深拷贝层层拷贝，浅拷贝只拷贝第一层，深层只是引用</li>
<li>在深拷贝中，新对象中的更改不会影响原始对象。而浅拷贝新对象中的更改原始对象也会跟着更改</li>
<li>深拷贝中，原始对象不与新对象共享相同的属性，浅拷贝中，他们具有相同的属性</li>
</ul>
<h2 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h2><p>闭包是一个能读取其他函数内部变量的函数</p>
<ul>
<li>优点：使外部能访问到局部的变量</li>
<li>缺点：使用不当容易造成内存泄漏问题</li>
</ul>
<pre><code class="js">function a () {
  let num = 0

  // 这是个闭包
  return function () {
     return ++num
  }
}
const b = a()
console.log(b()) // 1
console.log(b()) // 2
</code></pre>
<h2 id="4-变量提升"><a href="#4-变量提升" class="headerlink" title="4.变量提升"></a>4.变量提升</h2><p>使用<code>var</code>关键字声明的变量存在变量提升</p>
<pre><code class="js">console.log(name) // undefined
var name = &quot;hjc&quot;

if(false) {
    var age = 23;
}

console.log(age) // undefined
</code></pre>
<ul>
<li>函数提升</li>
</ul>
<pre><code class="js">console.log(fun) // function fun() {}
function fun() {}

if (false) {
  function fun2(){}
}
console.log(fun2) // undefined 不会报错
</code></pre>
<p>优先级：函数提升  &gt; 变量提升</p>
<h2 id="5-isNaN和Number-isNaN-的区别"><a href="#5-isNaN和Number-isNaN-的区别" class="headerlink" title="5.isNaN和Number.isNaN()的区别"></a>5.isNaN和Number.isNaN()的区别</h2><ul>
<li>isNaN：除了判断NaN为true，还会把不能转成数字的判断为true</li>
<li>Number.isNaN：只有判断NaN时为true，其余情况都为false</li>
</ul>
<h2 id="6-遍历对象时，如何避免遍历出原型上的属性"><a href="#6-遍历对象时，如何避免遍历出原型上的属性" class="headerlink" title="6.遍历对象时，如何避免遍历出原型上的属性"></a>6.遍历对象时，如何避免遍历出原型上的属性</h2><ul>
<li>使用<code>hasOwnProperty()</code></li>
</ul>
<pre><code class="js">function Person(name) {
    this.name = name;
}
Person.prototype.age = 22;

const person = new Person(&#39;jiacheng&#39;);

for(const key in person) {
    console.log(key) // name age
}

for(const key in person) {
    person.hasoOwnProperty(key) &amp;&amp; console.log(key) // name
}
</code></pre>
<h2 id="7-valueof与toString"><a href="#7-valueof与toString" class="headerlink" title="7.valueof与toString"></a>7.valueof与toString</h2><ul>
<li>valueOf偏向于运算，toString偏向于显示</li>
<li>对象转换时，会优先调用toString</li>
<li>强转字符串优先调用toString，强转数字优先调用valueOf</li>
<li>正常情况下优先调用toString，运算操作符情况下优先调用valueOf</li>
</ul>
<h3 id="调用valueOf"><a href="#调用valueOf" class="headerlink" title="调用valueOf"></a>调用valueOf</h3><table>
<thead>
<tr>
<th>调用者</th>
<th>返回值</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>数组本身</td>
<td>Array</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值</td>
<td>Boolean</td>
</tr>
<tr>
<td>Date</td>
<td>毫秒数</td>
<td>Number</td>
</tr>
<tr>
<td>Function</td>
<td>函数本身</td>
<td>Function</td>
</tr>
<tr>
<td>Number</td>
<td>数字值</td>
<td>Number</td>
</tr>
<tr>
<td>Object</td>
<td>对象本身</td>
<td>Object</td>
</tr>
<tr>
<td>String</td>
<td>字符串</td>
<td>String</td>
</tr>
</tbody></table>
<h3 id="调用toString"><a href="#调用toString" class="headerlink" title="调用toString"></a>调用toString</h3><table>
<thead>
<tr>
<th>调用者</th>
<th>返回值</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>数组转字符串，相当于Array.join()</td>
<td>String</td>
</tr>
<tr>
<td>Boolean</td>
<td>转字符串’true’、’false’</td>
<td>String</td>
</tr>
<tr>
<td>Date</td>
<td>字符串日期，如’Fri Dec 23 2016 11:24:47 GMT+0800 (中国标准时间)’</td>
<td>String</td>
</tr>
<tr>
<td>Number</td>
<td>数字字符串</td>
<td>String</td>
</tr>
<tr>
<td>Object</td>
<td>‘[object Object]’</td>
<td>String</td>
</tr>
<tr>
<td>String</td>
<td>字符串</td>
<td>String</td>
</tr>
</tbody></table>
<h2 id="8-JavaScript变量在内存中的具体存储形式"><a href="#8-JavaScript变量在内存中的具体存储形式" class="headerlink" title="8.JavaScript变量在内存中的具体存储形式"></a>8.JavaScript变量在内存中的具体存储形式</h2><ul>
<li>基本数据类型：存在<code>栈内存</code>中</li>
<li>引用数据类型：指针存在<code>栈内存</code>中，指向<code>堆内存</code>中一块地址，内容存在<code>堆内存</code>中</li>
</ul>
<h2 id="9-JavaScript装箱和拆箱"><a href="#9-JavaScript装箱和拆箱" class="headerlink" title="9.JavaScript装箱和拆箱"></a>9.JavaScript装箱和拆箱</h2><h3 id="装箱：把基本数据类型转化为对应的引用数据类型的操作"><a href="#装箱：把基本数据类型转化为对应的引用数据类型的操作" class="headerlink" title="装箱：把基本数据类型转化为对应的引用数据类型的操作"></a>装箱：把基本数据类型转化为对应的引用数据类型的操作</h3><ul>
<li>在声明一个基本数据类型时，若要调用对应引用数据类型上面的api，则直接调用即可</li>
</ul>
<pre><code class="js">var a = &#39;jiacheng&#39;
var index = a.indexOf(&#39;j&#39;)
console.log(index) // 0

// 装箱操作 1.创建String类型的一个实例；2.在实例上调用指定的方法；3.销毁这个实例
var temp = new String(&#39;jiacheng&#39;);
var index = temp.indexOf(&#39;j&#39;);
temp = null;
console.log(index)
</code></pre>
<h3 id="拆箱：将引用数据类型转化为对应的基本数据类型的操作"><a href="#拆箱：将引用数据类型转化为对应的基本数据类型的操作" class="headerlink" title="拆箱：将引用数据类型转化为对应的基本数据类型的操作"></a>拆箱：将引用数据类型转化为对应的基本数据类型的操作</h3><ul>
<li>通过<code>valueOf</code>和<code>toString</code>方法实现拆箱操作</li>
</ul>
<pre><code class="js">var objNum = new Number(123);
var objStr =new String(&quot;123&quot;);
console.log( typeof objNum ); //object
console.log( typeof objStr ); //object
console.log( typeof objNum.valueOf() ); //number
console.log( typeof objStr.valueOf() ); //string

console.log( typeof objNum.toString() ); // string
console.log( typeof objStr.toString() ); // string
</code></pre>
<p><strong>注意：从ES6开始语法禁止显示地实例化基本数据类型所对应的包装类，因此Symbol和BigInt的构造函数无法被new关键字实例化</strong></p>
<h2 id="10-null和undefined的异同点"><a href="#10-null和undefined的异同点" class="headerlink" title="10. null和undefined的异同点"></a>10. null和undefined的异同点</h2><p><strong>相同的</strong></p>
<ul>
<li>都是空变量</li>
<li>对应的布尔值都为false</li>
<li>null == undefined为true</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>typeof判断null为object，判断undefined为undefined</li>
<li>null转为number类型为0，undefined转成number类型为NaN</li>
<li>null表示一个对象未初始化，undefined表示初始化了但为赋值</li>
<li>null === undefined为false</li>
</ul>
<h2 id="11-如何判断数据类型"><a href="#11-如何判断数据类型" class="headerlink" title="11.如何判断数据类型"></a>11.如何判断数据类型</h2><ul>
<li><p>typeof xxx：能判断出number，string，undefined，boolean，symbol，bigint，object，function（null是object）</p>
</li>
<li><p>Object.prototype.toString.call(xxx)：能判断出大部分类型</p>
</li>
<li><p>Array.isArray(xxx)：判断是否为数组</p>
</li>
</ul>
<h2 id="12-为什么typeof-null是object"><a href="#12-为什么typeof-null是object" class="headerlink" title="12.为什么typeof null是object"></a>12.为什么typeof null是object</h2><p>不同的数据类型在底层都是通过二进制来表示的，二进制的前三位全是0的会被判断为<code>object</code>，而null的底层全是0，所以会被判断为object</p>
<h2 id="13、-与-的区别？"><a href="#13、-与-的区别？" class="headerlink" title="13、== 与 === 的区别？"></a>13、== 与 === 的区别？</h2><ul>
<li>==：在比较过程中会存在隐式转换</li>
<li>===：需要类型相同，值相同，才能为true</li>
</ul>
<h2 id="14、JavaScript的隐式转换规则？"><a href="#14、JavaScript的隐式转换规则？" class="headerlink" title="14、JavaScript的隐式转换规则？"></a>14、JavaScript的隐式转换规则？</h2><ul>
<li>1、转成string类型： +（字符串连接符）</li>
<li>2、转成number类型：++/–(自增自减运算符) + - * / %(算术运算符) &gt; &lt; &gt;= &lt;= == != === !== (关系运算符)</li>
<li>3、转成boolean类型：!（逻辑非运算符)</li>
</ul>
<h2 id="15-双等号左右两边的转换规则"><a href="#15-双等号左右两边的转换规则" class="headerlink" title="15.双等号左右两边的转换规则"></a>15.双等号左右两边的转换规则</h2><ul>
<li>null == undefined为true</li>
<li>如果有一个为boolean，则在比较之前会先转换成number类型再比较，true转为1，false转为0</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的toString()方法，用得到的基本类型值按照前面的规则进行比较</li>
</ul>
<h2 id="16-undefined-gt-undefined为什么是false"><a href="#16-undefined-gt-undefined为什么是false" class="headerlink" title="16. undefined &gt;= undefined为什么是false"></a>16. undefined &gt;= undefined为什么是false</h2><p>按照隐式转换规则，可以转为NaN &gt;=NaN，所以是false</p>
<h2 id="17-null-gt-null为什么是true"><a href="#17-null-gt-null为什么是true" class="headerlink" title="17.null &gt;= null为什么是true"></a>17.null &gt;= null为什么是true</h2><p>按照隐式转换规则，可以转为 0 &gt;= 0 ，所以为true</p>
<h2 id="18-为什么是true"><a href="#18-为什么是true" class="headerlink" title="18.[] == ![] 为什么是true"></a>18.[] == ![] 为什么是true</h2><p>按照<code>双等号左右两边的转换规则</code></p>
<ul>
<li><code>!</code> 优先级高于 <code>==</code>，<code>[]</code>不是假值，所以先转换成 <code>![] == false</code></li>
<li>右边为布尔值，<code>false</code>先转数字<code>0</code>，所以可转换为<code>[] == 0</code></li>
<li>左边为对象，<code>[]</code>调用<code>toString</code>转为 <code>&#39;&#39;</code>，转换为<code>&#39;&#39; == 0</code></li>
<li>左边为字符串，<code>&#39;&#39;</code>转换为<code>0</code>，最终为 <code>0 == 0</code></li>
</ul>
<h2 id="19-0-1-0-2-0-3，对吗？"><a href="#19-0-1-0-2-0-3，对吗？" class="headerlink" title="19.0.1 + 0.2 === 0.3，对吗？"></a>19.0.1 + 0.2 === 0.3，对吗？</h2><p>不对，JavaScript的计算存在精度丢失问题</p>
<ul>
<li>原因：JavaScript中小数是浮点数，需转二进制进行运算，有些小数无法用二进制表示，所以只能取近似值，所以造成误差</li>
<li>解决方法：<ul>
<li>先变成整数运算，然后再变回小数</li>
<li>toFixed() 性能不好，不推荐</li>
</ul>
</li>
</ul>
<h2 id="20-什么是匿名函数"><a href="#20-什么是匿名函数" class="headerlink" title="20.什么是匿名函数"></a>20.什么是匿名函数</h2><p>就是没有函数名的函数</p>
<h2 id="21-绑定点击事件有几种方式"><a href="#21-绑定点击事件有几种方式" class="headerlink" title="21.绑定点击事件有几种方式"></a>21.绑定点击事件有几种方式</h2><ul>
<li><code>xxx.onclick = function (){}</code></li>
<li><code>&lt;xxx onclick=&quot;&quot;&gt;&lt;/xxx&gt;</code></li>
<li><code>xxx.addEventListence(&#39;click&#39;, function(){}, false)</code></li>
</ul>
<h2 id="22-addEventListence的第三个参数是干嘛的"><a href="#22-addEventListence的第三个参数是干嘛的" class="headerlink" title="22. addEventListence的第三个参数是干嘛的"></a>22. addEventListence的第三个参数是干嘛的</h2><p>第三个变量传一个布尔值，是否要阻止冒泡，默认是false，不阻止冒泡</p>
<h2 id="23-函数声明和函数表达式的区别"><a href="#23-函数声明和函数表达式的区别" class="headerlink" title="23.函数声明和函数表达式的区别"></a>23.函数声明和函数表达式的区别</h2><ul>
<li>函数声明：享受函数提升</li>
<li>函数表达式：归于类变量声明，享受变量提升</li>
<li>函数提升优先级 &gt; 变量提升优先级</li>
</ul>
<pre><code class="js">console.log(fun) // fun () {}
// 函数表达式
var fun = function(name) {}
// 函数声明
function fun () {}
console.log(fun) // fun (name) {}
</code></pre>
<h2 id="24-JavaScript事件流模型"><a href="#24-JavaScript事件流模型" class="headerlink" title="24.JavaScript事件流模型"></a>24.JavaScript事件流模型</h2><ul>
<li>事件冒泡：由具体的元素接收，并往上传播</li>
<li>事件捕获：由最不具体的元素接收，并往下传播</li>
<li>DOM事件流：捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段</li>
</ul>
<h2 id="25-Ajax-Axios-Fetch"><a href="#25-Ajax-Axios-Fetch" class="headerlink" title="25.Ajax Axios Fetch"></a>25.Ajax Axios Fetch</h2><ul>
<li>Ajax：是对XMLHttpRequest对象（XHR）的封装</li>
<li>Axios：是基于Promise对XHR对象的封装</li>
<li>Fetch：是window的一个方法，也是基于Promise，但是与XHR无关，不支持IE</li>
</ul>
<h2 id="26-load、-document-ready、DOMContentLoaded的区别？"><a href="#26-load、-document-ready、DOMContentLoaded的区别？" class="headerlink" title="26.load、$(document).ready、DOMContentLoaded的区别？"></a>26.load、$(document).ready、DOMContentLoaded的区别？</h2><p>DOM文档加载的步骤为：</p>
<ul>
<li>解析HTML结构。</li>
<li>加载外部脚本和样式表文件。</li>
<li>解析并执行脚本代码。</li>
<li>DOM树构建完成。// <code>DOMContentLoaded</code>触发、<code>$(document).ready</code>触发</li>
<li>加载图片等外部文件。</li>
<li>页面加载完毕。// <code>load</code>触发</li>
</ul>
<h2 id="27-阻住事件冒泡"><a href="#27-阻住事件冒泡" class="headerlink" title="27.阻住事件冒泡"></a>27.阻住事件冒泡</h2><pre><code class="js">function stopBubble(e) {
  if (e.stopPropagation) {
    e.stopPropagation()
  } else {
    window.event.cancelBubble = true;
  }
}
</code></pre>
<h2 id="28-阻住事件默认行为"><a href="#28-阻住事件默认行为" class="headerlink" title="28.阻住事件默认行为"></a>28.阻住事件默认行为</h2><ul>
<li>比如说链接a，input type为submit等</li>
</ul>
<pre><code class="js">function stopDefault(e) {
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    window.event.returnValue = false;
}
</code></pre>
<h2 id="29-事件委托"><a href="#29-事件委托" class="headerlink" title="29.事件委托"></a>29.事件委托</h2><p>当所有子元素都需要绑定相同的事件的时候，可以把事件绑定在父元素上，这就是<code>事件委托</code>，优点有：</p>
<ul>
<li>绑定在父元素上只需要绑定一次，节省性能</li>
<li>子元素不需要每个都去绑定同一事件</li>
<li>如果后续又有新的子元素添加，会由于事件委托的原因，自动接收到父元素的事件监听</li>
</ul>
<h2 id="30-如何实现数组去重"><a href="#30-如何实现数组去重" class="headerlink" title="30.如何实现数组去重"></a>30.如何实现数组去重</h2><pre><code class="js">// 使用 Set 去重
function quchong (arr) {
    return [...new Set(arr)]
}
</code></pre>
<h2 id="31-NaN是什么，有什么特点"><a href="#31-NaN是什么，有什么特点" class="headerlink" title="31.NaN是什么，有什么特点"></a>31.NaN是什么，有什么特点</h2><ul>
<li>NaN不等于自身，也就是 <code>NaN === NaN</code> 为 <code>false</code></li>
<li>NaN为假值，转布尔值为<code>false</code></li>
<li>NaN本质是一个number，<code>typeof NaN === number</code></li>
</ul>
<h2 id="32-处理异步的方法有哪些"><a href="#32-处理异步的方法有哪些" class="headerlink" title="32.处理异步的方法有哪些"></a>32.处理异步的方法有哪些</h2><ul>
<li>回调函数</li>
<li>Promise</li>
<li>事件监听</li>
<li>发布订阅</li>
<li>Generator(async/await)</li>
</ul>
<h2 id="33-创建一个对象"><a href="#33-创建一个对象" class="headerlink" title="33.创建一个对象"></a>33.创建一个对象</h2><h4 id="new-Object创建"><a href="#new-Object创建" class="headerlink" title="new Object创建"></a>new Object创建</h4><pre><code class="js">const obj = new Object()
obj.name = &#39;Sunshine_Lin&#39;
</code></pre>
<h4 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h4><pre><code class="js">const obj = { name: &#39;Sunshin_Lin&#39; }
</code></pre>
<h4 id="工厂模式创建"><a href="#工厂模式创建" class="headerlink" title="工厂模式创建"></a>工厂模式创建</h4><pre><code class="js">function createObj(name) {
  const obj = new Object()
  obj.name = name
  return obj
}
const obj = createObj(&#39;Sunshine_Lin&#39;)
</code></pre>
<h4 id="构造函数创建"><a href="#构造函数创建" class="headerlink" title="构造函数创建"></a>构造函数创建</h4><pre><code class="js">function Person(name) {
  this.name = name
}
const person = new Person(&#39;Sunshine_Lin&#39;)
</code></pre>
<h2 id="34-this指向的四种情况"><a href="#34-this指向的四种情况" class="headerlink" title="34.this指向的四种情况"></a>34.this指向的四种情况</h2><ul>
<li>指向new操作符创建的实例</li>
</ul>
<pre><code class="js">function Person(name) {
    this.name = name;
    console.log(this)
}
const person = new Person(&#39;jiacheng&#39;) // this指向当前person的实例对象
</code></pre>
<ul>
<li>指向window</li>
</ul>
<pre><code class="js">function() {
    console.log(this);
}

fn() // 指向window
</code></pre>
<ul>
<li>指向对象调用方法</li>
</ul>
<pre><code class="js">const target = {
  fn: function () { console.log(this) }
}
target.fn() // target

const fn = target.fn
fn() // 浏览器window，node里global
</code></pre>
<ul>
<li>call apply bind改变this</li>
</ul>
<pre><code class="js">const obj1 = {
  name: &#39;黄家程&#39;,
  sayName: function() {
    console.log(this.name)
  }
}
const obj2 = {
  name: &#39;jiacheng_huang&#39;
}
// 改变sayName的this指向obj2
obj1.sayName.call(obj2) // jiacheng_huang

// 改变sayName的this指向obj2
obj1.sayName.apply(obj2) // jiacheng_huang

// 改变sayName的this指向obj2
const fn = obj1.sayName.bind(obj2)
fn() // jiacheng_huang
</code></pre>
<h2 id="35、数组的常用方法有哪些？"><a href="#35、数组的常用方法有哪些？" class="headerlink" title="35、数组的常用方法有哪些？"></a>35、数组的常用方法有哪些？</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>是否影响原数组</th>
</tr>
</thead>
<tbody><tr>
<td>push</td>
<td>在数组后添加元素，返回数组长度</td>
<td>✅</td>
</tr>
<tr>
<td>pop</td>
<td>删除数组最后一项，返回被删除项</td>
<td>✅</td>
</tr>
<tr>
<td>shift</td>
<td>删除数组第一项，并返回数组</td>
<td>✅</td>
</tr>
<tr>
<td>unshift</td>
<td>数组开头添加元素，返回添加的元素</td>
<td>✅</td>
</tr>
<tr>
<td>reserve</td>
<td>反转一个数组，返回修改后的数组</td>
<td>✅</td>
</tr>
<tr>
<td>sort</td>
<td>排序一个数组，返回修改后的数组</td>
<td>✅</td>
</tr>
<tr>
<td>splice</td>
<td>截取数组，返回被截取的区间</td>
<td>✅</td>
</tr>
<tr>
<td>join</td>
<td>将一个数组所有元素连接成字符串并返回这个字符串</td>
<td>❌</td>
</tr>
<tr>
<td>concat</td>
<td>arr1.concat(arr2, arr3)  连接数组</td>
<td>❌</td>
</tr>
<tr>
<td>map</td>
<td>操作数组每一项并返回一个新数组</td>
<td>❌</td>
</tr>
<tr>
<td>forEach</td>
<td>遍历数组，没有返回值</td>
<td>❌</td>
</tr>
<tr>
<td>find</td>
<td>对数组进行筛选，返回第一个符合条件的元素</td>
<td>❌</td>
</tr>
<tr>
<td>filter</td>
<td>对数组所有项进行判断，返回符合规则的新数组</td>
<td>❌</td>
</tr>
<tr>
<td>every</td>
<td>数组每一项都符合规则才返回true</td>
<td>❌</td>
</tr>
<tr>
<td>some</td>
<td>数组有符合规则的一项就返回true</td>
<td>❌</td>
</tr>
<tr>
<td>reduce</td>
<td>接收上一个return和数组的下一项</td>
<td>❌</td>
</tr>
<tr>
<td>flat</td>
<td>数组扁平化</td>
<td>❌</td>
</tr>
<tr>
<td>slice</td>
<td>截取数组，返回被截取的区间</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="36、Math的常用方法有哪些？"><a href="#36、Math的常用方法有哪些？" class="headerlink" title="36、Math的常用方法有哪些？"></a>36、Math的常用方法有哪些？</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Math.max(arr)</td>
<td>取arr中的最大值</td>
</tr>
<tr>
<td>Math.min(arr)</td>
<td>取arr中的最小值</td>
</tr>
<tr>
<td>Math.ceil(小数)</td>
<td>小数向上取整</td>
</tr>
<tr>
<td>Math.floor(小数)</td>
<td>小数向下取整</td>
</tr>
<tr>
<td>Math.round(小数)</td>
<td>小数四舍五入</td>
</tr>
<tr>
<td>Math.sqrt(num)</td>
<td>对num进行开方</td>
</tr>
<tr>
<td>Math.pow(num, m)</td>
<td>对num取m次幂</td>
</tr>
<tr>
<td>Math.random() * num</td>
<td>取[0,num)的随机数</td>
</tr>
</tbody></table>
<h2 id="37、哪些因素导致内存泄漏？如何解决？"><a href="#37、哪些因素导致内存泄漏？如何解决？" class="headerlink" title="37、哪些因素导致内存泄漏？如何解决？"></a>37、哪些因素导致内存泄漏？如何解决？</h2><p>请看我这篇文章<a href="https://juejin.cn/post/6996828267068014600">哪是大神？只是用他人七夕约会时间，整理「JS避免内存泄漏」罢了</a></p>
<h2 id="38、讲讲JavaScript的垃圾回收机制"><a href="#38、讲讲JavaScript的垃圾回收机制" class="headerlink" title="38、讲讲JavaScript的垃圾回收机制"></a>38、讲讲JavaScript的垃圾回收机制</h2><p>看我这篇文章：<a href="https://juejin.cn/post/6995706341041897486">赠你13张图，助你20分钟打败了「V8垃圾回收机制」</a></p>
<h2 id="39、JS中有哪些不同类型的弹出框？"><a href="#39、JS中有哪些不同类型的弹出框？" class="headerlink" title="39、JS中有哪些不同类型的弹出框？"></a>39、JS中有哪些不同类型的弹出框？</h2><p>在JS中有三种类型的弹出框可用，分别是：</p>
<ul>
<li>Alert</li>
<li>Confirm</li>
<li>Prompt</li>
</ul>
<h2 id="40-如何将-JS-日期转换为ISO标准"><a href="#40-如何将-JS-日期转换为ISO标准" class="headerlink" title="40. 如何将 JS 日期转换为ISO标准"></a>40. 如何将 JS 日期转换为ISO标准</h2><p><strong>toISOString()</strong> 方法用于将js日期转换为ISO标准。 它使用ISO标准将js Date对象转换为字符串。如：</p>
<pre><code>var date = new Date();
var n = date.toISOString();
console.log(n);
// YYYY-MM-DDTHH:mm:ss.sssZ
复制代码
</code></pre>
<h2 id="41、如何在JS中编码和解码-URL"><a href="#41、如何在JS中编码和解码-URL" class="headerlink" title="41、如何在JS中编码和解码 URL"></a>41、如何在JS中编码和解码 URL</h2><p><strong>encodeURI()</strong> 函数用于在JS中对URL进行编码。它将url字符串作为参数并返回编码的字符串。</p>
<p><strong>注意</strong>： encodeURI()不会编码类似这样字符： / ? : @ &amp; = + $ #，如果需要编码这些字符，请使用encodeURIComponent()。 用法：</p>
<pre><code class="js">var uri = &quot;my profile.php?name=sammer&amp;occupation=pāntiNG&quot;;
var encoded_uri = encodeURI(uri);
</code></pre>
<p><strong>decodeURI()</strong> 函数用于解码js中的URL。它将编码的url字符串作为参数并返回已解码的字符串，用法：</p>
<pre><code class="js">var uri = &quot;my profile.php?name=sammer&amp;occupation=pāntiNG&quot;;
var encoded_uri = encodeURI(uri);
decodeURI(encoded_uri);
</code></pre>
<h2 id="42、什么是BOM？有哪些api？"><a href="#42、什么是BOM？有哪些api？" class="headerlink" title="42、什么是BOM？有哪些api？"></a>42、什么是BOM？有哪些api？</h2><p>BOM就是<code>browser object model</code>，<code>浏览器对象模型</code></p>
<table>
<thead>
<tr>
<th>api</th>
<th>作用</th>
<th>代表方法或属性</th>
</tr>
</thead>
<tbody><tr>
<td>window.history</td>
<td>操纵浏览器的记录</td>
<td>history.back() history.go(-1)</td>
</tr>
<tr>
<td>window.innerHeight</td>
<td>获取浏览器窗口的高度</td>
<td></td>
</tr>
<tr>
<td>window.innerWidth</td>
<td>获取浏览器窗口的宽度</td>
<td></td>
</tr>
<tr>
<td>window.location</td>
<td>操作刷新按钮和地址栏</td>
<td>location.host：获取域名和端口 location.hostname：获取主机名 location.port：获取端口号 location.pathname：获取url的路径 location.search：获取?开始的部分 location.href：获取整个url location.hash：获取#开始的部分 location.origin：获取当前域名 location.navigator：获取当前浏览器信息</td>
</tr>
</tbody></table>
<h2 id="43、BOM-和-DOM-的关系"><a href="#43、BOM-和-DOM-的关系" class="headerlink" title="43、BOM 和 DOM 的关系"></a>43、BOM 和 DOM 的关系</h2><p><strong>BOM</strong>全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架。</p>
<p>DOM全称Document Object Model，即文档对象模型，是 HTML 和XML 的应用程序接口（API），遵循W3C 的标准，所有浏览器公共遵守的标准。</p>
<p>JS是通过访问<strong>BOM</strong>（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于<strong>BOM</strong>的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM的根节点。</p>
<p>可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。</p>
<h2 id="44、JS中的substr-和substring-函数有什么区别"><a href="#44、JS中的substr-和substring-函数有什么区别" class="headerlink" title="44、JS中的substr()和substring()函数有什么区别"></a>44、JS中的substr()和substring()函数有什么区别</h2><p>substr() 函数的形式为substr(startIndex,length)。 它从startIndex返回子字符串并返回’length’个字符数。</p>
<pre><code class="js">var s = &quot;hello&quot;;
( s.substr(1,4) == &quot;ello&quot; ) // true
</code></pre>
<p>substring() 函数的形式为substring(startIndex,endIndex)。 它返回从startIndex到endIndex - 1的子字符串。</p>
<pre><code class="js">var s = &quot;hello&quot;;
( s.substring(1,4) == &quot;ell&quot; ) // true
复制代码
</code></pre>
<h2 id="45、解释一下-“use-strict”"><a href="#45、解释一下-“use-strict”" class="headerlink" title="45、解释一下 “use strict” ?"></a>45、解释一下 “use strict” ?</h2><p>“use strict”是Es5中引入的js指令。 使用“use strict”指令的目的是强制执行严格模式下的代码。 在严格模式下，咱们不能在不声明变量的情况下使用变量。 早期版本的js忽略了“use strict”。</p>
<h2 id="46-ES5继承方式"><a href="#46-ES5继承方式" class="headerlink" title="46.ES5继承方式"></a>46.ES5继承方式</h2><ul>
<li>定义一个类</li>
</ul>
<pre><code class="js">// 定义一个类
function Animal(name) {
    this.name = name || &#39;Animal&#39;;
    // 实例方法
    this.sleep = function() {
        console.log(this.name + &#39;正在睡觉&#39;);
    }
}
// 原型方法
Animal.prototype.eat = function(food) {
    console.log(this.name + &#39;正在吃&#39; + food)
}
</code></pre>
<h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><p><strong>核心：将父类的实例作为子类的原型</strong></p>
<ul>
<li>优点<ul>
<li>实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ul>
</li>
<li>缺点<ul>
<li>子类要想新增属性和方法，必须要在<code>new Animal()</code>这样的语句之后，不能放在构造器中</li>
<li>原型对象的所有属性被所有实例共享</li>
<li>实现子类实例时，无法向父类构造函数传参</li>
<li>不支持多继承</li>
</ul>
</li>
</ul>
<pre><code class="js">function Cat() { }

Cat.prototype = new Animal();
Cat.prototype.name = &#39;cat&#39;;

var cat = new Cat();
console.log(cat.name);

cat.eat(&#39;fish&#39;); // cat正在吃fish
cat.sleep();     // cat正在睡觉

console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat);   // true
</code></pre>
<h3 id="2-构造继承"><a href="#2-构造继承" class="headerlink" title="2.构造继承"></a>2.构造继承</h3><p><strong>核心：使用父类的构造器来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</strong></p>
<ul>
<li><p>优点</p>
<ul>
<li>解决了<code>原型链继承</code>中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承(call多个父类对象)</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>实例并不是父类实例，只是子类的实例</li>
<li>只能继承父类的实例属性和实例方法，不能继承父类原型上的属性和方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
</li>
</ul>
<pre><code class="js">function Cat(name) {
  Animal.call(this);
  this.name = name || &#39;Tom&#39;;
}

var cat = new Cat();
console.log(cat.name); // Tom
cat.sleep(); // Tom正在睡觉
cat.eat(&#39;fish&#39;); // 报错

console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
</code></pre>
<h3 id="3-实例继承"><a href="#3-实例继承" class="headerlink" title="3.实例继承"></a>3.实例继承</h3><p><strong>核心：为父类实例添加新特性，作为子类实例返回</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>不限制调用方式，不管是<code>new 子类()</code>还是<code>子类()</code>，返回的对象具有相同效果</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>实例是父类的实例，不是子类的实例</li>
<li>不支持多继承</li>
</ul>
</li>
</ul>
<pre><code class="js">function Cat(name) {
  var instance = new Animal();

  instance.name = name || &#39;Tom&#39;;

  return instance;
}

var cat = new Cat();

console.log(cat.name); // Tom

cat.sleep(); // Tom正在睡觉

cat.eat(&#39;fish&#39;); // Tom正在吃fish

console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // false
</code></pre>
<h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h3><p><strong>核心：一个一个拷贝</strong></p>
<ul>
<li>优点<ul>
<li>支持多继承</li>
</ul>
</li>
<li>缺点<ul>
<li>因为要一个一个拷贝，所以效率很低</li>
<li>无法获取父类的不可枚举方法</li>
</ul>
</li>
</ul>
<pre><code class="js">function Cat(name) {
  var animal = new Animal();

  for (var p in animal) {
    Cat.prototype[p] = animal[p];
  }

  this.name = name || &#39;Tom&#39;
}

var cat = new Cat();
console.log(cat.name); // Tom
cat.sleep() // Tom正在睡觉！
cat.eat(&#39;fish&#39;); // Tom正在吃fish
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
</code></pre>
<h3 id="5-组合继承-原型链继承-构造继承"><a href="#5-组合继承-原型链继承-构造继承" class="headerlink" title="5.组合继承(原型链继承+构造继承)"></a>5.组合继承(原型链继承+构造继承)</h3><p><strong>核心：通过父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</strong></p>
<ul>
<li>优点<ul>
<li>弥补了<code>构造继承</code>的缺陷，可以继承实例的属性/方法，也可以继承原型上的属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>可以向父类传参</li>
<li>函数可以复用</li>
</ul>
</li>
<li>缺点<ul>
<li>调用了两次父类的构造函数，生成了两份实例</li>
</ul>
</li>
</ul>
<pre><code class="js">function Cat(name) {
  Animal.call(this);

  this.name = name || &#39;Tom&#39;;
}

Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;

var cat = new Cat();
console.log(cat.name); // Tom
cat.sleep() // Tom正在睡觉！
cat.eat(&#39;fish&#39;); // Tom正在吃fish
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
</code></pre>
<h3 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6.寄生组合继承"></a>6.寄生组合继承</h3><p><strong>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造时，就不会初始化两次实例方法/属性，避免<code>继承组合</code>的缺点</strong></p>
<ul>
<li>优点<ul>
<li>几乎完美</li>
</ul>
</li>
<li>缺点<ul>
<li>实现复杂</li>
</ul>
</li>
</ul>
<pre><code class="js">function Cat(name) {
  Animal.call(this);
  this.name = name || &#39;Tom&#39;;
}

// 创建一个没有实例方法的构造函数
var Super = function () { }
Super.prototype = Animal.prototype;
// 将实例作为子类的原型
Cat.prototype = new Super();

// Test Code
var cat = new Cat();
console.log(cat.name); // Tom
cat.sleep() // Tom正在睡觉！
cat.eat(&#39;fish&#39;) // // Tom正在吃fish
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true
</code></pre>
