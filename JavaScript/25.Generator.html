<hr>
<p>title: Generator<br>excerpt: Generator函数是ES6提供的异步编程的解决方案，语法上，Generator是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，可以依次遍历Generator函数内部的每一个状态<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
</ul>
<hr>
<h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1.特性"></a>1.特性</h2><p>·<code>function</code>关键字与函数名之间有一个星号</p>
<p>内部通过<code>yield</code>表达式，定义不同的内部状态</p>
<p>返回的遍历器对象，使用<code>next()</code>方法依次遍历函数内部的状态</p>
<h2 id="2-yield表达式"><a href="#2-yield表达式" class="headerlink" title="2.yield表达式"></a>2.yield表达式</h2><p><code>Generator</code>函数内部通过<code>yield</code>表达式来暂停执行后面的操作，只有通过<code>next()</code>方法才能继续往下执行</p>
<ul>
<li>next方法的运行逻辑：<ul>
<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值</li>
<li>再次调用<code>next</code>方法，就继续往下执行，直到遇到下一个<code>yield</code>表达式，就暂停执行并将后面的值赋给<code>value</code>返回</li>
<li>如果没有遇到新的<code>yield</code>表达式，就一直运行到函数结束，将<code>return</code>语句后面的表达式作为对象的<code>value</code>值返回，如果没有<code>return</code>语句，则返回<code>undefined</code></li>
</ul>
</li>
</ul>
<h2 id="3-与Iterator的关系"><a href="#3-与Iterator的关系" class="headerlink" title="3.与Iterator的关系"></a>3.与Iterator的关系</h2><p><code>Generator</code>函数就是遍历器的生成函数，可以把<code>Generator</code>赋值给对象的<code>Symbol.Iterator</code>属性，从而使得该对象可以被<code>Iterator</code>接口相关的语句遍历</p>
<pre><code class="js">const obj = {}
obj[Symbol.iterator] = function * () {
    yield 1;
    yield 2;
    yield 3;
}

[...obj]

for(const i of obj) {
    console.log(i)
}
</code></pre>
<h2 id="4-next方法参数"><a href="#4-next方法参数" class="headerlink" title="4. next方法参数"></a>4. next方法参数</h2><p><code>yield</code>表达式本身没有返回值，或者说返回值是<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作<code>上一个yield表达式的返回值</code></p>
<pre><code class="js">function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
</code></pre>
<p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致 <code>y</code> 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 <code>3</code> 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p>
<p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p>
<h2 id="5-next-throw-return"><a href="#5-next-throw-return" class="headerlink" title="5.next() throw() return()"></a>5.next() throw() return()</h2><ul>
<li><p>都是让Generator函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式</p>
</li>
<li><p><code>next()</code>是将上一个<code>yield</code>表达式替换成一个值</p>
<pre><code class="js">const g = function* (x, y) {
  let result = yield x + y;
  return result;
};

const gen = g(1, 2);
gen.next(); // Object {value: 3, done: false}

gen.next(1); // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = 1;
</code></pre>
</li>
<li><p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句</p>
<pre><code class="js">gen.throw(new Error(&#39;出错了&#39;)); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error(&#39;出错了&#39;));
</code></pre>
</li>
<li><p><code>return()</code>相当于将<code>yield</code>表达式替换成一个<code>return</code>语句</p>
<pre><code class="js">gen.return(2); // Object {value: 2, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;
</code></pre>
</li>
</ul>
<h2 id="6-yield"><a href="#6-yield" class="headerlink" title="6.yield*"></a>6.yield*</h2><p><code>yield*</code>表达式用来在一个Generator函数里面执行另一个Generator函数</p>
<pre><code class="js">function * foo() {
    yield &#39;a&#39;;
    yield &#39;b&#39;
}

function * bar() {
    yield &#39;x&#39;;
    yield foo();
    yield &#39;y&#39;
}

for(let item of bar()) {
    console.log(item) // x a b y
}
</code></pre>
<ul>
<li><p>任何数据结构只要有<code>iterator</code>接口，就能被<code>yield*</code>遍历</p>
<pre><code class="js">function * gen() {
    yield * [1,2,3]
}

gen().next()
</code></pre>
</li>
</ul>
<h2 id="7-处理异步"><a href="#7-处理异步" class="headerlink" title="7.处理异步"></a>7.处理异步</h2><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<ul>
<li>协程的执行流程<ul>
<li>协程A开始执行</li>
<li>协程A执行到一半，进入暂停，执行权转移到协程B</li>
<li>一段时间后，协程B交还执行权并恢复协程A的执行</li>
</ul>
</li>
</ul>
<h3 id="协程的Generator函数实现"><a href="#协程的Generator函数实现" class="headerlink" title="协程的Generator函数实现"></a>协程的Generator函数实现</h3><p>Generator函数是协程在ES6的实现，最大的特点就是可以交出函数的执行权(暂停执行)。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器，异步操作需要暂停的地方，都使用<code>yield</code>语句注明</p>
<pre><code class="js">function * gen(x) {
    var y = yield x + 2;
    return y
}
</code></pre>
<h3 id="Generator函数数据的交换和错误处理"><a href="#Generator函数数据的交换和错误处理" class="headerlink" title="Generator函数数据的交换和错误处理"></a>Generator函数数据的交换和错误处理</h3><p>Generator函数所具有的特性，使它成为异步编程的解决方案</p>
<ul>
<li>可以暂停执行和恢复执行，这是它能封装异步任务的根本原因</li>
<li>函数体内外的数据交换和错误处理机制，使它可以作为异步编程的完整解决方案</li>
</ul>
<p>调用<code>next()</code>方法返回值的value属性，是Generator函数向外输出数据，而在调用<code>next()</code>方法还可以接受参数，向<code>Generator</code>函数体内输入数据</p>
<pre><code class="js">function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next(2) // { value: 2, done: true }
</code></pre>
<p>Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误</p>
<pre><code class="js">function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){
    console.log(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw(&#39;出错了&#39;);
// 出错了
</code></pre>
<p>上面代码的最后一行，Generator 函数体外，使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<pre><code class="javascript">var fetch = require(&#39;node-fetch&#39;);

function* gen(){
  var url = &#39;https://api.github.com/users/github&#39;;
  var result = yield fetch(url);
  console.log(result);
}
</code></pre>
<p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p>
<p>执行这段代码的方法如下。</p>
<pre><code class="javascript">var g = gen();
var result = g.next();

result.value.then(function(data){
  return data.json();
}).then(function(data){
  g.next(data);
});
</code></pre>
<p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用<code>next</code>方法（第二行），执行异步任务的第一阶段。由于<code>Fetch</code>模块返回的是一个 Promise 对象，因此要用<code>then</code>方法调用下一个<code>next</code>方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h3 id="自动执行Generator"><a href="#自动执行Generator" class="headerlink" title="自动执行Generator"></a>自动执行Generator</h3><ul>
<li><p>封装一个基于Promise的自动执行机制</p>
<pre><code class="js">var fs = require(&#39;fs&#39;);

var readFile = function (fileName){
  return new Promise(function (resolve, reject){
    fs.readFile(fileName, function(error, data){
      if (error) return reject(error);
      resolve(data);
    });
  });
};

var gen = function* (){
  var f1 = yield readFile(&#39;/etc/fstab&#39;);
  var f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
</li>
<li><p>手动执行上面的Generator函数</p>
<pre><code class="js">var g = gen();

g.next().value.then(function(data){
  g.next(data).value.then(function(data){
    g.next(data);
  });
});
</code></pre>
<p>手动执行其实就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<pre><code class="js">function run(gen){
  var g = gen();

  function next(data){
    var result = g.next(data);
    if (result.done) return result.value;
    result.value.then(function(data){
      next(data);
    });
  }

  next();
}

run(gen);
</code></pre>
</li>
</ul>
