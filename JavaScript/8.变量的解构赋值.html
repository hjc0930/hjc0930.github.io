<hr>
<p>title: 解构赋值<br>excerpt: 解构赋值是通过ES6新增的Iterator接口来实现的<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
</ul>
<hr>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6允许按照一定的模式，从数组和对象中提取值，并赋值给对应的对象，这被称为解构赋值</p>
<p>解构赋值本质上属于<code>模式匹配</code>，也就是说，只要等式两边的模式相同，左边的变量就会被赋予对应的值</p>
<p>如果解构不成功，变量的值就会被赋予<code>undefined</code></p>
<p>解构赋值分为数组形式的解构赋值和对象形式的解构赋值，两者实现的原理不同</p>
<h2 id="1-数组形式的解构赋值"><a href="#1-数组形式的解构赋值" class="headerlink" title="1.数组形式的解构赋值"></a>1.数组形式的解构赋值</h2><p><strong>数组形式的解构赋值本质上是调用可迭代数据结构原型链上的<code>iterator</code>接口，遍历出对应的数据并进行赋值</strong></p>
<pre><code class="js">let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre>
<ul>
<li>如果右边不是数组(或者严格来说，不是可遍历的结构)，那么将会报错</li>
<li>对于Set结构，也可以使用数组进行解构赋值</li>
</ul>
<pre><code class="js">let [x,y,z] = new Set([1,2,3])
</code></pre>
<p>事实上，只要某种数据结构具有<code>Iterator</code>接口，都可以采用数组的形式解构赋值</p>
<pre><code class="js">function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
</code></pre>
<ul>
<li>默认值</li>
</ul>
<p>解构赋值允许指定默认值</p>
<pre><code class="js">let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;
</code></pre>
<p><strong>注意：ES6内部默认使用严格相等运算符判断一个位置是否有值，所以，只有当要解构的数组成员默认等于undefined时，默认值才会生效</strong></p>
<pre><code class="js">let [x = 1] = [undefined];
x // 1

let [x = 1] = [null]
x // null
</code></pre>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<pre><code class="js">function f() {
  console.log(&#39;aaa&#39;);
}

let [x = f()] = [1];
</code></pre>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<pre><code class="javascript">let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
</code></pre>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为字符串的包装类也是一个带有<code>iterator</code>的可迭代对象</p>
<pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre>
<h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><p>函数参数也可以使用解构赋值</p>
<pre><code class="js">function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
</code></pre>
<h2 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h2><p>对象的解构赋值和数组有所不同，数组的解构赋值变量名是按照数组的元素顺序一一赋值的，而<strong>对象解构赋值内部的运行机制其实就是直接查找同名的属性进行赋值</strong>，只要属性名正确，就能取到值，否则为<code>undefined</code></p>
<pre><code class="js">let { bar, foo } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // undefined
</code></pre>
<p>对象的解构赋值极大地方便了我们将现有对象的某个方法，单独取出来使用，并且支持重命名</p>
<pre><code class="js">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre>
<ul>
<li><p>默认值</p>
<p>对象的解构赋值也可以指定默认值</p>
</li>
</ul>
<pre><code class="js">var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5

var { message: msg = &#39;Something went wrong&#39; } = {};
msg // &quot;Something went wrong&quot;
</code></pre>
<p>默认值生成的条件与数组相同，对象的属性必须严格等于<code>undefined</code></p>
<pre><code class="js">var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
</code></pre>
<h2 id="3-解构中的装箱"><a href="#3-解构中的装箱" class="headerlink" title="3.解构中的装箱"></a>3.解构中的装箱</h2><p><strong>一些基本数据类型也可以进行解构取值。准确地来说，是因为在解构中发生了装箱操作，可以取到其对应包装类型上的方法</strong></p>
<p>例如：</p>
<h3 id="取字符串所对应String类中的length"><a href="#取字符串所对应String类中的length" class="headerlink" title="取字符串所对应String类中的length"></a>取字符串所对应String类中的length</h3><pre><code class="javascript">let { length } = &#39;hello&#39;;
length // 5
</code></pre>
<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>同样可以取到对应包装类型上的方法</p>
<pre><code class="js">let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
</code></pre>
<p>null和undefined没有对应的包装类型，无法转为对象，因此解构会直接报错</p>
<pre><code class="javascript">let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
</code></pre>
<h2 id="4-用途"><a href="#4-用途" class="headerlink" title="4.用途"></a>4.用途</h2><p>变量的解构赋值用途很多。</p>
<p><strong>（1）交换变量的值</strong></p>
<pre><code class="javascript">let x = 1;
let y = 2;

[x, y] = [y, x];
</code></pre>
<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p><strong>（2）从函数返回多个值</strong></p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<pre><code class="javascript">// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</code></pre>
<p><strong>（3）函数参数的定义</strong></p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code class="javascript">// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
</code></pre>
<p><strong>（4）提取 JSON 数据</strong></p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<pre><code class="javascript">let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre>
<p>上面代码可以快速提取 JSON 数据的值。</p>
<p><strong>（5）函数参数的默认值</strong></p>
<pre><code class="javascript">jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
</code></pre>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<p><strong>（6）遍历 Map 结构</strong></p>
<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code class="javascript">const map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code class="javascript">// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</code></pre>
<p><strong>（7）输入模块的指定方法</strong></p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<pre><code class="javascript">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>
