<hr>
<p>title: 原型与原型链<br>excerpt: 原型与原型链<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
</ul>
<hr>
<h2 id="1-prototype"><a href="#1-prototype" class="headerlink" title="1.prototype"></a>1.prototype</h2><p>JavaScript中，每一个函数都有一个<code>prototype</code>属性，这个属性是与生俱来的特质，特别强调，是函数，<strong>普通对象是没有这个属性的</strong></p>
<pre><code class="js">function Person() {

}
// 虽然写在注释里面，但是需要注意的是
// prototype 是函数才会有的属性 （哈哈哈，看来在JavaScript中函数果然是有特权的……）
Person.prototype.name = &quot;Kevin&quot;;
var person1 = new Person();
var person2 = new Person();

console.log(person1.name) // Kevin
console.log(person2.name) // Kevin
</code></pre>
<p>上面的代码中我们创建了一个构造函数<code>Person</code>，并且在实例原型上面添加了一个<code>name</code>属性赋值为<code>&quot;Kevin&quot;</code>;</p>
<p>然后分别创建了两个实例对象:<code>person1、person2</code>;</p>
<p>当我们打印两个实例对象上name属性时均输出了<code>Kevin</code>(可以亲自试一下)。</p>
<p>我们不禁疑惑，这个<code>Person.prototype</code>到底是什么，为什么在上面添加属性，在 构造函数的实例化对象上都能访问到呢？</p>
<p>其实 Person这个函数的<code>prototype</code>属性指向了一个对象(即:<code>Person.prototype</code>也是一个对象)。<strong>这个对象正是调用该构造函数而创建的实例的原型</strong>。也就是这个例子中的<code>person1</code>和<code>person2</code>的原型(即实例化的对象的<code>__proto__</code>属性指向构造函数的原型)。</p>
<p>那么什么是原型呢？即：</p>
<p>每个JavaScript对象(null除外)，在创建的时候都会与之关联另外一个对象，这个对象就是我们所说的原型，并且每一个对象都会从原型继承属性</p>
<p>上面的代码中我们并没有直接在<code>person1</code>和<code>person2</code>中添加name属性 但是这两个对象 却能够访问name属性,就是这个道理。</p>
<p>我们用一张图表示构造函数和实例原型之间的关系:</p>
<p><img src="/assets/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png"></p>
<ul>
<li><p>小结</p>
<p>在JavaScript中，每一个函数都会有一个<code>prototype</code>属性，这个属性指向它的实例原型对象，而每一个对象，在创建的时候，就会关联另一个对象，这个关联的对象，就是我们所说的原型</p>
</li>
</ul>
<h3 id="tips：new关键字的内部执行机制"><a href="#tips：new关键字的内部执行机制" class="headerlink" title="tips：new关键字的内部执行机制"></a>tips：<code>new</code>关键字的内部执行机制</h3><ul>
<li><p>创建一个空对象</p>
</li>
<li><p>将这个空对象的原型对象指向构造函数的原型</p>
</li>
<li><p>将构造函数的this指向这个空对象并执行</p>
</li>
<li><p>返回这个空对象</p>
</li>
<li><p>手写一个<code>new</code></p>
</li>
</ul>
<pre><code class="js">function myNew(...newArgs) {
    const [Fn,...arg] = newAtgs;
    // 创建一个空对象并将这个对象的原型指向构造函数的实例原型
    const obj = Object.create(Fn.prototype);
    // 将构造函数的this指向空对象并执行构造函数
    Fn.apply(obj, arg);
    // 返回这个对象
    return obj;
}
</code></pre>
<h2 id="2-proto"><a href="#2-proto" class="headerlink" title="2.__proto__"></a>2.<code>__proto__</code></h2><p>每一个JavaScript对象(null除外)，都有一个<code>__proto__</code>属性，作为实例对象和实例原型之间链接的桥梁</p>
<p><strong>这里强调，是对象，同样，因为函数也是对象，所以函数也有这个属性</strong></p>
<pre><code class="js">function Person() {

}

var person = new Person();
console.log(person.__proto__ === Person.prototype); //true;
</code></pre>
<p>有了第二个属性的帮助，我们就能更加全面的理解这张关系图了：</p>
<p><img src="/assets/%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p>
<p>通过上面的关系图我们可以看到,<code>构造函数Person</code> 和<code>实例对象person</code> 分别通过 <code>prototype</code>和__proto__ 和<code>实例原型Person.prototype</code>进行关联，根据箭头指向 我们不禁要有疑问：<strong>实例原型是否有属性指向构造函数或者实例呢？</strong></p>
<p>这时候该请出我们的第三个属性了：<code>constructor</code></p>
<h2 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h2><p>实例原型指向实例的属性倒是没有,因为一个构造函数可能会生成很多个实例，但是原型指向构造函数的属性倒是有的，这就是我们的<code>constructor</code>——每一个原型都有一个<code>constructor</code>属性指向关联的构造函数。</p>
<p>我们再来看一个示例：</p>
<pre><code>function Person() {

}
console.log(Person === Person.prototype.constructor); // true
</code></pre>
<p>好了到这里我们再完善下关系图：</p>
<p><img src="/assets/constructor.png"></p>
<h2 id="4-实例与原型"><a href="#4-实例与原型" class="headerlink" title="4.实例与原型"></a>4.实例与原型</h2><p><strong>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</strong></p>
<p>我们再举一个例子：</p>
<pre><code>  function Person() {

  }

  Person.prototype.name = &#39;Kevin&#39;;

  var person = new Person();

  person.name = &#39;Daisy&#39;;
  console.log(person.name) // Daisy

  delete person.name;
  console.log(person.name) // Kevin
复制代码
</code></pre>
<p>在上面这个例子中，我们给实例person添加了name 属性，当我们打印person.name的时候，结果自然为Daisy</p>
<p>但是当我们删除了<code>person</code>下面的name属性后，读取<code>person.name</code>，依然能够成功输出Kevin，实际情况是从 person 对象中找不到 name 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，也就是 <code>Person.prototype</code>中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p>
<p>但是我们不禁有疑问，如果万一没有找到该怎么办？</p>
<p>我们来看下一层的关系 原型的原型</p>
<h2 id="5-原型与原型链"><a href="#5-原型与原型链" class="headerlink" title="5.原型与原型链"></a>5.原型与原型链</h2><p>我们前面提到过，原型也是一个对象，那么既然是对象，那肯定有创建它的构造函数，这个构造函数就是<code>Object()</code></p>
<pre><code class="js">const obj = new Object()
obj.name = &#39;jiacheng&#39;;
console.log(obj.name) // jiacheng
</code></pre>
<p>其实原型对象就是通过Object构造函数生成的，结合之前我们所说的，实例__proto__指向构造函数的 prototype 所以我们再丰富一下我们的关系图；</p>
<img src="assets/对象的构造函数.png" style="zoom:75%;" />

<p>到了这里我们对于 构造函数、实例对象、实例原型之间的关系又有了进一步的认识。 说了这么多，终于可以介绍原型链了。</p>
<h2 id="6-原型链"><a href="#6-原型链" class="headerlink" title="6.原型链"></a>6.原型链</h2><p>那Object.prototype的原型呢？Object是根节点对象，再往上查找就是null</p>
<pre><code class="js">console.log(Object.prototype.__proto__ === null) // true
</code></pre>
<p>然而 null 究竟代表了什么呢？</p>
<p>引用阮一峰老师的 《undefined与null的区别》 就是：</p>
<p>null 表示“没有对象”，即该处不应该有值。</p>
<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>我们可以将null 也加入最后的关系图中，这样就比较完整了。</p>
<img src="assets/原型链的根节点.png" style="zoom:75%;" />

<p>上图中相互关联的原型组成的链状结构就是原型链，也就是红色的这条线</p>
<p>换句话来说，原型链就是<code>__proto__</code>这个属性连接的路径</p>
<h2 id="7-补充"><a href="#7-补充" class="headerlink" title="7.补充"></a>7.补充</h2><p>最后，补充三点大家可能不会注意到的地方：</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>首先是constructor，我们看一个例子：</p>
<pre><code class="js">function Person() {

}

var person = new Person();
console.log(person.constructor === Person); // true
</code></pre>
<p>当获取<code>person.constructor</code>时，其实 person 中并没有<code>constructor</code> 属性,当不能读取到<code>constructor</code>属性时，会从 person 的原型也就是 <code>Person.prototype</code>中读取，正好原型中有该属性，所以：</p>
<pre><code class="js">person.constructor === Person.prototype.constructor
</code></pre>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
<h3 id="构造函数的原型指向"><a href="#构造函数的原型指向" class="headerlink" title="构造函数的原型指向"></a>构造函数的原型指向</h3><p>我们知道构造函数的<code>prototype</code>属性指向它的实例原型，但构造函数同样是通过<code>Function()</code>这个构造函数创建出来的，所以它的<code>__proto__</code>属性指向<code>Function.prototype</code></p>
<pre><code class="js">console.log(fn.__proto__ === Function.prototype); // true
</code></pre>
<p>同样的<code>Object</code>和<code>Function</code>的<code>__proto__</code>属性也是指向<code>Function.prototype</code></p>
<pre><code class="js">console.log(Object.__proto__ === Function.prototype); // true
console.log(Function.__proto__ === Function.prototype); // true
</code></pre>
<h2 id="8-练习题"><a href="#8-练习题" class="headerlink" title="8.练习题"></a>8.练习题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><pre><code class="js">var F = function() {};

Object.prototype.a = function() {
  console.log(&#39;a&#39;);
};

Function.prototype.b = function() {
  console.log(&#39;b&#39;);
}

var f = new F();

f.a(); // a
f.b(); // error

F.a(); // a
F.b(); // b
</code></pre>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><pre><code class="js">var A = function() {};
A.prototype.n = 1;
var b = new A();
A.prototype = {
  n: 2,
  m: 3
}
var c = new A();

console.log(b.n); // 1
console.log(b.m); // undefined

console.log(c.n); // 2
console.log(c.m); // 3
</code></pre>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><pre><code class="js">var foo = {},
    F = function(){};
Object.prototype.a = &#39;value a&#39;;
Function.prototype.b = &#39;value b&#39;;

console.log(foo.a); // value a
console.log(foo.b); // undefined

console.log(F.a); // value a
console.log(F.b); // value b
</code></pre>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><pre><code class="js">function A() {}
function B(a) {
    this.a = a; // 有实例属性时，访问会优先调用实例属性，然后调用原型上的属性
}
function C(a) {
    if (a) {
        this.a = a;
    }
}
A.prototype.a = 1;
B.prototype.a = 1;
C.prototype.a = 1;

console.log(new A().a);  // 1
console.log(new B().a); // undefined
console.log(new C(2).a); // 2
</code></pre>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><pre><code class="js">console.log(123[&#39;toString&#39;].length + 123) // 124
</code></pre>
