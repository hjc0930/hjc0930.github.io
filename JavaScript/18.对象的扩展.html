<hr>
<p>title: 对象的扩展<br>excerpt: ES6新增对对象操作的扩展<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
</ul>
<hr>
<h2 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1.属性的简洁表示法"></a>1.属性的简洁表示法</h2><p>ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法</p>
<pre><code class="js">const foo = &#39;bar&#39;;
const baz = {foo};
baz // {foo: &quot;bar&quot;}

// 等同于
const baz = {foo: foo};
</code></pre>
<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>
<pre><code class="javascript">const cart = {
  _wheels: 4,

  get wheels () {
    return this._wheels;
  },

  set wheels (value) {
    if (value &lt; this._wheels) {
      throw new Error(&#39;数值太小了！&#39;);
    }
    this._wheels = value;
  }
}
</code></pre>
<h2 id="2-属性表达式"><a href="#2-属性表达式" class="headerlink" title="2.属性表达式"></a>2.属性表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p>
<pre><code class="javascript">// 方法一
obj.foo = true;

// 方法二
obj[&#39;a&#39; + &#39;bc&#39;] = 123;
</code></pre>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>
<pre><code class="javascript">var obj = {
  foo: true,
  abc: 123
};
</code></pre>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<pre><code class="javascript">let propKey = &#39;foo&#39;;

let obj = {
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123
};
</code></pre>
<h2 id="3-属性的可枚举性和遍历"><a href="#3-属性的可枚举性和遍历" class="headerlink" title="3.属性的可枚举性和遍历"></a>3.属性的可枚举性和遍历</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<pre><code class="javascript">let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
</code></pre>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>
<pre><code class="javascript">Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;).enumerable
// false

Object.getOwnPropertyDescriptor([], &#39;length&#39;).enumerable
// false
</code></pre>
<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>
<pre><code class="javascript">Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, &#39;foo&#39;).enumerable
// false
</code></pre>
<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<p>可以通过<code>Object.defineProperty()</code>来创建对象属性的描述</p>
<pre><code class="js">Object.defineProperty({}, &#39;invisible&#39;, {
    enumerable: false,
    value: &#39;hello&#39;
})
</code></pre>
<h2 id="4-属性的遍历"><a href="#4-属性的遍历" class="headerlink" title="4.属性的遍历"></a>4.属性的遍历</h2><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<pre><code class="javascript">Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]
</code></pre>
<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>
<h2 id="5-Object-is"><a href="#5-Object-is" class="headerlink" title="5.Object.is()"></a>5.Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<pre><code class="javascript">Object.is(&#39;foo&#39;, &#39;foo&#39;)
// true
Object.is({}, {})
// false
</code></pre>
<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>
<pre><code class="javascript">+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<h2 id="6-Object-assign"><a href="#6-Object-assign" class="headerlink" title="6.Object.assign()"></a>6.Object.assign()</h2><p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<pre><code class="javascript">const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre>
<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<pre><code class="javascript">const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre>
<h2 id="7-Object-getOwnPropertyDescriptors"><a href="#7-Object-getOwnPropertyDescriptors" class="headerlink" title="7.Object.getOwnPropertyDescriptors()"></a>7.Object.getOwnPropertyDescriptors()</h2><p>ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<pre><code class="js">const obj = {
  foo: 123,
  get bar() { return &#39;abc&#39; }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
</code></pre>
<h2 id="8-proto-，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#8-proto-，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="8.__proto__，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>8.<code>__proto__</code>，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<pre><code class="javascript">// es5 的写法
const obj = {
  method: function() { ... }
};
obj.__proto__ = someOtherObj;

// es6 的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... };
</code></pre>
<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<pre><code class="javascript">// 格式
Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf({}, null);
</code></pre>
<p>该方法等同于下面的函数。</p>
<pre><code class="javascript">function setPrototypeOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre>
<p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<pre><code class="javascript">Object.setPrototypeOf(1, {}) === 1 // true
Object.setPrototypeOf(&#39;foo&#39;, {}) === &#39;foo&#39; // true
Object.setPrototypeOf(true, {}) === true // true
</code></pre>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>
<pre><code class="javascript">Object.setPrototypeOf(undefined, {})
// TypeError: Object.setPrototypeOf called on null or undefined

Object.setPrototypeOf(null, {})
// TypeError: Object.setPrototypeOf called on null or undefined
</code></pre>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<pre><code class="javascript">Object.getPrototypeOf(obj);
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="javascript">function Rectangle() {
  // ...
}

const rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
</code></pre>
<h2 id="9-Object-keys-，Object-values-，Object-entries"><a href="#9-Object-keys-，Object-values-，Object-entries" class="headerlink" title="9.Object.keys()，Object.values()，Object.entries()"></a>9.Object.keys()，Object.values()，Object.entries()</h2><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<pre><code class="javascript">var obj = { foo: &#39;bar&#39;, baz: 42 };
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre>
<p>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>
<pre><code class="javascript">let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]
}
</code></pre>
<h2 id="10-Object-fromEntries"><a href="#10-Object-fromEntries" class="headerlink" title="10.Object.fromEntries()"></a>10.Object.fromEntries()</h2><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p>
<pre><code class="javascript">Object.fromEntries([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
])
// { foo: &quot;bar&quot;, baz: 42 }
</code></pre>
<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p>
<pre><code class="javascript">// 例一
const entries = new Map([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
]);

Object.fromEntries(entries)
// { foo: &quot;bar&quot;, baz: 42 }

// 例二
const map = new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);
Object.fromEntries(map)
// { foo: true, bar: false }
</code></pre>
<p>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</p>
<pre><code class="javascript">Object.fromEntries(new URLSearchParams(&#39;foo=bar&amp;baz=qux&#39;))
// { foo: &quot;bar&quot;, baz: &quot;qux&quot; }
</code></pre>
