<hr>
<p>title: 事件模型<br>excerpt: JavaScript事件流是为了描述父子元素之间事件触发的顺序<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
<li>DOM</li>
</ul>
<hr>
<blockquote>
<p><code>Javascript</code>事件使得<code>Html</code>网页具备互动性， 常见的加载事件、鼠标事件、自定义事件等</p>
</blockquote>
<h2 id="1-事件模型"><a href="#1-事件模型" class="headerlink" title="1.事件模型"></a>1.事件模型</h2><p><strong>JavaScript事件流是为了描述父子元素之间事件触发的顺序</strong></p>
<p><code>Javascript</code>事件模型一共有三种分别是</p>
<ol>
<li><p><strong>原始事件模型（DOM0级）</strong></p>
<p>所有的浏览器都支持的一种事件模型， 没有事件流，事件一旦发生马上进行处理，有两种方式可以实现原始事件模型</p>
<ul>
<li><p>以on开头的标签属性</p>
<pre><code class="html">&lt;p onclick=&quot;console.log(&#39;p&#39;)&quot;&gt;
    &lt;span onclick=&quot;console.log(&#39;span&#39;)&quot;&gt;clieck me&lt;/span&gt;
&lt;/p&gt;
&lt;!--
标签属性值是事件点击后要执行的javascript代码；
显示与行为没有分离；
没法为同一个事件绑定多个函数
事件发生在冒泡阶段(当点击span标签时，console依次打印span、p)
--&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>元素节点对象的事件属性</p>
<pre><code class="javascript">   var pDom = document.getElementById(&quot;p&quot;);

pDom.onclick = sayHello;

function sayHello() {
       console.log(&quot;hello world&quot;)
   }
   /**
   节点对象的事件属性值是函数
   没法为同一个事件绑定多个函数，后者会覆盖前者
   事件依然发生在冒泡阶段
   */
</code></pre>
</li>
</ul>
<ol start="2">
<li><p><strong>标准事件模型（DOM2级）</strong></p>
<p>标准事件模型是W3C组织制定的标准事件模型，现代浏览器（IE6～8之外）都支持，该模型将事件分为三个阶段：</p>
<ul>
<li><p>捕获阶段</p>
<p> 当某个事件触发时，事件会从window对象至上而下传播直至事件发生的目标元素，默认在这个过程中相应的事件监听函数不会触发。</p>
</li>
<li><p>目标阶段</p>
<p> 当事件传播到目标元素之后，执行目标元素上该事件的监听函数，如果没有就不执行。</p>
</li>
<li><p>冒泡阶段</p>
<p> 事件再从<strong>目标元素开始</strong>逐层向上传播， 如果途中有该事件的监听函数就执行；所有事件都有捕获阶段，但是只有部分事件才有冒泡阶段。</p>
</li>
</ul>
<p>依次给下面的div、ul、li、p、span元素添加一个click事件，并给该事件绑定两个监听函数（函数相同，但是调用阶段不同，一个在捕获阶段触发， 一个在冒泡阶段触发）</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div&gt;
    &lt;p&gt;
      &lt;span&gt;clieck me&lt;/span&gt;
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;script&gt;
    var elArray = [&#39;div&#39;, &#39;p&#39;, &#39;span&#39;]
    var domArray = elArray.map(item =&gt; {
      return document.querySelector(item)
    })
    domArray.forEach(item =&gt; {
      item.addEventListener(&#39;click&#39;, hello, false)
      item.addEventListener(&#39;click&#39;, hello, true)
    })
    function hello(event) {
      console.log(`
  target:${event.target.nodeName.toLowerCase()}
  currentTarget: ${event.currentTarget.nodeName.toLowerCase()}
  eventPhase: ${[&quot;not happen&quot;, &quot;capture&quot;, &quot;target&quot;, &quot;bubble&quot;][event.eventPhase]}`)
    }
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p><img src="/assets/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B.png" alt="事件模型"></p>
<p>当点击span时，事件从window对象至上而下传播， 先触发捕获阶段的事件，当事件传播到目标元素时触发目标元素的两个监听事件发生，所以在target阶段console打印了两次， 接着冒泡阶段事件由里向外传播，依次触发对应事件。</p>
</li>
<li><p><strong>IE事件模型</strong></p>
<p>在IE老版本浏览器中（IE6～8），事件对象不作为函数传入， 而是作为window全局对象的一个属性传入</p>
<p>window.event 现已基本不用了，太老了。</p>
</li>
</ol>
<h2 id="2-EventTarget"><a href="#2-EventTarget" class="headerlink" title="2.EventTarget"></a>2.EventTarget</h2><p>DOM的事件操作（监听和触发），都定义在<code>EventTarget</code>接口， 所有节点对象都部署了这个接口（window, document, element等对象）</p>
<p>该接口主要提供三个实例方法：</p>
<ul>
<li><code>addEventListener</code> : 添加事件监听器</li>
<li><code>removeEventListener</code> : 移除事件监听器</li>
<li><code>dispatchEvent</code> ： 派发事件</li>
</ul>
<h4 id="1-1-addEventListener"><a href="#1-1-addEventListener" class="headerlink" title="1.1 addEventListener"></a>1.1 addEventListener</h4><p><code>addEventListener(type, fn, useCapture)</code> 方法为事件添加对应的处理函数，在事件触发时调用。</p>
<p><code>type</code>: 事件名称（click、dubleclick、keydown…）</p>
<p><code>fn</code>： 事件触发时的回调函数</p>
<p><code>useCapture</code>: 指定回调函数是在捕获阶段调用还是在冒泡阶段调用， 默认值为false在冒泡阶段调用。</p>
<p><strong>可以通过该方法为同一个事件添加多个监听函数；</strong></p>
<p><strong>可以手动控制事件发生是在捕获阶段还是在冒泡阶段触发；</strong></p>
<p><strong>可以将子元素上的事件统一委托给父元素代为处理</strong></p>
<p>事件对象<strong>event</strong>以监听函数参数的形式出现， 其常用属性：</p>
<p>target： 监听事件所在的节点对象， 只会出现在目标阶段</p>
<p>currentTarget: 事件传播过程中当前所在的节点对象， 会发生在捕获、目标、冒泡三阶段</p>
<p>eventPhase: 事件发生的阶段： 0: 事件未发生； 1:捕获阶段；2:目标阶段； 3:冒泡阶段</p>
<h3 id="3-事件代理"><a href="#3-事件代理" class="headerlink" title="3.事件代理"></a>3.事件代理</h3><p>通过事件冒泡机制，统一将添加在子元素上的事件，委托给父元素代为处理，这样的好处：</p>
<p><strong>减少元素上的事件绑定、减少内存占用</strong></p>
<p><strong>统一在父元素上代为处理， 即便后面再动态添减元素，上面的事件依然有效</strong></p>
