<hr>
<p>title: 迭代器<br>excerpt: 迭代器<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
</ul>
<hr>
<h2 id="1-Iterator-遍历器-的概念"><a href="#1-Iterator-遍历器-的概念" class="headerlink" title="1.Iterator(遍历器)的概念"></a>1.Iterator(遍历器)的概念</h2><p>JavaScript原有的表示<code>集合</code>的数据，主要是数组和对象，ES6又添加了Map和Set结构，这样就有了四种数据集合</p>
<p>这样就需要一种统一的接口机制，来处理所有不同的数据结构</p>
<p>遍历器(Iterator)就是这样的一种机制，它是一个接口，为不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作(即依次处理该数据结构的所有成员)</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>
<h3 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h3><ul>
<li>创建一个指针对象，指向当前数据结构的起始位置，也就是说，遍历器的本质是一个指针对象</li>
<li>不断调用这个指针对象的<code>next</code>方法，返回数据结构的当前成员信息，具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象，其中，<code>value</code>就是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束</li>
</ul>
<pre><code class="js">var it = makeIterator([&#39;a&#39;, &#39;b&#39;]);

it.next() // { value: &quot;a&quot;, done: false }
it.next() // { value: &quot;b&quot;, done: false }
it.next() // { value: undefined, done: true }

function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex &lt; array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true};
    }
  };
}
</code></pre>
<h2 id="2-默认Iterator接口"><a href="#2-默认Iterator接口" class="headerlink" title="2.默认Iterator接口"></a>2.默认Iterator接口</h2><p>Iterator接口的目的，就是为所有的数据结构，提供一种统一的访问机制，即<code>for...of</code>循环</p>
<p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。</p>
<p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<pre><code class="javascript">let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let iter = arr[Symbol.iterator]();

iter.next() // { value: &#39;a&#39;, done: false }
iter.next() // { value: &#39;b&#39;, done: false }
iter.next() // { value: &#39;c&#39;, done: false }
iter.next() // { value: undefined, done: true }
</code></pre>
<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了</p>
<h2 id="3-调用-Iterator-接口的场合"><a href="#3-调用-Iterator-接口的场合" class="headerlink" title="3.调用 Iterator 接口的场合"></a>3.调用 Iterator 接口的场合</h2><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>
<p><strong>（1）解构赋值</strong></p>
<p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>
<pre><code class="javascript">let set = new Set().add(&#39;a&#39;).add(&#39;b&#39;).add(&#39;c&#39;);

let [x,y] = set;
// x=&#39;a&#39;; y=&#39;b&#39;

let [first, ...rest] = set;
// first=&#39;a&#39;; rest=[&#39;b&#39;,&#39;c&#39;];
</code></pre>
<p><strong>（2）扩展运算符</strong></p>
<p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<pre><code class="javascript">// 例一
var str = &#39;hello&#39;;
[...str] //  [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]

// 例二
let arr = [&#39;b&#39;, &#39;c&#39;];
[&#39;a&#39;, ...arr, &#39;d&#39;]
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
</code></pre>
<p>上面代码的扩展运算符内部就调用 Iterator 接口。</p>
<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p>
<pre><code class="javascript">let arr = [...iterable];
</code></pre>
<p><strong>（3）yield*</strong></p>
<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<pre><code class="javascript">let generator = function* () {
  yield 1;
  yield* [2,3,4];
  yield 5;
};

var iterator = generator();

iterator.next() // { value: 1, done: false }
iterator.next() // { value: 2, done: false }
iterator.next() // { value: 3, done: false }
iterator.next() // { value: 4, done: false }
iterator.next() // { value: 5, done: false }
iterator.next() // { value: undefined, done: true }
</code></pre>
<p><strong>（4）其他场合</strong></p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
