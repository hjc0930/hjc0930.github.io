<hr>
<p>title: ESM<br>excerpt: ESM<br>toc: true<br>tag: ‘JavaScript’<br>categories:</p>
<ul>
<li>前端</li>
<li>JavaScript</li>
</ul>
<hr>
<p>ESM是ES6引入的JS标准模块化规范，它的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系和输入和输出的变量。</p>
<p>功能：模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>
<p>特性</p>
<ul>
<li>编译时确定模块的依赖关系和输入输出变量</li>
<li>自动采用严格模式</li>
<li>一个模块就是一个文件，该模块内部的所有变量，外部无法获取</li>
</ul>
<p>好处</p>
<ul>
<li>使得静态分析成了可能，比如类型检验</li>
<li>不再需要<code>UMD</code>模块格式</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>
<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>
</ul>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>如果你希望外部能够读取模块内部的某个变量，必须通过<code>export</code>关键字输出该变量</p>
<ul>
<li>输出变量</li>
</ul>
<pre><code class="js">// profile.js
export const a = 1;
export const b = &#39;aaa&#39;;
export const c = 2021;

// 另一种写法
const a = 1;
const b = &#39;aaa&#39;;
const c = 2021;

export {a, b, c}
</code></pre>
<p>上面的这两种写法的等价的，但推荐使用第二种写法，因为这样可以在模块的末尾一眼看出该模块输出了哪些变量</p>
<ul>
<li>输出函数</li>
</ul>
<pre><code class="js">export function fn() {
    console.log()
}

// 另一种写法
function fn1(){}
function fn2() {}

export {fn1, fn2}
// 给函数重命名
export {fn1 as st1, fn2 as st2, fn2 as st3}
</code></pre>
<p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>
<ul>
<li>注意：<code>export</code>命令规定的是模块对外的接口，必须与模块内部的变量建立一一对应关系</li>
</ul>
<blockquote>
<p>例如以下的写法会报错</p>
</blockquote>
<pre><code class="js">export 1; // 报错
const a = 1;
export a; // 报错
</code></pre>
<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。<code>1</code>只是一个值，不是接口。</p>
<blockquote>
<p>正确的写法</p>
</blockquote>
<pre><code class="js">// 写法1
export const a = 1;

// 写法2
const a = 1;
export { a }

// 写法3
const a = 1;
export {a as m}
</code></pre>
<p>上面三种写法都是正确的，规定了对外的接口<code>a</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>
<blockquote>
<p>函数和类同样必须遵守上面的规则</p>
</blockquote>
<pre><code class="js">function fn() {}
export fn; // 报错

export function fn() {} // 正确

function fn() {}
export {fn} // 正确
</code></pre>
<ul>
<li><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，获取模块内部实时的值</li>
</ul>
<pre><code class="js">export let foo = &#39;bar&#39;;
setTimeout(() =&gt; foo = &#39;baz&#39;, 500);
</code></pre>
<p>上面的代码输出时是bar，500ms后会变为baz</p>
<ul>
<li><p><code>export</code>只能出现在模块的顶层，不能在块级作用域中</p>
</li>
<li><p><code>export default</code>：用于模块的默认导出，一个模块中只能存在一个<code>export default</code></p>
</li>
</ul>
<pre><code class="js">// index.js
export default function() {
    ...
}
// 加载，可以为该匿名函数指定任意名字
import aaa from &#39;./index.js&#39;
</code></pre>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><code>import</code>命令用于输入其他模块提供的功能</p>
<pre><code class="js">import { a, b, c } from &#39;./index.js&#39;;

// 直接使用
console.log(a);
console.log(b);
console.log(c);
</code></pre>
<p><code>import</code>命令也可以给加载的模块重命名</p>
<pre><code class="js">import { a as st1, b as st2, c as st3 } from &#39;./index.js&#39;;
</code></pre>
<ul>
<li><code>import</code>命令输入的变量都是只读的，因为它本质是输入接口，也就是说，不允许在加载模块的脚本里面，改写接口</li>
</ul>
<pre><code class="js">import {a} from &#39;./xxx.js&#39;

a = {}; // Syntax Error : &#39;a&#39; is read-only;
</code></pre>
<p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p>
<pre><code class="js">import { a } from &#39;./xxx.js&#39;

a.foo = &#39;hello&#39;; // 合法操作
</code></pre>
<ul>
<li><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>
</li>
<li><p><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
</li>
<li><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
</li>
</ul>
<pre><code class="js">// 报错
import { &#39;f&#39; + &#39;oo&#39; } from &#39;my_module&#39;;

// 报错
let module = &#39;my_module&#39;;
import { foo } from module;

// 报错
if (x === 1) {
  import { foo } from &#39;module1&#39;;
} else {
  import { foo } from &#39;module2&#39;;
}
</code></pre>
<ul>
<li><code>import</code>语句在没有<code>from</code>的情况下会执行所加载的模块，如果多次执行同一个模块的import，那么只会执行一次</li>
</ul>
<pre><code class="js">import &#39;lodash&#39;;
import &#39;lodash&#39;;
</code></pre>
<ul>
<li>如果执行的import语句对应的是同一个模块，等同于只加载一次</li>
</ul>
<pre><code class="js">import { foo } from &#39;my_module&#39;;
import { bar } from &#39;my_module&#39;; // 不建议这么写

// 等同于
import { foo, bar } from &#39;my_module&#39;;
</code></pre>
<h2 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>
<pre><code class="js">export { foo, bar } from &#39;my_module&#39;;

// 可以简单理解为
import { foo, bar } from &#39;my_module&#39;;
export { foo, bar };
</code></pre>
<h2 id="import-1"><a href="#import-1" class="headerlink" title="import()"></a>import()</h2><p><a href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块，并且返回一个<code>Promise</code>对象。</p>
<pre><code class="js">import(module)
</code></pre>
<h2 id="和CommonJs的差异"><a href="#和CommonJs的差异" class="headerlink" title="和CommonJs的差异"></a>和CommonJs的差异</h2><ul>
<li>CommonJS 模块输出的是一个值的拷贝，ESM 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ESM 模块是编译时输出接口。</li>
<li>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</li>
</ul>
<p>CommonJS模块，都是只能在运行时确定这些东西。</p>
<pre><code class="js">// CommonJS模块
let { stat, exists, readfile } = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre>
<p>上面的代码实质是整体加载fs模块，生成一个对象，然后从这三个对象上面读取三个方法，这种加载称为运行时加载，因为只有在运行时才能得到这个对象，导致完全无法在编译时做”静态优化”</p>
<ul>
<li><code>NodeJs</code>从13.2版本开始支持ESM模块</li>
</ul>
<h3 id="CommonJS-模块加载-ESM-模块"><a href="#CommonJS-模块加载-ESM-模块" class="headerlink" title="CommonJS 模块加载 ESM 模块"></a><code>CommonJS </code>模块加载 ESM 模块</h3><p><code>CommonJs</code>不能通过<code>require()</code>命令加载ESM模块，只能通过<code>import()</code>命令加载</p>
<pre><code class="js">(
  async () =&gt; {
      await import(modlue)
  }
)()
</code></pre>
<p><code>require()</code>不支持 ESM模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p>
<h3 id="ESM模块加载Commonjs"><a href="#ESM模块加载Commonjs" class="headerlink" title="ESM模块加载Commonjs"></a>ESM模块加载<code>Commonjs</code></h3><p>ESM模块的<code>import</code>命令可以加载<code>CommonJs</code>模块，但只能整体加载，不能单独加载单一的输出项</p>
